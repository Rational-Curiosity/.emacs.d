#+TITLE:  Emacs Configuration File
#+AUTHOR: e
#+EMAIL:  no-reply@
#+PROPERTY:  header-args:elisp   :results silent
#+PROPERTY:  header-args:elisp+  :tangle (expand-file-name "init.el" user-emacs-directory)
#+PROPERTY:  header-args:elisp+  :eval no-export
# Save to tangle file: C-c C-v C-t

* Doc

Emacs buind from source

#+begin_src sh
./configure \
    --without-sound --without-xpm --without-selinux --without-xwidgets\
    --without-jpeg --without-tiff --without-gif --without-rsvg\
    --without-imagemagick --without-libotf --without-m17n-flt --without-xaw3d\
    --without-toolkit-scroll-bars --without-gpm --without-gconf\
    --without-gsettings --with-png --with-tree-sitter\
    --enable-link-time-optimization --with-mailutils\
    --with-cairo-xcb --with-x-toolkit=gtk3 --with-dbus --with-json --with-xml2\
    --with-zlib --with-native-compilation CFLAGS='-O2 -mtune=native -march=native'
#+end_src

#+RESULTS:

- minimal emacs

#+begin_src sh
./configure \
  --without-sound --without-xpm --without-selinux \
  --without-xwidgets --without-cairo --without-x-toolkit \
  --without-jpeg --without-tiff --without-gif --without-rsvg \
  --without-imagemagick --without-libotf --without-m17n-flt \
  --without-xaw3d --without-toolkit-scroll-bars --without-gpm --without-dbus \
  --without-gconf --without-gsettings --without-makeinfo \
  --with-json --with-xml2 --with-zlib \
  --with-native-compilation CFLAGS='-O2 -mtune=native -march=native'
#+end_src

#+RESULTS:

Compile .el files with

#+begin_src sh
emacs -batch -f batch-byte-compile emacs.el
mv emacs.elc init.elc
#+end_src

#+RESULTS:

emacs 27 avoids ~(package-initialize)~

* Pre emacs 28

#+begin_src elisp
(when (< emacs-major-version 28)
  (message "Making config compatible with emacs < 28")
  (defun repeat-mode ())

  (defun generate-new-buffer-advice (orig-fun name &optional _inhibit)
    (funcall orig-fun name))
  (advice-add 'generate-new-buffer :around 'generate-new-buffer-advice)

  (defun string-replace (fromstring tostring instring)
    (replace-regexp-in-string (regexp-quote fromstring) tostring instring t t)))
#+end_src

* Libraries
** Config utils

#+begin_src elisp
(require 'cl-lib)
;; [ Package cl is deprecated
;; (eval-when-compile
;;   (require 'cl))
;; ]

;;;;;;;;;;;;;;;;
;; My library ;;
;;;;;;;;;;;;;;;;
(defun remove-nth-element (nth list)
  "Efficient remove NTH element in LIST."
  (if (zerop nth) (cdr list)
    (let ((last (nthcdr (1- nth) list)))
      (setcdr last (cddr last))
      list)))

(defun assoc-keys (keys alist &optional test-fun)
  "Recursively find KEYS in ALIST using TEST-FUN."
  (if keys
      (cond
       ((listp alist)
        (assoc-keys (cdr keys) (cdr (assoc (car keys) alist test-fun)) test-fun))
       ((vectorp alist)
        (mapcar (lambda (al)
                  (assoc-keys (cdr keys) (cdr (assoc (car keys) al test-fun)) test-fun)) alist)))
    alist))

(defun eval-string (string)
  "Evaluate elisp code stored in a string."
  (eval (car (read-from-string string))))

;; keymaps
(defun keymap-symbol (keymap)
  "Return the symbol to which KEYMAP is bound, or nil if no such symbol exists."
  (catch 'gotit
    (mapatoms (lambda (sym)
                (and (boundp sym)
                     (eq (symbol-value sym) keymap)
                     (not (eq sym 'keymap))
                     (throw 'gotit sym)))
              obarray)))

(defun keymaps-with-binding (key)
  (let (keymaps)
    (mapatoms (lambda (ob) (if (boundp ob)
                               (let ((keymap (symbol-value ob)))
                                 (if (keymapp keymap)
                                     (let ((m (lookup-key keymap key)))
                                       (if (and m (or (symbolp m) (keymapp m)))
                                           (push keymap keymaps)))))))
              obarray)
    keymaps))

(defun locate-key-binding (key)
  "Determine keymaps KEY is defined"
  (interactive "kPress key: ")
  (let ((key-str (key-description key)))
    (mapatoms (lambda (ob) (when (and (boundp ob) (keymapp (symbol-value ob)))
                             (let ((m (lookup-key (symbol-value ob) key)))
                               (when m
                                 (message "key: %s, keymap: %S, bind: %s" key-str ob m)))))
              obarray)))

;; Recursive byte compile
(defun byte-compile-force-recompile-recursively (directory)
  "Force recompile '.el' when '.elc' file exists and compile when
does not exist.  Files in subdirectories of DIRECTORY are processed also."
  (interactive "DByte compile and force recompile recursively directory: ")
  (byte-recompile-directory directory 0 t))

(defun byte-compile-emacs-config (&optional force)
  "Recompile '.el' when '.elc' is out of date or does not exist.
'init.el' file and 'el/' folder are processed recursively."
  (interactive)
  (let ((emacs-el-directory (expand-file-name "el/" user-emacs-directory)))
    (save-some-buffers
     nil (lambda ()
           (let ((file (buffer-file-name)))
             (and file
                  (string-match-p emacs-lisp-file-regexp file)
                  (file-in-directory-p file emacs-el-directory)))))
    (force-mode-line-update)
    (with-current-buffer (get-buffer-create byte-compile-log-buffer)
      (setq default-directory (expand-file-name user-emacs-directory))
      ;; compilation-mode copies value of default-directory.
      (unless (derived-mode-p 'compilation-mode)
        (emacs-lisp-compilation-mode))
      (let ((default-directory emacs-el-directory))
        (let ((directories (list default-directory))
              (skip-count 0)
              (fail-count 0)
              (file-count 0)
              (dir-count 0)
              directory
              last-dir)
          (displaying-byte-compile-warnings
           (dolist (file
                    (delete-dups
                     (remove
                      nil
                      (mapcar
                       (lambda (file)
                         (if (stringp file)
                             (if (file-exists-p file) file)
                           (if (and (boundp file)
                                    (setq file (symbol-value file))
                                    (string-match emacs-lisp-file-regexp file)
                                    (file-exists-p file))
                               file)))
                       `(user-init-file
                         early-init-file
                         ,(expand-file-name "init.el" user-emacs-directory)
                         ,(expand-file-name "early-init.el" user-emacs-directory)
                         ,(expand-file-name "config.el" user-emacs-directory)
                         package-quickstart-file custom-file)))))
             (cl-incf
              (pcase (byte-recompile-file
                      file force 0)
                ('no-byte-compile skip-count)
                ('t file-count)
                (_
                 (message "Failed initial file %s" file)
                 fail-count))))
           (while directories
             (setq directory (car directories))
             ;; (message "Checking %s..." directory)
             (dolist (file (directory-files directory))
               (let ((source (expand-file-name file directory)))
                 (if (file-directory-p source)
                     (and (not (member file '("RCS" "CVS")))
                          (not (eq ?\. (aref file 0)))
                          (not (file-symlink-p source))
                          ;; This file is a subdirectory.  Handle them differently.
                          (setcdr (last directories) (list source)))
                   ;; It is an ordinary file.  Decide whether to compile it.
                   (if (and (string-match emacs-lisp-file-regexp source)
                            ;; The next 2 tests avoid compiling lock files
                            (file-readable-p source)
                            (not (string-match "\\`\\.#" file))
                            (not (auto-save-file-name-p source))
                            (not (string-equal dir-locals-file
                                               (file-name-nondirectory source))))
                       (progn (cl-incf
                               (pcase (byte-recompile-file source force 0)
                                 ('no-byte-compile skip-count)
                                 ('t file-count)
                                 (_
                                  (message "Failed %s" source)
                                  fail-count)))
                              (if (not (eq last-dir directory))
                                  (setq last-dir directory
                                        dir-count (1+ dir-count))))))))
             (setq directories (cdr directories))))
          (message "Done (Total of %d file%s compiled%s%s%s)"
                   file-count (if (= file-count 1) "" "s")
                   (if (> fail-count 0) (format ", %d failed" fail-count) "")
                   (if (> skip-count 0) (format ", %d skipped" skip-count) "")
                   (if (> dir-count 1)
                       (format " in %d directories" dir-count) "")))))))

;; [ counting visual lines
(defun count-visual-lines-in-line (line max-cols)
  (let ((line-len (length line))
        pos
        (visual-lines 1))
    (while (< max-cols line-len)
      (cl-incf visual-lines)
      (setq pos (1+ (or (cl-position
                         ?  line :end max-cols :from-end t)
                        max-cols))
            line (substring line pos)
            line-len (- line-len pos)))
    visual-lines))

(defun count-visual-lines-in-string (string max-cols)
  (apply '+ (mapcar (lambda (line)
                      (count-visual-lines-in-line line max-cols))
                    (split-string string "\n"))))
;; ]

;; [ get current function name <nativecomp incompatible>
;; thanks to: https://emacs.stackexchange.com/a/2312
;; (defun call-stack ()
;;   "Return the current call stack frames."
;;   (let ((frames)
;;         (frame)
;;         (index 5))
;;     (while (setq frame (backtrace-frame index))
;;       (push frame frames)
;;       (cl-incf index))
;;     (cl-delete-if-not 'car frames)))

;; (defmacro compile-time-function-name ()
;;   "Get the name of calling function at expansion time."
;;   (symbol-name
;;    (cl-cadadr
;;     (cl-caddr
;;      (cl-find-if (lambda (frame)
;;                 (ignore-errors (equal (car (cl-caddr frame)) 'defalias)))
;;               (reverse (call-stack)))))))
;; ]

;; Converts calls to COMPOSE to lambda forms with everything written
;; out and some things written as direct function calls.
;; Example: (compose #'1+ #'2* #'-) => (LAMBDA (X) (1+ (2* (- X))))
(cl-define-compiler-macro compose (&rest functions)
  (cl-labels ((sharp-quoted-p (x)
                              (and (listp x)
                                   (eql (cl-first x) 'function)
                                   (symbolp (cl-second x)))))
    `(lambda (x) ,(cl-reduce #'(lambda (fun arg)
                                 (if (sharp-quoted-p fun)
                                     (list (cl-second fun) arg)
                                   (list 'funcall fun arg)))
                             functions
                             :initial-value 'x
                             :from-end t))))

;; Eval checking bound before
(defmacro bound-and-eval (func &rest args)
  "Ensures FUNC exist and eval with ARGS."
  (list 'and (list 'fboundp func) (list 'apply func (list 'quote args))))

;; Return function that check bound before
(defmacro lambda-bound-and-eval (func &rest args)
  "Return lambda that ensures FUNC exist and eval with ARGS."
  `(lambda () (and (fboundp ,func) (apply ,func (quote ,args)))))

;; write message in *Messages* buffer with colors
(defun message-log (format-string &rest args)
  (with-current-buffer "*Messages*"
    (save-excursion
      (goto-char (point-max))
      (let ((inhibit-read-only t))
        (unless (zerop (current-column)) (insert "\n"))
        (insert (apply 'format format-string args))
        (insert "\n")))))

(defun message-color (format-string &rest args)
  "Acts like `message' but preserves string properties in the *Messages* buffer."
  (let ((message-log-max nil))
    (apply 'message format-string args))
  (apply 'message-log format-string args))

;; Silent messages
;; Usage:
;; (advice-add '<orig-fun> :around #'message-silent-advice)
(defun message-silent-advice (orig-fun &rest args)
  "Silent and eval ORIG-FUN with ARGS."
  (let ((message-log-max nil)
        (inhibit-message t))
    (apply orig-fun args)))

;; Inhibit messages on echo
;; Usage:
;; (advice-add '<orig-fun> :around #'message-inhibit-advice)
(defun message-inhibit-advice (orig-fun &rest args)
  "Inhibit message and eval ORIG-FUN with ARGS."
  (let ((inhibit-message t))
    (apply orig-fun args)))

;; Truncate messages
;; Usage:
;; (advice-add '<orig-fun> :around #'message-truncate-advice)
(defun message-truncate-advice (orig-fun &rest args)
  "Stablish `message-truncate-lines' and eval ORIG-FUN with ARGS."
  (let ((message-truncate-lines t))
    (apply orig-fun args)))

(defmacro eval-and-when-daemon (frame &rest body)
  "When starting daemon wait FRAME ready before BODY."
  (declare (indent defun))
  (let ((fun-args (list (or frame 'frame))))
    `(if (daemonp)
         (let ((fun-name (intern (symbol-name (gensym "when-daemon-hook"))))
               (fun-args (quote ,fun-args))
               (body (quote ,body)))
           (defalias fun-name
             `(lambda ,fun-args
                ,@body
                (remove-hook 'after-make-frame-functions (quote ,fun-name))
                (unintern (quote ,fun-name))))
           (add-hook 'after-make-frame-functions fun-name))
       (funcall (lambda ,fun-args ,@body) (selected-frame)))))

;; Load all libraries in directory
(defun load-all-in-directory (dir)
  "`load' all elisp libraries in directory DIR which are not already loaded."
  (interactive "D")
  (let ((libraries-loaded (mapcar #'file-name-sans-extension
                                  (delq nil (mapcar #'car load-history)))))
    (dolist (file (directory-files dir t ".+\\.elc?$"))
      (let ((library (file-name-sans-extension file)))
        (unless (member library libraries-loaded)
          (load library nil t)
          (push library libraries-loaded))))))

;; Establish safe dir-locals variables
(defun safe-dir-locals (dir list &optional class)
  "Set local variables for directory.
DIR directory.
LIST list of local variables.
CLASS optional class name, DIR default."
  (unless class
    (setq class dir))
  (dir-locals-set-class-variables class list)
  (dir-locals-set-directory-class dir class)
  (dolist (item list)
    (setq safe-local-variable-values (nconc safe-local-variable-values (cdr item))))
  class)


;; regex inside each file in list
;; return first occurence
(defun re-search-in-files (regex files &optional first)
  "Search REGEX match inside the files of FILES list.
If FIRST is not-nil return first file in files with regex match.
Otherwise return a list of files which regex match."
  (let ((matched '()))
    (while (and
            files
            (not (and first matched)))
      (let* ((file (pop files))
             (buffer (get-file-buffer file)))
        (if buffer
            (with-current-buffer buffer
              (save-excursion
                (goto-char (point-min))
                (when (re-search-forward regex nil t)
                  (push file matched))))
          (let ((buffer (find-file-noselect file t t)))
            (with-current-buffer buffer
              (when (re-search-forward regex nil t)
                (push file matched)))
            (kill-buffer buffer)))))
    (if first
        (car matched)
      matched)))

(defun comint-truncate-buffers (regexp &optional verbose)
  (dolist (buffer (buffer-list))
    (let ((name (buffer-name buffer)))
      (when (and name (not (string-equal name ""))
                 (string-match-p regexp name))
        (with-current-buffer buffer
          (save-excursion
            (goto-char (point-max))
            (forward-line (- comint-buffer-maximum-size))
            (beginning-of-line)
            (let ((lines (1- (line-number-at-pos))))
              (when (< 0 lines)
                (when verbose
                  (message "Truncating %s lines in buffer `%s'"
                           lines name))
                (let ((inhibit-read-only t))
                  (delete-region (point-min) (point)))))))))))

;;;;;;;;;;
;; Bugs ;;
;;;;;;;;;;
(defun bug-check-function-bytecode (function bytecode-base64 &optional inhibit-log)
  "Check if FUNCTION has BYTECODE-BASE64.  If INHIBIT-LOG is non-nil inhibit log when differs."
  (cond
   ((null (fboundp function))
    (unless inhibit-log
      (message-color #("WARN function `%s' not defined"
                       0 4 (face warning)) function))
    nil)
   ((featurep 'comp)
    t)
   (t
    (let ((current-bytecode-base64
           (condition-case nil
               (base64-encode-string (aref (symbol-function function) 1) t)
             (error
              (unless inhibit-log
                (message-color #("WARN missing function bytecode, maybe %s is a built-in function in 'C source code' or not bytecompiled"
                                 0 4 (face warning)) function))))))
      (if (string-equal
           current-bytecode-base64
           bytecode-base64)
          t
        (unless inhibit-log
          (message-color #("WARN bug fixed for different version of %s with b64 %s see %s"
                           0 4 (face warning))
                         (if (fboundp 'find-function-library)
                             (find-function-library function)
                           (symbol-name function))
                         current-bytecode-base64
                         load-file-name))
        nil)))))


(require 'help-fns)
(defun bug-function-bytecode-into-base64 (function)
  "Write the bytecode of FUNCTION (a symbol).
When called from lisp, FUNCTION may also be a function object."
  (interactive
   (let* ((fn (function-called-at-point))
          (enable-recursive-minibuffers t)
          (val (completing-read
                (if fn
                    (format "Bytecode of function (default %s): " fn)
                  "Bytecode of function: ")
                #'help--symbol-completion-table
                (lambda (f) (fboundp f))
                t nil nil
                (and fn (symbol-name fn)))))
     (unless (equal val "")
       (setq fn (intern val)))
     (unless (and fn (symbolp fn))
       (user-error "You didn't specify a function symbol"))
     (unless (fboundp fn)
       (user-error "Symbol's function definition is void: %s" fn))
     (list fn)))
  (insert "\""
          (condition-case nil
              (base64-encode-string (aref (symbol-function function) 1) t)
            (error
             (user-error "Missing function bytecode, maybe %s is a built-in function in 'C source code' or not bytecompiled" function)))
          "\""))

;; escape special characters
;; (let ((print-escape-newlines t))
;;   (prin1-to-string "..."))

(defun bug-ediff-defun-at-point ()
  (interactive)
  (let* ((defnA (or (thing-at-point 'defun t)
                    (user-error "Not function at point")))
         (posnA (progn
                  (string-match
                   "^[^;]*(\\(defun\\|cl-defun\\|defmacro\\|cl-defmethod\\) \\([-_a-zA-Z0-9]+\\)"
                   defnA)
                  (1- (match-beginning 1))))
         (nameA (or (match-string 2 defnA)
                    (user-error "Not name of function at point")))
         (library (or (find-lisp-object-file-name (intern nameA) 'defun)
                      (user-error "Library containing `%s' not found" nameA)))
         (orig-bufnA (buffer-name)))
    (find-file (find-library-name library))
    (goto-char (point-min))
    (search-forward-regexp (concat "defun[ \t\r\n]+\\_<" nameA "\\_>"))
    (let* ((defnB (thing-at-point 'defun t))
           (posnB (progn
                    (string-match
                     "^[^;]*(\\(defun\\|cl-defun\\|defmacro\\|cl-defmethod\\) [-_a-zA-Z0-9]+"
                     defnB)
                    (1- (match-beginning 1))))
           (bufnA (concat "*bug-ediff A [" orig-bufnA "]*"))
           (bufnB (concat "*bug-ediff B [" (buffer-name) "]*")))
      (switch-to-buffer bufnA)
      (emacs-lisp-mode)
      (insert (replace-regexp-in-string "\t" "        " (substring defnA posnA)))
      (goto-char (point-min))
      (setq defnA (thing-at-point 'defun t))
      (insert defnA)
      (delete-region (point) (point-max))
      (unless (bolp)
        (insert "\n"))
      (indent-region (point-min) (point-max))
      (set-buffer-modified-p nil)
      (switch-to-buffer bufnB)
      (emacs-lisp-mode)
      (insert (replace-regexp-in-string "\t" "        " (substring defnB posnB)))
      (goto-char (point-min))
      (setq defnB (thing-at-point 'defun t))
      (insert defnB)
      (delete-region (point) (point-max))
      (unless (bolp)
        (insert "\n"))
      (indent-region (point-min) (point-max))
      (set-buffer-modified-p nil)
      (ediff-buffers bufnA bufnB))))

;;;;;;;;;;;;
;; Errors ;;
;;;;;;;;;;;;
;; Protect from errors
(defun rollback-on-error-inc ()
  "Increment `rollback-on-error-counter' fake variable."
  (cl-incf rollback-on-error-counter))
(defun rollback-on-error-advice (orig-fun &rest args)
  "Rollback (ORIG-FUN ARGS) evaluation on error.

Example: (advice-add 'mt-interchange-thing-up :around #'rollback-on-error-advice)"
  ;; (undo-boundary)  ; <undo>
  (advice-add 'undo-boundary :before #'rollback-on-error-inc)
  (unwind-protect
      (let ((rollback-on-error-counter 1))
        (condition-case-unless-debug raised-error
            (apply orig-fun args)
          (error (primitive-undo rollback-on-error-counter
                                 buffer-undo-list)
                 (error "%s: %s rolled back (%i)"
                        orig-fun
                        (error-message-string raised-error)
                        rollback-on-error-counter))))
    (advice-remove 'undo-boundary #'rollback-on-error-inc)))


;;;;;;;;;;;;;;;
;; Processes ;;
;;;;;;;;;;;;;;;
(defun process-get-attrs (pid attrs-process)
  (let ((process-attrs (process-attributes pid)))
    (cons `(pid . ,pid) (mapcar (lambda (attr)
                                  (assoc attr process-attrs))
                                attrs-process))))

(defun processes-named (names attrs-processes)
  (cl-remove-if-not (lambda (attrs-process)
                      (member (cdr (assoc 'comm attrs-process)) names))
                    attrs-processes))

(defun processes-children (pid attrs-processes)
  (cl-remove-if-not (lambda (attrs-process)
                      (let ((ppid (cdr (assoc 'ppid attrs-process))))
                        (and (integerp ppid) (= pid ppid))))
                    attrs-processes))

(defun processes-children-all (pid attrs-processes)
  (let ((pids (list pid))
        children processes)
    (while pids
      (setq children nil)
      (mapc (lambda (pid) (setq children (nconc children (processes-children pid attrs-processes)))) pids)
      (setq processes (nconc processes children))
      (setq pids (mapcar (lambda (attrs-process) (cdr (assoc 'pid attrs-process))) children)))
    processes))

(defmacro processes-run-with-timer-cond-body (secs repeat process-names
                                                   processes-number-variable
                                                   processes-number-condition
                                                   &rest body)
  (declare (indent 5))
  `(run-with-timer
    ,secs ,repeat
    (lambda ()
      ;; [ Limit python's processes of all emacs
      ;; (let ((attrs-processes (mapcar (lambda (x) (process-get-attrs x '(ppid comm))) (list-system-processes)))
      ;;       (emacs-processes))
      ;;   (mapc (lambda (x) (nconc emacs-processes (processes-children-all (cdr (assoc 'pid x)) attrs-processes))) (processes-named "emacs.exe" attrs-processes))
      ;;   (processes-named "python.exe" emacs-processes))
      ;; ]
      ;; Limit python's processes of every emacs
      (let ((,processes-number-variable
             (length (processes-named
                      ,process-names
                      (processes-children-all
                       (emacs-pid)
                       (mapcar (lambda (x) (process-get-attrs x '(ppid comm)))
                               (list-system-processes)))))))
        (when
            ,processes-number-condition
          ,@body)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; With eval after load replacement ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defvar named-code-hash-table
  (make-hash-table :test 'eq))

(defmacro named-code-declare (name &rest body)
  (declare (indent 1) (debug t))
  (let ((fun (gethash (eval name) named-code-hash-table)))
    (if fun
        (if (eq fun t)
            `(progn ,@body)
          `(puthash ,name (lambda () (funcall (quote ,fun)) ,@body)
                    named-code-hash-table))
      `(puthash ,name (lambda () ,@body)
                named-code-hash-table))))

(defun named-code-eval (name)
  (let ((fun (gethash name named-code-hash-table)))
    (puthash name t named-code-hash-table)
    (when fun
      (funcall fun))))

(defmacro map-append (map key value)
  `(let ((item-list (assoc ,key ,map)))
     (if item-list
         (setcdr (last item-list) (list ,value))
       (setq ,map (cons (list ,key ,value) ,map)))))

(defun eval-after-config (key &rest args)
  "Ensures FUNC exist and eval with ARGS."
  (when config-p
    (if (boundp 'after-config-functions)
        (let ((count 0))
          (dolist (fun (assoc-default key after-config-functions))
            (apply fun args)
            (cl-incf count))
          (message "Called `%s' %i functions" key count)
          (assoc-delete-all key after-config-functions))
      (message-color #("WARN Missing `after-config-functions' variable"
                       0 4 (face warning))))))

(defun inhibit-mode-line ()
  (setq mode-line-format nil))
#+end_src

** Random functions

#+begin_src elisp
(defun random-goto-line ()
  (interactive)
  (goto-char (point-min))
  (forward-line (random (count-lines (point-min) (point-max)))))

(defun random-goto-char ()
  (interactive)
  (goto-char (random (- (point-max) (point-min)))))

(defun nmcli-connect-vpn (up-down name)
  (interactive
   (list
    (completing-read "Choose up/down(up): " '("up" "down") nil t nil nil "up")
    (completing-read "Choose VPN:"
                     (split-string
                      (shell-command-to-string
                       "nmcli --colors no -t -f name connection")
                      "\n" t)
                     nil t)))
  (start-process "*nmcli connect vpn*" " *nmcli connect vpn*"
                 "nmcli" "--ask" "--colors" "no" "-t" "-w" "0" "connection"
                 up-down name))

;; (defun icomplete-vertical-kill-ring-insert (&optional arg)
;;   "Insert item from kill-ring, selected with completion."
;;   (interactive "*p")
;;   (if (or (eq last-command 'yank)
;;           (if (active-minibuffer-window)
;;               (setq last-command 'yank)))
;;       (yank-pop arg)
;;     (let ((candidate
;;            (completing-read
;;             "Yank: "
;;             (lambda (string pred action)
;;               (if (eq action 'metadata)
;;                   '(metadata (display-sort-function . identity)
;;                              (cycle-sort-function . identity))
;;                 (complete-with-action action kill-ring string pred)))
;;             nil t)))
;;       (when (and candidate (region-active-p))
;;         ;; the currently highlighted section is to be replaced by the yank
;;         (delete-region (region-beginning) (region-end)))
;;       (insert candidate))))
#+end_src

* Backup and Undo

#+begin_src elisp
;;;;;;;;;;;;;;;;;;;;;;;;
;; Backup & Auto save ;;
;;;;;;;;;;;;;;;;;;;;;;;;
;; create the autosave dir if necessary, since emacs won't.
;; with backup directory is not necessary
(let ((saves-directory (expand-file-name "saves/" user-emacs-directory)))
  (let ((backup-directory (concat saves-directory "backup/"))
        (auto-save-directory (concat saves-directory "auto-save/"))
        (auto-save-list-directory (concat saves-directory "auto-save/session/")))
    (make-directory backup-directory t)
    (make-directory auto-save-directory t)
    (make-directory auto-save-list-directory t)

    (setq undo-limit (eval-when-compile
                       (* 1024 1024))
          undo-outer-limit (eval-when-compile
                             (* 10 1024 1024))
          undo-strong-limit (eval-when-compile
                              (* 3 1024 1024))
          savehist-file (concat saves-directory "minibuffer-history")
          backup-directory-alist
          `((".*" . ,backup-directory))
          auto-save-list-file-prefix auto-save-list-directory
          auto-save-file-name-transforms
          (nconc auto-save-file-name-transforms
                 `((".*" ,auto-save-directory t)))
          ;; 10 input events #<file-name>#
          auto-save-interval 10
          ;; 10 seconds
          auto-save-timeout 10
          ;; create local .#<file-name> to avoid collisions
          create-lockfiles nil)))

(defun buffer-reset-undo (&optional buffer)
  "Reset BUFFER undo information.
No argument or nil as argument means do this for the current buffer."
  (interactive)
  (with-current-buffer (if buffer (get-buffer buffer) (current-buffer))
    (setq buffer-undo-list nil)))

(defun undo-all (arg)
  (interactive "P")
  (undo (length buffer-undo-list))
  (when arg
    (setq buffer-undo-list nil)))

;; (defun undo-advice (&optional arg)
;;   (recenter nil t))
;; (advice-add #'undo :after 'undo-advice)
(defun allow-undoing-advice (&rest _args)
  (when (eq last-command 'undo)
    (setq this-command 'undo)))
(advice-add #'recenter-top-bottom :after 'allow-undoing-advice)
(global-set-key (kbd "C-/") 'undo-redo)
#+end_src

* Miscellaneous

#+begin_src elisp
;; Inhibit dangerous functions
(defun suspend-emacs (&rest _args)
  (interactive)
  (message "Command `suspend-emacs' is dangerous in EXWM and Tiling Window Managers."))

(with-eval-after-load 'frame
  (defun suspend-frame (&rest _args)
    (interactive)
    (message "Command `suspend-frame' is dangerous in EXWM and Tiling Window Managers.")))

;;;;;;;;;;;;;;;
;; Clipboard ;;
;;;;;;;;;;;;;;;
(defun copy-buffer-file-name ()
  (interactive)
  (kill-new (abbreviate-file-name buffer-file-name)))

(defun copy-buffer-file-name-nondirectory ()
  (interactive)
  (kill-new (file-name-nondirectory buffer-file-name)))

(defun copy-buffer-file-name-directory ()
  (interactive)
  (kill-new (file-name-directory buffer-file-name)))

;;;;;;;;;;
;; Math ;;
;;;;;;;;;;
(defun round-on-region (start end arg)
  "Rounds the numbers of the region."
  (interactive "r\nP")
  (save-restriction
    (narrow-to-region start end)
    (goto-char 1)
    (let ((case-fold-search nil))
      (while (search-forward-regexp "\\([0-9]+\\.[0-9]+\\)" nil t)
        (replace-match
         (format
          (concat "%0." (if arg (number-to-string arg) "0") "f")
          (string-to-number (match-string 1))) t t)))))

;;;;;;;;;;;;;;;;
;; Mode utils ;;
;;;;;;;;;;;;;;;;
(defun reload-current-major-mode ()
  "Reloads the current major mode."
  (interactive)
  (let ((mode major-mode))
    (message "%s is going to be unloaded" mode)
    (unload-feature mode t)
    (message "%s unloaded" mode)
    (funcall-interactively mode)
    (message "%s loaded" mode)))
#+end_src

* Custom

#+begin_src elisp
;; [ custom
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(load (substring custom-file 0 -3))
;; ]
#+end_src

* Personal config

#+begin_src elisp
(defvar config-p
  (load (expand-file-name "config" user-emacs-directory) t))
#+end_src

* Mode line

#+begin_src elisp
;; utf8 symbols for modes
;; - abbrev-mode      "ⓐ"
;; - company-mode     "Ⓒ"
;; - flyspell-mode    "ⓕ"
;; - helm-mode        "Ⓗ"
;; - helm-cscope-mode "ⓢ"
;; - helm-gtags-mode  "ⓣ"
;; - yas-minor-mode   "ⓨ"
;; - undo-tree-mode   "ⓤ"

;; Remove minor mode from minor-mode-alist
;; (setq minor-mode-alist
;;       (cl-delete '<minor-mode> minor-mode-alist :key 'car))
;; or
;; (setq minor-mode-alist
;;       (assq-delete-all '<minor-mode> minor-mode-alist))

;; (require 'mini-modeline)                                       ;; + with mini-modeline
;; (setcar (cdr (assq 'mini-modeline-mode minor-mode-alist)) nil)  ;; + with mini-modeline

;;;;;;;;;;;
;; Faces ;;
;;;;;;;;;;;
(defface mode-line-correct
  '((t :foreground "green4"))
  "Correct" :group 'mode-line)
(defface mode-line-notready
  '((t :foreground "brown4"))
  "Correct" :group 'mode-line)
(defface mode-line-warning
  '((t :foreground "yellow4"))
  "Warning" :group 'mode-line)
(defface mode-line-error
  '((t :foreground "red4"))
  "Error" :group 'mode-line)

(defface mode-line-modified
  '((t :foreground "Red" :weight bold))
  "Modified" :group 'mode-line)

(defface mode-line-read-only
  '((t :foreground "Yellow"))
  "Read only" :group 'mode-line)

(defface mode-line-not-modified
  '((t :foreground "Green"))
  "Not modified" :group 'mode-line)

(defface mode-line-project-name
  '((t :foreground "SaddleBrown" :weight bold))
  "Project name" :group 'mode-line)

(with-eval-after-load 'abbrev
  (setcar (cdr (assq 'abbrev-mode minor-mode-alist))
          (propertize "A"
                      'face '(:foreground "light slate blue" :weight bold))))
(with-eval-after-load 'compile
  (setcar (cdr (assq 'compilation-shell-minor-mode minor-mode-alist)) "Cs")
  (setcar (cdr (assq 'compilation-minor-mode minor-mode-alist)) "Cp"))
(with-eval-after-load 'autorevert
  (setq auto-revert-mode-text "Ar"))

;;;;;;;;;;;;;;;;;;;;;;
;; Sort minor modes ;;
;;;;;;;;;;;;;;;;;;;;;;
(defun mode-line-sort-minors ()
  (interactive)
  (dolist (minor '(abbrev-mode yas-minor-mode company-mode caps-lock-show-mode))
    (let ((pos (cl-position-if (lambda (x) (eq minor (car x))) minor-mode-alist)))
      (when pos
        (setcdr (last minor-mode-alist) (list (elt minor-mode-alist pos)))
        (setq minor-mode-alist
              (remove-nth-element pos minor-mode-alist))))))
(dolist (package '("abbrev" "yasnippet" "company"))
  (with-eval-after-load package
    (mode-line-sort-minors)))

;;;;;;;;;;;;;;;;;;;;;;;
;; Battery mode line ;;
;;;;;;;;;;;;;;;;;;;;;;;

;; (require 'battery)
;; (bug-check-function-bytecode
;;  'battery-update
;;  "CIUGAAggGcbHCZ5BIUAayAuDJgAKp4MmAAoMWIMmAMkLCSKCJwDKywqnhTQACg1YhTQAzM3OJRYQKs8ghw==")
;; (eval-and-when-daemon frame
;;   (display-battery-mode)
;;   (setq battery-mode-line-format "%p%L")
;;   (defun battery-update ()
;;     "Update battery status information in the mode line."
;;     (let ((data (and battery-status-function (funcall battery-status-function))))
;;       (let ((percentage (car (read-from-string (cdr (assq ?p data)))))
;;             (supplier (cdr (assq ?L data)))
;;             percentage-str
;;             percentage-face)
;;         (if (numberp percentage)
;;             (setq percentage-str (int-to-string (truncate percentage))
;;                   percentage-face (if (<= percentage battery-load-critical)
;;                                       '(:foreground "red")
;;                                     `(:foreground ,(format "#%02i%02i00"
;;                                                            (- 100 percentage)
;;                                                            (- percentage 1)))))
;;           (setq percentage-str percentage
;;                 percentage-face '(:foreground "yellow")))
;;         (setq battery-mode-line-string
;;               (propertize (concat
;;                            percentage-str
;;                            (cond ((string-equal supplier "AC")
;;                                   (if (display-graphic-p) "🔌" ":"))
;;                                  ((string-equal supplier "BAT")
;;                                   (if (display-graphic-p) "🔋" "!"))
;;                                  ((string-equal supplier "N/A")
;;                                   "?")
;;                                  (t supplier)))
;;                           'font-lock-face
;;                           percentage-face
;;                           'help-echo "Battery status information"))))
;;     (force-mode-line-update)))

;;;;;;;;;;;;;;;;;;;;;;
;; Define mode line ;;
;;;;;;;;;;;;;;;;;;;;;;
(setq eol-mnemonic-unix "LF"
      eol-mnemonic-dos "CRLF"
      eol-mnemonic-mac "CR")

(defvar-local mode-line-cached nil)
(defvar-local mode-line-identification nil)

(line-number-mode -1)
(defvar-local mode-line-display-line-number "%l")
(defun mode-line-set-line-number-format ()
  (setq mode-line-display-line-number
        (if (memq display-line-numbers '(relative visual))
            "" "%l")))
(add-hook 'display-line-numbers-mode-hook 'mode-line-set-line-number-format)

(setq-default
 ;; #     #
 ;; ##   ## #    # #      ######
 ;; # # # # #    # #      #
 ;; #  #  # #    # #      #####
 ;; #     # #    # #      #
 ;; #     # #    # #      #
 ;; #     #  ####  ###### ######
 mode-line-mule-info
 `(""
   (current-input-method
    (:propertize ("" current-input-method-title)
                 help-echo (concat
                            ,(purecopy "Current input method: ")
                            current-input-method
                            ,(purecopy "\n\
mouse-2: Disable input method\n\
mouse-3: Describe current input method"))
                 local-map ,mode-line-input-method-map
                 mouse-face mode-line-highlight))
   ,(propertize
     "%z"
     'face '(:foreground "SaddleBrown")
     'help-echo 'mode-line-mule-info-help-echo
     'mouse-face 'mode-line-highlight
     'local-map mode-line-coding-system-map)
   (:propertize
    (:eval (mode-line-eol-desc))
    face (:foreground "DarkOliveGreen")))
 ;; #     #
 ;; ##   ##  ####  #####  # ###### # ###### #####
 ;; # # # # #    # #    # # #      # #      #    #
 ;; #  #  # #    # #    # # #####  # #####  #    #
 ;; #     # #    # #    # # #      # #      #    #
 ;; #     # #    # #    # # #      # #      #    #
 ;; #     #  ####  #####  # #      # ###### #####
 mode-line-modified
 '(:eval
   (cond
    ((not (or (and (buffer-file-name) (file-remote-p buffer-file-name))
              (verify-visited-file-modtime (current-buffer))))
     (propertize "M" 'face '(:foreground "#ffffff" :background "#c82829")
                 'help-echo "Modified outside Emacs!\nRevert first!"))
    ((buffer-modified-p)
     (propertize (if buffer-read-only
                     "R"
                   "×")
                 'face 'mode-line-modified
                 'help-echo (if (and (buffer-file-name) (not (file-remote-p buffer-file-name)))
                                (format-time-string
                                 "Modified on %T %Y-%m-%d."
                                 (nth 5 (file-attributes (buffer-file-name))))
                              "Buffer Modified")
                 'local-map '(keymap (mode-line keymap (mouse-1 . save-buffer)))))
    (buffer-read-only (propertize "R"
                                  'face 'mode-line-read-only
                                  'help-echo "Read-Only Buffer"))
    (t (propertize "-" 'face 'mode-line-not-modified))))
 ;; ######
 ;; #     #  ####   ####  # ##### #  ####  #    #
 ;; #     # #    # #      #   #   # #    # ##   #
 ;; ######  #    #  ####  #   #   # #    # # #  #
 ;; #       #    #      # #   #   # #    # #  # #
 ;; #       #    # #    # #   #   # #    # #   ##
 ;; #        ####   ####  #   #   #  ####  #    #
 mode-line-position
 `((:propertize
    (:eval mode-line-display-line-number)
    face (:foreground "#fe3" :weight bold))
   (:propertize
    ":%c "
    local-map mode-line-column-line-number-mode-map
    mouse-face mode-line-highlight
    help-echo "Line number and Column number\n\
mouse-1: Display Line and Column Mode Menu")
   (:propertize
    mode-line-percent-position
    face (:foreground "DodgerBlue")
    local-map ,mode-line-column-line-number-mode-map
    mouse-face mode-line-highlight
    ;; XXX needs better description
    help-echo "Size indication mode\n\
mouse-1: Display Line and Column Mode Menu")
   (size-indication-mode
    ,(propertize
      " %I"
      'local-map mode-line-column-line-number-mode-map
      'mouse-face 'mode-line-highlight
      ;; XXX needs better description
      'help-echo "Size indication mode\n\
mouse-1: Display Line and Column Mode Menu")))
 ;; #     #
 ;; ##   ##  ####  #####  ######  ####
 ;; # # # # #    # #    # #      #
 ;; #  #  # #    # #    # #####   ####
 ;; #     # #    # #    # #           #
 ;; #     # #    # #    # #      #    #
 ;; #     #  ####  #####  ######  ####
 mode-line-modes
 (let ((recursive-edit-help-echo "Recursive edit, type C-M-c to get out"))
   (list (propertize "%[" 'help-echo recursive-edit-help-echo)
         " "
         `(:propertize ("" mode-name)
                       face (:foreground "DarkBlue" :weight ultra-bold)
                       help-echo "Major mode\n\
mouse-1: Display major mode menu\n\
mouse-2: Show help for major mode\n\
mouse-3: Toggle minor modes"
                       mouse-face mode-line-highlight
                       local-map ,mode-line-major-mode-keymap)
         '("" mode-line-process)
         `(:propertize ("" minor-mode-alist)
                       mouse-face mode-line-highlight
                       help-echo "Minor mode\n\
mouse-1: Display minor mode menu\n\
mouse-2: Show help for minor mode\n\
mouse-3: Toggle minor modes"
                       local-map ,mode-line-minor-mode-keymap)
         (propertize "%n" 'help-echo "mouse-2: Remove narrowing from buffer"
                     'mouse-face 'mode-line-highlight
                     'local-map (make-mode-line-mouse-map
                                 'mouse-2 #'mode-line-widen))
         (propertize "%]" 'help-echo recursive-edit-help-echo)
         " "))
 ;; #     #                         #
 ;; ##   ##  ####  #####  ######    #       # #    # ######
 ;; # # # # #    # #    # #         #       # ##   # #
 ;; #  #  # #    # #    # #####     #       # # #  # #####
 ;; #     # #    # #    # #         #       # #  # # #
 ;; #     # #    # #    # #         #       # #   ## #
 ;; #     #  ####  #####  ######    ####### # #    # ######
 mode-line-format
 '((:eval (mode-line-justified))))

(defun force-mode-line-buffer-identification (&rest _args)
  (setq mode-line-cached nil)
  (force-mode-line-update))

(add-hook 'window-configuration-change-hook
          'force-mode-line-buffer-identification)
(add-hook 'after-save-hook
          'force-mode-line-buffer-identification)
(add-hook 'after-revert-hook
          'force-mode-line-buffer-identification)
(advice-add 'rename-buffer :after 'force-mode-line-buffer-identification)

;; [ mini-modeline options
;; (setq mini-modeline-truncate-p nil
;;       mini-modeline-echo-duration 5)
;; (mini-modeline-mode t)  ;; + with mini-modeline
;; ]

(defun project-root-directory (&optional dir)
  (locate-dominating-file (or dir default-directory) ".git/"))

(defun mode-line-abbreviate-file-name ()
  (when-let ((name (buffer-file-name)))
    (let ((dominating-file (project-root-directory))
          (abbrev-name (abbreviate-file-name name)))
      (if dominating-file
          (concat (propertize
                   (file-name-nondirectory
                    (directory-file-name
                     (file-name-directory dominating-file)))
                   'face 'mode-line-project-name)
                  (substring abbrev-name (1- (length dominating-file))))
        abbrev-name))))

(defun abbrev-string-try (len string)
  (let ((old ""))
    (while (and (< len (string-width string))
                (not (string-equal string old)))
      (setq old string
            string (replace-regexp-in-string
                    "\\(\\([A-Za-z]\\{3\\}\\)[A-Za-z]+\\).*\\'"
                    "\\2"
                    string t nil 1))))
  string)

(defvar mode-line-filename-replacements
  `(("test"     . ,(propertize "T" 'face 'hi-red-b 'help-echo "test"))
    ("config"   . ,(propertize "C" 'face 'hi-red-b 'help-echo "config"))
    ("class"    . ,(propertize "C" 'face 'hi-green-b 'help-echo "class"))
    ("object"   . ,(propertize "O" 'face 'hi-green-b 'help-echo "object"))
    ("api"      . ,(propertize "A" 'face 'hi-green-b 'help-echo "api"))
    ("util"     . ,(propertize "U" 'face 'hi-green-b 'help-echo "util"))
    ("bug"      . ,(propertize "B" 'face 'hi-green-b 'help-echo "bug"))
    ("library"  . ,(propertize "L" 'face 'hi-green-b 'help-echo "library"))
    ("librarie" . ,(propertize "L" 'face 'hi-green-b 'help-echo "librarie"))
    ("invoice"  . ,(propertize "I" 'face 'hi-red-b 'help-echo "invoice"))
    ("resource" . ,(propertize "R" 'face 'hi-red-b 'help-echo "resource")))
  "Mode line file name replacements")

(defun abbrev-strings-try (len string &rest strings)
  (let ((i -1)
        (len-list (length strings))
        (len-short (- len (string-width string)))
        len-strings)
    (while (and (< (cl-incf i) len-list)
                (< len-short (setq len-strings (apply '+ (mapcar 'string-width strings)))))
      (let ((len-i (- (string-width (nth i strings)) (- len-strings len-short)))
            (old ""))
        (while (and (< len-i (string-width (nth i strings)))
                    (not (string-equal (nth i strings) old)))
          (setq old (nth i strings))
          (let ((istring (nth i strings)))
            (if (string-match "\\(\\([A-Za-z]\\{2\\}\\)[A-Za-z]+\\).*\\'"
                              istring)
                (setcar (nthcdr i strings)
                        (concat
                         (substring istring 0 (match-beginning 1))
                         (let ((isubtext (substring istring
                                                    (match-beginning 2)
                                                    (match-end 2))))
                           (propertize
                            isubtext
                            'face
                            `(:weight bold :slant italic
                                      :inherit ,(get-text-property 0 'face isubtext))
                            'help-echo (substring istring
                                                  (match-beginning 1)
                                                  (match-end 1))))
                         (substring istring (match-end 1)))))))))
    (if (< 0 (setq len-strings (- len (apply '+ (mapcar 'string-width strings)))))
        (let ((len-list (length mode-line-filename-replacements))
              (i -1))
          (while (and (< len-strings (string-width string))
                      (< i len-list))
            (let ((replacement (nth i mode-line-filename-replacements)))
              (let ((pos (string-match-p (car replacement) string)))
                (if pos
                    (setq string
                          (concat
                           (substring string 0 pos)
                           (cdr replacement)
                           (substring string (+ pos (length (car replacement))))))
                  (cl-incf i))))))))
  `(,string ,@strings))

(defun abbrev-string (len string)
  (if (< len (string-width string))
      (let ((len/2 (max 1 (/ len 2))))
        (concat
         (substring string 0 (- len/2 1))
         (propertize "…"
                     'face 'error
                     'help-echo (buffer-file-name))
         (substring string (- len/2))))
    string))

(defun mode-line-justified ()
  (let ((mode-line-pre-identification
         (format-mode-line '("%e"
                             mode-line-position
                             ;; mode-line-front-space  ;; display-graphic-p
                             mode-line-mule-info
                             mode-line-client
                             mode-line-modified
                             mode-line-remote)))
        (mode-line-post-identification
         (format-mode-line '("%e"
                             mode-line-modes
                             mode-line-misc-info))))
    (let* ((post-len (string-width mode-line-post-identification))
           (others-len (+ (string-width mode-line-pre-identification)
                          post-len)))
      (if (equal (car mode-line-cached) others-len)
          (list (string-replace "%" "%%" mode-line-pre-identification)
                (car mode-line-identification)
                (propertize " "
                            'display
                            `((space :align-to (- (+ right right-fringe right-margin 1)
                                                  ,(+ post-len (cdr mode-line-cached))))))
                (cdr mode-line-identification)
                (string-replace "%" "%%" mode-line-post-identification))
        (let ((len (- (window-total-width) others-len))
              (vc-name (or vc-mode ""))
              (final-name (or (mode-line-abbreviate-file-name) (buffer-name))))
          (if (< len (+ (string-width final-name) (string-width vc-name)))
              (if (string-match "\\`\\(.*/\\)\\([^/]*\\)\\'" final-name)
                  (let ((dir-name (match-string 1 final-name))
                        (base-name (match-string 2 final-name)))
                    (if vc-mode
                        (let ((result (abbrev-strings-try
                                       len base-name dir-name vc-name)))
                          (setq vc-name (car (cdr (cdr result)))
                                len (- len (string-width vc-name))
                                final-name (abbrev-string
                                            len (concat
                                                 (car (cdr result))
                                                 (car result)))))
                      (let ((result (abbrev-strings-try
                                     len base-name dir-name)))
                        (setq final-name (abbrev-string
                                          len (concat
                                               (car (cdr result))
                                               (car result)))))))
                (if vc-mode
                    (let ((result (abbrev-strings-try len "" final-name vc-name)))
                      (setq vc-name (car (cdr (cdr result)))
                            len (- len (string-width vc-name))
                            final-name (abbrev-string len (car (cdr result)))))
                  (setq final-name (abbrev-string
                                    len (abbrev-string-try len final-name))))))
          (setq mode-line-identification
                (cons
                 (string-replace "%" "%%" final-name)
                 (string-replace "%" "%%" vc-name))
                mode-line-cached (cons others-len (string-width vc-name)))
          (list (string-replace "%" "%%" mode-line-pre-identification)
                (car mode-line-identification)
                (propertize " "
                            'display
                            `((space :align-to (- (+ right right-fringe right-margin 1)
                                                  ,(+ post-len (cdr mode-line-cached))))))
                (cdr mode-line-identification)
                (string-replace "%" "%%" mode-line-post-identification)))))))

;;;;;;;;;;;;;;;;
;; Projectile ;;
;;;;;;;;;;;;;;;;
(with-eval-after-load 'projectile
  (defun projectile-mode-menu (event)
    (interactive "@e")
    (let ((minor-mode 'projectile-mode))
      (let* ((map (cdr-safe (assq minor-mode minor-mode-map-alist)))
             (menu (and (keymapp map) (lookup-key map [menu-bar]))))
        (if menu
            (popup-menu (mouse-menu-non-singleton menu))
          (message "No menu available")))))

  (defvar mode-line-projectile-mode-keymap
    (let ((map (make-sparse-keymap)))
      (define-key map [mode-line down-mouse-1] 'projectile-mode-menu)
      (define-key map [mode-line mouse-2] 'mode-line-minor-mode-help)
      (define-key map [mode-line down-mouse-3] mode-line-mode-menu)
      (define-key map [header-line down-mouse-3] mode-line-mode-menu)
      map) "\
Keymap to display projectile options.")

  (defun mode-line-perform-projectile-replacement (in)
    "If path IN is inside a project, use its name as a prefix."
    (let ((proj (projectile-project-p)))
      (if (stringp proj)
          (let* ((replacement (propertize
                               (funcall projectile-mode-line-function)
                               'face 'mode-line-project-name
                               'mouse-face 'mode-line-highlight
                               'help-echo "Minor mode\n\
mouse-1: Display minor mode menu\n\
mouse-2: Show help for minor mode\n\
mouse-3: Toggle minor modes"
                               'local-map mode-line-projectile-mode-keymap))
                 (short (replace-regexp-in-string
                         (concat "^" (regexp-quote (abbreviate-file-name proj)))
                         replacement
                         in t t)))
            (if (string= short in)
                (let* ((true-in (abbreviate-file-name (file-truename in)))
                       (true-short
                        (replace-regexp-in-string
                         (concat "^" (regexp-quote (abbreviate-file-name (file-truename proj))))
                         replacement true-in t t)))
                  (if (string= true-in true-short) in true-short))
              short))
        in)))

  (defun mode-line-abbreviate-file-name ()
    (let ((name (buffer-file-name)))
      (if name
          (mode-line-perform-projectile-replacement (abbreviate-file-name name))))))
#+end_src

* Version control

#+begin_src elisp
;; (defun vc-refresh-state-when-vc-mode ()
;;   (when vc-mode
;;     (setq mode-line-cached nil)
;;     (vc-refresh-state)))
;; (add-hook 'after-revert-hook 'vc-refresh-state-when-vc-mode)

(with-eval-after-load 'vc-hooks
  (defun vc-mode-line-advice (_file &optional backend)
    "Colorize and abbrev `vc-mode'."
    (when (stringp vc-mode)
      (let ((noback (replace-regexp-in-string
                     (concat "^ " (regexp-quote (symbol-name backend)))
                     " " vc-mode t t)))
        (setq vc-mode
              (propertize noback
                          'face (cl-case (elt noback 1)
                                  (?- 'mode-line-not-modified)
                                  ((?: ?@) 'mode-line-read-only)
                                  ((?! ?\\ ??) 'mode-line-modified)))))))
  (advice-add 'vc-mode-line :after 'vc-mode-line-advice))
#+end_src

* Font

#+begin_src elisp
;; set a default font
;; $(sudo fc-cache -rfv)
(setq inhibit-compacting-font-caches t)
(eval-and-when-daemon frame
  (when (display-graphic-p frame)
    (with-selected-frame frame
      (cond
       ((member "Hack Nerd Font Mono" (font-family-list))
        (set-face-attribute 'default nil
                            :family "Hack Nerd Font Mono"
                            :height 90
                            :foundry "unknown"
                            :weight 'regular
                            :slant 'normal
                            :width 'normal)
        (message "Monospace font: Hack Nerd Font Mono Family"))
       ((member "Hack" (font-family-list))
        (set-face-attribute 'default nil
                            :family "Hack"
                            :height 90
                            :foundry "unknown"
                            :weight 'regular
                            :slant 'normal
                            :width 'normal)
        (message "Monospace font: Hack Family"))
       ((member "Monaco" (font-family-list))
        (set-face-attribute 'default nil
                            :family "Monaco"
                            :height 90
                            :foundry "unknown"
                            :weight 'regular
                            :slant 'normal
                            :width 'normal)
        (message "Monospace font: Monaco Family"))
       ((member "Fira Code" (font-family-list))
        (set-face-attribute 'default nil
                            :family "Fira Code"
                            :height 90
                            :foundry "unknown"
                            :weight 'regular
                            :slant 'normal
                            :width 'normal)
        (message "Monospace font: Fira Code Family"))
       ((member "DejaVu Sans Mono" (font-family-list))
        (set-face-attribute 'default nil
                            :family "DejaVu Sans Mono"
                            :height 100
                            :foundry "unknown"
                            :weight 'regular
                            :slant 'normal
                            :width 'normal)
        (message "Monospace font: DejaVu Sans Mono Family"))
       ((member "Iosevka Term" (font-family-list)) ;; Iosevka case
        (set-face-attribute 'default nil
                            :family "Iosevka Term"
                            :height 100
                            :foundry "unknown"
                            :weight 'light
                            :slant 'normal
                            :width 'normal)
        (message "Monospace font: Iosevka Term Family"))
       ((member "-outline-Iosevka Term Light-light-normal-normal-mono-*-*-*-*-c-*-iso8859-1"
                (x-list-fonts "*" nil (selected-frame)))
        (set-face-attribute 'default nil
                            :font "-outline-Iosevka Term Light-light-normal-normal-mono-*-*-*-*-c-*-iso8859-1"
                            :height 100)
        (message "Monospace font: Iosevka Term Light"))
       ((member "-outline-Unifont-normal-normal-normal-*-*-*-*-*-p-*-iso8859-1"
                (x-list-fonts "*" nil (selected-frame)))
        (set-face-attribute 'default nil
                            :font "-outline-Unifont-normal-normal-normal-*-*-*-*-*-p-*-iso8859-1"
                            :height 100)
        (message "Monospace font: Unifont"))
       ;; sudo apt install fonts-mononoki
       ((member "mononoki" (font-family-list))
        (set-face-attribute 'default nil
                            :family "Mononoki"
                            :height 90
                            :foundry "unknown"
                            :weight 'regular
                            :slant 'normal
                            :width 'normal)
        (message "Monospace font: Mononoki Family"))
       (t ;; default case
        (message "Monospace font not found")
        (set-face-attribute 'default nil
                            :height 100
                            :weight 'light
                            :slant 'normal
                            :width 'normal)))
      ;; [ Iosevka 3.0.0 supports unicode
      ;; (let ((font-spec-args
      ;;        (cond
      ;;         ((member "DejaVu Sans Mono monospacified for Iosevka Term Light"
      ;;                  (font-family-list))
      ;;          '(:family "DejaVu Sans Mono monospacified for Iosevka Term Light"))
      ;;         ((member "-outline-DejaVu Sans Mono monospacified -normal-normal-normal-mono-*-*-*-*-c-*-iso8859-1"
      ;;                  (x-list-fonts "*" nil (selected-frame)))
      ;;          '(:name "-outline-DejaVu Sans Mono monospacified -normal-normal-normal-mono-*-*-*-*-c-*-iso8859-1"))
      ;;         ((member "-outline-Unifont-normal-normal-normal-*-*-*-*-*-p-*-iso8859-1"
      ;;                  (x-list-fonts "*" nil (selected-frame)))
      ;;          '(:name "-outline-Unifont-normal-normal-normal-*-*-*-*-*-p-*-iso8859-1")))))
      ;;   (if (null font-spec-args)
      ;;       (message "Monospace utf-8 font not found.")
      ;;     (dolist (range '((#x2100 . #x230F)
      ;;                        (#x2380 . #x23F3)
      ;;                        (#x2420 . #x2424)
      ;;                        (#x25A0 . #x25FF)
      ;;                        (#x2610 . #x2613)
      ;;                        (#x2692 . #x26A0)
      ;;                        (#x26D2 . #x26D4)
      ;;                        (#x2709 . #x270C)))
      ;;         (set-fontset-font "fontset-default" range
      ;;                           (apply 'font-spec font-spec-args)))
      ;;     (message "Monospace utf-8 font: %s" (or (plist-get font-spec-args :family)
      ;;                                             (plist-get font-spec-args :name)))))
      ;; ]
      )))
#+end_src

* TODO Delme after finish this org file

#+begin_src elisp
(eval-and-compile
  (let ((default-directory (expand-file-name
                            "el" user-emacs-directory)))
    (normal-top-level-add-subdirs-to-load-path)))
#+end_src

* Typing

#+begin_src elisp
(unless (display-graphic-p)
  (xterm-mouse-mode 1)
  (xclip-mode 1))
;; [ don't work properly and cpu expensive
;; (setq blink-cursor-blinks 0)
;; (eval-and-when-daemon frame
;;   (blink-cursor-mode t))
;; <xor>
(eval-and-when-daemon frame
  (blink-cursor-mode -1))
;; ]

(set-face-attribute 'line-number-current-line nil
                    :weight 'bold
                    :foreground "#fe3")

(setq-default
 ;; t -   long lines go away from window width, ei, continuation lines
 ;; nil - soft wrap lines
 truncate-lines nil ;; so-long-variable-overrides doc
 ;; ignore case searching
 case-fold-search t)
;; [ Demasiado agresivo, mejor con ido
;; Cambia todas las preguntas yes-or-no-p por y-or-n-p
;; (fset 'yes-or-no-p 'y-or-n-p)
;; ]
;; Option 2
;; (defun yes-or-no-p (prompt)
;;   (interactive)
;;   (pcase (downcase (read-string (concat prompt "(yes, no) ")))
;;     ("y" t)
;;     ("ye" t)
;;     ("yes" t)
;;     (_ nil)))
(defun yes-or-no-p (prompt)
  (interactive)
  (string-equal
   "yes"
   (completing-read prompt '("yes" "no") nil t nil nil "no")))

(defun insert-utf8 (&optional name)
  (interactive)
  (let ((utf8-hash-table (ucs-names)))
    (insert (gethash (completing-read
                      "Unicode character name: "
                      (hash-table-keys utf8-hash-table)
                      nil t)
                     utf8-hash-table))))

(setq echo-keystrokes 0.5
      jit-lock-defer-time 0.05
      ;; when idle fontifies portions not yet displayed
      jit-lock-stealth-time 1
      ;; jit-lock-stealth-nice 0.5
      ;; jit-lock-stealth-load 50
      ;; jit-lock-chunk-size 100
      ;; fontification of non modified but context lines
      ;; jit-lock-context-time 0.5
      column-number-mode t
      max-mini-window-height 0.55
      ;; kill-ring
      kill-do-not-save-duplicates t
      ;; mark-ring
      set-mark-command-repeat-pop t
      mark-ring-max 32
      global-mark-ring-max 128
      ;; isearch
      isearch-lazy-count t
      isearch-allow-scroll 'unlimited
      isearch-allow-motion t
      ;; Deshabilita insertar una nueva linea al final de los ficheros
      ;; para que las plantillas de 'yasnippet' no añadan nueva liena
      mode-require-final-newline nil)
;; (push 'substring completion-styles)

;;;;;;;;;;;;;;;;;;;
;; Coding system ;;
;;;;;;;;;;;;;;;;;;;
;; [ utf8 default in last versions
;; (set-default-coding-systems 'utf-8)
;; (set-clipboard-coding-system 'utf-8)

;; (prefer-coding-system 'utf-8)
;; (setq locale-coding-system 'utf-8
;;       unibyte-display-via-language-environment t
;;       default-process-coding-system '(utf-8-unix . utf-8-unix)
;;       file-name-coding-system 'utf-8)
;; (set-terminal-coding-system 'utf-8-unix)

;; (eval-and-when-daemon frame
;;   (with-selected-frame frame
;;     (unless window-system
;;       (set-keyboard-coding-system 'utf-8))))

;; (set-selection-coding-system 'utf-8)
;; (set-next-selection-coding-system 'utf-8)
;; (set-buffer-file-coding-system 'utf-8-unix)
;; (set-language-environment 'UTF-8)
;; (require 'iso-transl)
;; ]
;;(set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix) ; error: No process
;;(add-to-list 'auto-coding-regexp-alist '("^\xEF\xBB\xBF" . utf-8) t)
;;(add-to-list 'auto-coding-regexp-alist '("\\`\240..." . latin-1))
;;(add-to-list 'process-coding-system-alist '("gud" . utf-8))

;; Toggle coding systems
(defun toggle-buffer-coding-system ()
  (interactive)
  (if (or (equal buffer-file-coding-system 'utf-8-unix)
          (equal buffer-file-coding-system 'utf-8))
      (let ((process (get-buffer-process (current-buffer))))
        (set-buffer-file-coding-system 'iso-8859-1-unix)
        (set-keyboard-coding-system 'iso-8859-1-unix)
        (when process
          (set-process-coding-system process 'iso-8859-1-unix 'iso-8859-1-unix)))
    (let ((process (get-buffer-process (current-buffer))))
      (set-buffer-file-coding-system 'utf-8-unix)
      (set-keyboard-coding-system 'utf-8)
      (when process
        (set-process-coding-system process 'utf-8-unix 'utf-8-unix)))))

;; Busca caracteres no representables
(defun find-next-unsafe-char (&optional coding-system)
  "Find the next character in the buffer that cannot be encoded by
coding-system. If coding-system is unspecified, default to the coding
system that would be used to save this buffer. With prefix argument,
prompt the user for a coding system."
  (interactive "Zcoding-system: ")
  (if (stringp coding-system) (setq coding-system (intern coding-system)))
  (if coding-system nil
    (setq coding-system
          (or save-buffer-coding-system buffer-file-coding-system)))
  (let ((found nil) (char nil) (csets nil) (safe nil))
    (setq safe (coding-system-get coding-system 'safe-chars))
    ;; some systems merely specify the charsets as ones they can encode:
    (setq csets (coding-system-get coding-system 'safe-charsets))
    (save-excursion
      ;;(message "zoom to <")
      (let ((end  (point-max))
            (here (point    ))
            (char  nil))
        (while (and (< here end) (not found))
          (setq char (char-after here))
          (if (or (eq safe t)
                  (< char ?\177)
                  (and safe  (aref safe char))
                  (and csets (memq (char-charset char) csets)))
              nil ;; safe char, noop
            (setq found (cons here char)))
          (setq here (1+ here))) ))
    (and found (goto-char (1+ (car found))))
    found))

;; from ascii to utf8
(defun ascii-to-utf8-forward (beg end)
  (interactive (list (point) (point-max)))
  (save-excursion
    (let ((case-fold-search nil))
      (dolist (map '(("\\\240" . "á")
                     ("\\\202" . "é")
                     ("\\\241" . "í")
                     ("\\\242" . "ó")
                     ("\\\243" . "ú")
                     ("\\\244" . "ñ")
                     ("\\\245" . "Ñ")
                     ("\\\265" . "Á")
                     ("\\\220" . "É")
                     ("\\\326" . "Í")
                     ("\\\340" . "Ó")
                     ("\\\351" . "Ú")
                     ("\\\204" . "ä")
                     ("\\\211" . "ë")
                     ("\\\213" . "ï")
                     ("\\\224" . "ö")
                     ("\\\201" . "ü")
                     ("\\\216" . "Ä")
                     ("\\\323" . "Ë")
                     ("\\\330" . "Ï")
                     ("\\\231" . "Ö")
                     ("\\\232" . "Ü")))
        (goto-char beg)
        (while (search-forward (car map) end t 1)
          (replace-match (cdr map) t t))))))

(defun utf8-fix-wrong-ascii (beg end)
  (interactive (list (point) (point-max)))
  (save-excursion
    (save-restriction
      (narrow-to-region beg end)
      (let ((case-fold-search nil))
        (dolist (map '(("›" . "â\x0080º") ;; \200
                       ("🐜" . "ð\x009f\x0090\x009c"))) ;; \237\220\234
          (goto-char (point-min))
          (while (search-forward (cdr map) nil t 1)
            (replace-match (car map) t t)))))))

(defun utf8-fix-wrong-latin (beg end)
  (interactive (list (point) (point-max)))
  (save-excursion
    (save-restriction
      (narrow-to-region beg end)
      (let ((case-fold-search nil))
        (dolist (map '(("À" . "Ã€")
                       ("Â" . "Ã‚")
                       ("Ã" . "Ãƒ")
                       ("Ä" . "Ã„")
                       ("Å" . "Ã…")
                       ("Æ" . "Ã†")
                       ("Ç" . "Ã‡")
                       ("È" . "Ãˆ")
                       ("É" . "Ã‰")
                       ("Ê" . "ÃŠ")
                       ("Ë" . "Ã‹")
                       ("Ì" . "ÃŒ")
                       ("Î" . "ÃŽ")
                       ("Ñ" . "Ã‘")
                       ("Ò" . "Ã’")
                       ("Ó" . "Ã“")
                       ("Ô" . "Ã”")
                       ("Õ" . "Ã•")
                       ("Ö" . "Ã–")
                       ("×" . "Ã—")
                       ("Ø" . "Ã˜")
                       ("Ù" . "Ã™")
                       ("Ú" . "Ãš")
                       ("Û" . "Ã›")
                       ("Ü" . "Ãœ")
                       ("Þ" . "Ãž")
                       ("ß" . "ÃŸ")
                       ("á" . "Ã¡")
                       ("â" . "Ã¢")
                       ("ã" . "Ã£")
                       ("ä" . "Ã¤")
                       ("å" . "Ã¥")
                       ("æ" . "Ã¦")
                       ("ç" . "Ã§")
                       ("è" . "Ã¨")
                       ("é" . "Ã©")
                       ("ê" . "Ãª")
                       ("ë" . "Ã«")
                       ("ì" . "Ã¬")
                       ("í" . "Ã­")
                       ("î" . "Ã®")
                       ("ï" . "Ã¯")
                       ("ð" . "Ã°")
                       ("ñ" . "Ã±")
                       ("ò" . "Ã²")
                       ("ó" . "Ã³")
                       ("ô" . "Ã´")
                       ("õ" . "Ãµ")
                       ("ö" . "Ã¶")
                       ("÷" . "Ã·")
                       ("ø" . "Ã¸")
                       ("ù" . "Ã¹")
                       ("ú" . "Ãº")
                       ("û" . "Ã»")
                       ("ü" . "Ã¼")
                       ("ý" . "Ã½")
                       ("þ" . "Ã¾")
                       ("ÿ" . "Ã¿")
                       ("Á" . "Ã")))
          (goto-char (point-min))
          (while (search-forward (cdr map) nil t 1)
            (replace-match (car map) t t)))))))

(defun insert-fixing-utf8 (&rest args)
  (let ((beg (point)))
    (apply 'insert args)
    (save-restriction
      (narrow-to-region beg (point))
      (utf8-fix-wrong-ascii (point-min) (point-max))
      (utf8-fix-wrong-latin (point-min) (point-max)))))

;; remove latin1 characters
(defun remove-tildes (string)
  (let ((case-fold-search t))
    (dolist (map '(("á" . "a")
                   ("é" . "e")
                   ("í" . "i")
                   ("ó" . "o")
                   ("ú" . "u")
                   ("ñ" . "n")
                   ("ä" . "a")
                   ("ë" . "e")
                   ("ï" . "i")
                   ("ö" . "o")
                   ("ü" . "u")) string)
      (set 'string (replace-regexp-in-string (car map) (cdr map) string nil t)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Keyboard translations ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;
(when (executable-find "setxkbmap")
  (defun xkb-swap-ctrl-caps (&optional arg)
    (interactive "P")
    (if arg
        (start-process " *setxkbmap" nil
                       "setxkbmap" "-option")
      (start-process " *setxkbmap" nil
                     "setxkbmap" "-option" "ctrl:swapcaps")))
  (defun xkb-swap-ctrl-win (&optional arg)
    (interactive "P")
    (if arg
        (start-process " *setxkbmap" nil
                       "setxkbmap" "-option")
      (start-process " *setxkbmap" nil
                     "setxkbmap" "-option" "ctrl:swap_lwin_lctl"))))

(when (executable-find "xkbcomp")
  (defun xkb-swap-ralt-ctrl (&optional arg)
    (interactive "P")
    (let ((xkb-path (expand-file-name "cache/xkb" user-emacs-directory)))
      (if arg
          (start-process " *xkbcomp" nil
                         "xkbcomp" (concat "-I" xkb-path)
                         (concat xkb-path "/keymap/kbd")
                         (getenv "DISPLAY"))
        (start-process " *xkbcomp" nil
                       "xkbcomp" (concat "-I" xkb-path)
                       (concat xkb-path "/keymap/kbd_swap_ralt_ctrl")
                       (getenv "DISPLAY"))))))

(defun swap-for-programming-keys (&optional arg)
  (interactive "P")
  (if arg
      (setq keyboard-translate-table nil)
    (setq keyboard-translate-table
          (make-char-table 'keyboard-translate-table))
    ;; Swap º and \
    (aset keyboard-translate-table ?º ?\\)
    (aset keyboard-translate-table ?\\ ?º)))

(defun apple-keyboard-toggle-fn-key (&optional arg)
  ;; * permanent change
  ;; 1. edit or create: /etc/modprobe.d/hid_apple.conf
  ;; 2. append line:    options hid_apple fnmode=2
  ;; 3. shell command:  sudo update-initramfs -u -k all
  ;; 4. reboot.
  (interactive "P")
  (if (eq last-command 'apple-keyboard-toggle-fn-key)
      (user-error "Ignoring repeated call")
    (setq arg  (number-to-string
                (if (numberp arg)
                    (if (and (<= arg 2)
                             (>= arg 0))
                        arg
                      (user-error "Invalid number %i" arg))
                  (cl-case (string-to-number
                            (shell-command-to-string
                             "cat /sys/module/hid_apple/parameters/fnmode"))
                    (0 2)
                    (1 2)
                    (2 0)
                    (otherwise 2)))))
    (unwind-protect
        (with-temp-buffer
          (cd "/sudo::/")
          (shell-command
           (concat "echo " arg " | tee /sys/module/hid_apple/parameters/fnmode")))
      (discard-input)
      (setq unread-command-events nil))))
(global-set-key (kbd "<M-XF86MonBrightnessDown>") 'apple-keyboard-toggle-fn-key)
(global-set-key (kbd "<M-f1>") 'apple-keyboard-toggle-fn-key)

;;;;;;;;;;;;;;;;;
;; Indentation ;;
;;;;;;;;;;;;;;;;;
;; Only spaces without tabs
(setq-default indent-tabs-mode nil
              tab-width 4
              sh-indent-for-case-label 0
              sh-indent-for-case-alt '+)
(setq tab-always-indent 'complete
      ;; styles
      c-default-style "linux"
      tab-width 4
      indent-tabs-mode nil
      c-basic-offset 4
      python-indent-offset 4
      js-indent-level 2)

(c-set-offset 'innamespace '0)
(c-set-offset 'inextern-lang '0)
(c-set-offset 'inline-open '0)
(c-set-offset 'label '*)
(c-set-offset 'case-label '0)
(c-set-offset 'access-label '/)

(define-key indent-rigidly-map (kbd "M-f") #'indent-rigidly-right-to-tab-stop)
(define-key indent-rigidly-map (kbd "M-b") #'indent-rigidly-left-to-tab-stop)
(define-key indent-rigidly-map (kbd "C-f") #'indent-rigidly-right)
(define-key indent-rigidly-map (kbd "C-b") #'indent-rigidly-left)

(defmacro save-line (&rest body)
  `(let* ((origin (point))
          (line (count-lines 1 origin)))
     ,@body
     (unless (= line (count-lines 1 (point)))
       (goto-char origin))))

;; unescape line
(defun join-lines-unescaping-new-lines ()
  (interactive)
  (save-excursion
    (end-of-line)
    (while (char-equal (char-before) ?\\)
      (left-char)
      (delete-char 2)
      (when (char-equal (char-after) ? )
        (fixup-whitespace))
      (end-of-line))))

(defun break-line-escaping-new-lines ()
  (interactive)
  (save-excursion
    (while (= (1+ whitespace-line-column)
              (move-to-column (1+ whitespace-line-column)))
      (left-char)
      (save-line
       (backward-word))
      (let ((column (current-column)))
        (when (or (< column (/ whitespace-line-column 2))
                  (> column (- whitespace-line-column 2)))
          (move-to-column (- whitespace-line-column 2))))
      (insert "\\")
      (call-interactively #'newline))))

;; Mostrar parentesis (ya lo hace show-smartparents-mode)
(show-paren-mode 1)
;; (electric-pair-mode 1)
(electric-indent-mode -1)
;; Narrow enabled
(put 'narrow-to-region 'disabled nil)

;; No lo activamos por ser muy engorroso
;;(put 'scroll-left 'disabled nil)

;;;;;;;;;;;;;;;;;
;; Copy things ;;
;;;;;;;;;;;;;;;;;
(setq yank-excluded-properties t
      yank-from-kill-ring-rotate t)

(defun duplicate-region (arg beg end &optional orig)
  "Duplicates ARG times region from BEG to END."
  (let ((origin (or orig end))
        (neg (> 0 arg))
        (argument (abs arg))
        (region (buffer-substring-no-properties beg end)))
    (if neg
        (dotimes (i argument)
          (goto-char end)
          (newline)
          (insert region)
          (setq end (point)))
      (dotimes (i argument)
        (goto-char end)
        (insert region)
        (setq end (point)))
      (set 'origin (- origin argument)))
    (goto-char (+ origin (* (length region) argument) argument))))

(defun duplicate-rectangle-region (arg beg end)
  (let ((region (sort (list beg end) '<)))
    (let ((rectangle (extract-rectangle (cl-first region)
                                        (cl-second region)))
          (bounds (extract-rectangle-bounds (cl-first region)
                                            (cl-second region))))
      (cond
       ((or (= end (cdr (car bounds)))
            (= end (cdr (car (last bounds)))))
        (dotimes (i arg)
          (goto-char (car region))
          (insert-rectangle rectangle)))
       ((= end (car (car bounds)))
        (let ((column (current-column))
              (lines (length bounds))
              backward-lines)
          (setq backward-lines (- 1 (* 2 lines))
                lines (- 1 lines))
          (forward-line lines)
          (dotimes (i arg)
            (unless (= 0 (forward-line backward-lines))
              (error "Not enough lines above"))
            (move-to-column column)
            (insert-rectangle rectangle))
          (forward-line lines)
          (move-to-column column)))
       ((= end (car (car (last bounds))))
        (let ((column (current-column)))
          (dotimes (i arg)
            (let ((line (line-number-at-pos)))
              (forward-line)
              (if (= line (line-number-at-pos))
                  (insert "\n")))
            (move-to-column column)
            (insert-rectangle rectangle))
          (move-to-column column)))))))

(defun duplicate-current-line-or-region (arg)
  "Duplicates the current line or region ARG times.
If there's no region, the current line will be duplicated. However, if
there's a region, all lines that region covers will be duplicated."
  (interactive "p")
  (if (use-region-p)
      (if rectangle-mark-mode
          (duplicate-rectangle-region arg (mark) (point))
        (let ((region (sort (list (mark) (point)) '<)))
          (duplicate-region arg
                            (cl-first region)
                            (cl-second region)
                            (point))))
    (duplicate-region (- arg)
                      (line-beginning-position)
                      (line-end-position)
                      (point))))
;;;;;;;;;;;
;; Mouse ;;
;;;;;;;;;;;

;; (require 'ffap) autoloaded functions
(global-set-key [S-mouse-3] 'ffap-at-mouse)
(global-set-key [C-S-mouse-3] 'ffap-menu)
(global-set-key "\C-xf" 'find-file-at-point)

;; (global-set-key "\C-x\C-f" 'find-file-at-point)
;; (global-set-key "\C-x\C-r" 'ffap-read-only)
;; (global-set-key "\C-x\C-v" 'ffap-alternate-file)

;; (global-set-key "\C-x4f"   'ffap-other-window)
;; (global-set-key "\C-x5f"   'ffap-other-frame)
;; (global-set-key "\C-x4r"   'ffap-read-only-other-window)
;; (global-set-key "\C-x5r"   'ffap-read-only-other-frame)

;; (global-set-key "\C-xd"    'dired-at-point)
;; (global-set-key "\C-x4d"   'ffap-dired-other-window)
;; (global-set-key "\C-x5d"   'ffap-dired-other-frame)
;; (global-set-key "\C-x\C-d" 'ffap-list-directory)

;; (add-hook 'gnus-summary-mode-hook 'ffap-gnus-hook)
;; (add-hook 'gnus-article-mode-hook 'ffap-gnus-hook)
;; (add-hook 'vm-mode-hook 'ffap-ro-mode-hook)
;; (add-hook 'rmail-mode-hook 'ffap-ro-mode-hook))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                        ;;
;;     Nuevas teclas      ;;
;;                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;
;; Idiomas español e inglés

;; [ Liberamos la combinación de teclas M-f
;; (global-unset-key (kbd "M-f"))
;; copiado y pegado
;; (global-unset-key (kbd "M-w"))
;; (global-unset-key (kbd "C-w"))
;; (global-unset-key (kbd "C-y"))
;; (global-unset-key (kbd "C-c"))
;; (global-unset-key (kbd "C-x"))
;; (global-unset-key (kbd "C-v"))
;; ;; ]
;; ;; [ Teclas de copiado y pegado universales
;; (global-set-key (kbd "C-c") 'kill-ring-save)
;; (global-set-key (kbd "C-x") 'kill)
;; (global-set-key (kbd "C-c") 'yank)
;; ]
;;;;;;;


;; Activa imath-mode
                                        ;(global-set-key (kbd "M-n M-m") 'imath-mode)

;; Bookmark handling
;;
;; (global-set-key (kbd "<C-f5>") '(lambda () (interactive) (progn (message "Bookmark f5 added") (bookmark-set "BookMark_f5"))))
;; (global-set-key (kbd "<f5>") '(lambda () (interactive) (bookmark-jump "BookMark_f5")))
;; (global-set-key (kbd "<C-f6>") '(lambda () (interactive) (progn (message "Bookmark f6 added") (bookmark-set "BookMark_f6"))))
;; (global-set-key (kbd "<f6>") '(lambda () (interactive) (bookmark-jump "BookMark_f6")))
;; (global-set-key (kbd "<C-f7>") '(lambda () (interactive) (progn (message "Bookmark f7 added") (bookmark-set "BookMark_f7"))))
;; (global-set-key (kbd "<f7>") '(lambda () (interactive) (bookmark-jump "BookMark_f7")))
;; (global-set-key (kbd "<C-f8>") '(lambda () (interactive) (progn (message "Bookmark f8 added") (bookmark-set "BookMark_f8"))))
;; (global-set-key (kbd "<f8>") '(lambda () (interactive) (bookmark-jump "BookMark_f8")))

(define-key key-translation-map (kbd "M-s M-u <down>") (kbd "↓"))
(define-key key-translation-map (kbd "M-s M-u <left>") (kbd "←"))
(define-key key-translation-map (kbd "M-s M-u <right>") (kbd "→"))
(define-key key-translation-map (kbd "M-s M-u <up>") (kbd "↑"))
(define-key key-translation-map (kbd "M-s M-u TAB") (kbd "↹"))
(define-key key-translation-map (kbd "M-s M-u RET") (kbd "↵"))
(define-key key-translation-map (kbd "M-s M-u a") (kbd "α"))
(define-key key-translation-map (kbd "M-s M-u A") (kbd "Α"))
(define-key key-translation-map (kbd "M-s M-u b") (kbd "β"))
(define-key key-translation-map (kbd "M-s M-u B") (kbd "Β"))
(define-key key-translation-map (kbd "M-s M-u g") (kbd "γ"))
(define-key key-translation-map (kbd "M-s M-u G") (kbd "Γ"))
(define-key key-translation-map (kbd "M-s M-u d") (kbd "δ"))
(define-key key-translation-map (kbd "M-s M-u D") (kbd "Δ"))
(define-key key-translation-map (kbd "M-s M-u e") (kbd "ε"))
(define-key key-translation-map (kbd "M-s M-u E") (kbd "Ε"))
(define-key key-translation-map (kbd "M-s M-u z") (kbd "ζ"))
(define-key key-translation-map (kbd "M-s M-u Z") (kbd "Ζ"))
(define-key key-translation-map (kbd "M-s M-u h") (kbd "η"))
(define-key key-translation-map (kbd "M-s M-u H") (kbd "Η"))
(define-key key-translation-map (kbd "M-s M-u q") (kbd "θ"))
(define-key key-translation-map (kbd "M-s M-u Q") (kbd "Θ"))
(define-key key-translation-map (kbd "M-s M-u i") (kbd "ι"))
(define-key key-translation-map (kbd "M-s M-u I") (kbd "Ι"))
(define-key key-translation-map (kbd "M-s M-u k") (kbd "κ"))
(define-key key-translation-map (kbd "M-s M-u K") (kbd "Κ"))
(define-key key-translation-map (kbd "M-s M-u l") (kbd "λ"))
(define-key key-translation-map (kbd "M-s M-u L") (kbd "Λ"))
(define-key key-translation-map (kbd "M-s M-u m") (kbd "μ"))
(define-key key-translation-map (kbd "M-s M-u M") (kbd "Μ"))
(define-key key-translation-map (kbd "M-s M-u n") (kbd "ν"))
(define-key key-translation-map (kbd "M-s M-u N") (kbd "Ν"))
(define-key key-translation-map (kbd "M-s M-u p") (kbd "π"))
(define-key key-translation-map (kbd "M-s M-u P") (kbd "Π"))
(define-key key-translation-map (kbd "M-s M-u r") (kbd "ρ"))
(define-key key-translation-map (kbd "M-s M-u R") (kbd "Ρ"))
(define-key key-translation-map (kbd "M-s M-u s") (kbd "σ"))
(define-key key-translation-map (kbd "M-s M-u S") (kbd "Σ"))
(define-key key-translation-map (kbd "M-s M-u t") (kbd "τ"))
(define-key key-translation-map (kbd "M-s M-u T") (kbd "Τ"))
(define-key key-translation-map (kbd "M-s M-u y") (kbd "υ"))
(define-key key-translation-map (kbd "M-s M-u Y") (kbd "Υ"))
(define-key key-translation-map (kbd "M-s M-u f") (kbd "φ"))
(define-key key-translation-map (kbd "M-s M-u F") (kbd "Φ"))
(define-key key-translation-map (kbd "M-s M-u x") (kbd "χ"))
(define-key key-translation-map (kbd "M-s M-u X") (kbd "Χ"))
(define-key key-translation-map (kbd "M-s M-u v") (kbd "Ψ"))
(define-key key-translation-map (kbd "M-s M-u V") (kbd "ψ"))
(define-key key-translation-map (kbd "M-s M-u w") (kbd "ω"))
(define-key key-translation-map (kbd "M-s M-u W") (kbd "Ω"))
(define-key key-translation-map (kbd "M-s M-u *") (kbd "×"))
(define-key key-translation-map (kbd "M-s M-u /") (kbd "÷"))
(define-key key-translation-map (kbd "M-s M-u .") (kbd "…"))
(define-key key-translation-map (kbd "M-s M-u +") (kbd "∞"))
(define-key key-translation-map (kbd "M-s M-u =") (kbd "≠"))
(define-key key-translation-map (kbd "M-s M-u -") (kbd "±"))
(define-key key-translation-map (kbd "M-s M-u 0") (kbd "ℵ"))
(define-key key-translation-map (kbd "M-s M-u \\") (kbd "∀"))
(define-key key-translation-map (kbd "M-s M-u !") (kbd "∃"))
(define-key key-translation-map (kbd "M-s M-u |") (kbd "∄"))
(define-key key-translation-map (kbd "M-s M-u º") (kbd "∅"))
(define-key key-translation-map (kbd "M-s M-u /") (kbd "∈"))
(define-key key-translation-map (kbd "M-s M-u %") (kbd "∝"))
(define-key key-translation-map (kbd "M-s M-u ç") (kbd "⊆"))
(define-key key-translation-map (kbd "M-s M-u Ç") (kbd "⊂"))
(define-key key-translation-map (kbd "M-s M-u ñ") (kbd "⊇"))
(define-key key-translation-map (kbd "M-s M-u Ñ") (kbd "⊃"))

;;;;;;;;;;;;;;;;;;;;
;; Big movements  ;;
;;;;;;;;;;;;;;;;;;;;
(defun window-width-without-margin (&optional window pixelwise)
  (- (window-width window pixelwise)
     hscroll-margin
     (if display-line-numbers
         (if (numberp display-line-numbers-width)
             display-line-numbers-width
           3)
       0)))

(defvar recenter-horizontal-last-op nil)
(defvar recenter-horizontal-positions '(middle left right))

(defun recenter-horizontal (&optional arg)
  "Make the ARG or point horizontally centered in the window."
  (interactive "P")
  (setq arg (or arg (current-column))
        recenter-horizontal-last-op (if (eq this-command last-command)
                                        (car (or (cdr (member
                                                       recenter-horizontal-last-op
                                                       recenter-horizontal-positions))
                                                 recenter-horizontal-positions))
                                      (car recenter-horizontal-positions)))
  (pcase recenter-horizontal-last-op
    ('middle
     (let ((mid (/ (window-width-without-margin) 2)))
       (if (< mid arg)
           (set-window-hscroll (selected-window)
                               (- arg mid)))))
    ('left
     (set-window-hscroll (selected-window) arg))
    ('right
     (let ((width (window-width-without-margin)))
       (if (< width arg)
           (set-window-hscroll (selected-window)
                               (- arg width)))))))

(defvar horizontal-alt 15)

(defun forward-alt ()
  (interactive)
  (forward-char horizontal-alt))

(defun backward-alt ()
  (interactive)
  (backward-char horizontal-alt))

(defun hscroll-right (arg)
  (interactive "p")
  (let ((width (window-width-without-margin))
        (col (current-column)))
    (let ((pos (max 0 (* (+ (/ col width) arg) width))))
      (move-to-column (+ pos hscroll-margin 1))
      (set-window-hscroll (selected-window) pos))))

(defun hscroll-left (arg)
  (interactive "p")
  (hscroll-right (- arg)))

;;;;;;;;;;;;
;; Prompt ;;
;;;;;;;;;;;;
                                        ;(advice-add 'read-from-minibuffer :around #'message-inhibit-advice)

;; [ Allow typing out of input area
;; (defun minibuffer-try-pre ()
;;   "By default typing out of input area raise an error.
;; This function avoid error and insert character at the end."
;;   (when (memq this-command '(self-insert-command
;;                              y-or-n-p-insert-y
;;                              y-or-n-p-insert-n))
;;     (setq this-command
;;           `(lambda () (interactive)
;;              (setq this-command (quote ,this-command))
;;              (condition-case-unless-debug _
;;                  (call-interactively (quote ,this-command))
;;                (text-read-only (goto-char (point-max))
;;                                ,(cl-case this-command
;;                                   (self-insert-command
;;                                    '(self-insert-command
;;                                      (prefix-numeric-value current-prefix-arg)
;;                                      last-command-event))
;;                                   (otherwise
;;                                    (list this-command))))
;;                ((beginning-of-buffer
;;                  end-of-buffer)
;;                 (goto-char (point-max)))
;;                (end-of-buffer (goto-char (point-max))))))))

;; (defun minibuffer-try-add-hooks ()
;;   (add-hook 'pre-command-hook 'minibuffer-try-pre))
;; (defun minibuffer-try-remove-hooks ()
;;   (remove-hook 'pre-command-hook 'minibuffer-try-pre))

;; (add-hook 'minibuffer-setup-hook 'minibuffer-try-add-hooks)
;; (add-hook 'minibuffer-exit-hook 'minibuffer-try-remove-hooks)
;; ]
;;;;;;;;;;;;;;;
;; Kill ring ;;
;;;;;;;;;;;;;;;
;; (defun kill-ring-insert ()
;;   (interactive)
;;   (let ((to_insert (completing-read "Yank: "
;;                                     (cl-delete-duplicates kill-ring :test #'equal)
;;                                     nil t)))
;;     (when (and to_insert (region-active-p))
;;       ;; the currently highlighted section is to be replaced by the yank
;;       (delete-region (region-beginning) (region-end)))
;;     (insert to_insert)))

;;;;;;;;;;;;
;; Cycles ;;
;;;;;;;;;;;;
;; (defun rotate-or-inflection (arg)
;;   (interactive (list (if (consp current-prefix-arg)
;;                          -1
;;                        (prefix-numeric-value current-prefix-arg))))
;;   (condition-case nil
;;       (rotate-text arg)
;;     (error (string-inflection-all-cycle))))

(defun scroll-down-or-completions (&optional arg)
  (interactive "^P")
  (if (get-buffer-window "*Completions*")
      (switch-to-completions)
    (scroll-down-command arg)))
;;;;;;;;;;
;; Sexp ;;
;;;;;;;;;;
(defun sp-or-forward-sexp (&optional arg)
  (interactive "^p")
  (if (fboundp 'sp-forward-sexp)
      (sp-forward-sexp arg)
    (forward-sexp arg)))

(defun sp-or-backward-sexp (&optional arg)
  (interactive "^p")
  (if (fboundp 'sp-backward-sexp)
      (sp-backward-sexp arg)
    (backward-sexp arg)))

(defun sp-or-backward-kill-sexp (&optional arg)
  (interactive "^p")
  (if (fboundp 'sp-backward-sexp)
      (let ((opoint (point)))
        (sp-backward-sexp arg)
        (kill-region opoint (point)))
    (backward-kill-sexp arg)))

;;;;;;;;;;;
;; Pairs ;;
;;;;;;;;;;;
(setq parens-require-spaces nil
      insert-pair-alist
      (nconc insert-pair-alist '((?¡ ?!)
                                 (?¿ ??)
                                 (?« ?»)
                                 (?“ ?”))))

(defun surround-delete-pair (&optional arg escape-strings no-syntax-crossing)
  (interactive "^p\nd\nd")
  (save-excursion
    (backward-up-list arg escape-strings no-syntax-crossing)
    (let ((delete-pair-blink-delay nil))
      (delete-pair 1))))

(defun surround-change-pair (&optional arg escape-strings no-syntax-crossing)
  (interactive "^p\nd\nd")
  (let ((alist insert-pair-alist)
        (char (read-char "Left delimiter: ")))
    (let ((pair (or (assoc char alist 'char-equal)
                    (rassoc char alist)
                    (list char char))))
      (save-excursion
        (backward-up-list arg escape-strings no-syntax-crossing)
        (save-excursion
          (forward-sexp 1)
          (delete-char -1)
          (insert (car (cdr pair))))
        (delete-char 1)
        (insert (car pair))))))

(global-set-key "¡" #'insert-pair)
(global-set-key "¿" #'insert-pair)
;;;;;;;;;;;;;;;;;;;;
;; Indent newline ;;
;;;;;;;;;;;;;;;;;;;;
(defun newline-indent (arg interactive)
  (interactive "*P\np")
  (ignore-error 'beginning-of-buffer
    (fixup-whitespace))
  (newline arg interactive)
  (indent-according-to-mode))

(defun newline-blankline-indent (arg interactive)
  (interactive "*p\np")
  (ignore-error 'beginning-of-buffer
    (fixup-whitespace))
  (when (save-excursion
          (beginning-of-line)
          (looking-at "^[[:space:]]*{}"))
    (indent-according-to-mode))
  (newline (1+ arg) interactive)
  (indent-according-to-mode)
  (forward-line -1)
  (indent-according-to-mode))

;;;;;;;;;;;;;;;;;;;;;
;; Keyboard macros ;;
;;;;;;;;;;;;;;;;;;;;;
(defun select-kbd-macro ()
  (interactive)
  (unless (kmacro-ring-empty-p)
    (let* ((ring-alist (mapcar (lambda (ring-item)
                                 (cons (format-kbd-macro (car ring-item))
                                       (car ring-item)))
                               kmacro-ring))
           (kbd-macro (cdr (assoc (completing-read
                                   "Select kbd macro: "
                                   ring-alist nil t nil nil
                                   (format-kbd-macro last-kbd-macro)) ring-alist))))
      (when kbd-macro
        (cl-delete-if (lambda (ring-item) (equal kbd-macro (car ring-item))) kmacro-ring)
        (kmacro-push-ring)
        (setq last-kbd-macro kbd-macro)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Next-Previous thing like this ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; (require 'thing-cmds)
;; (defvar thgcmd--last-like-this nil)

(defun buffer-substring-no-properties-thing (thing)
  (let* ((use-near-p  (and (boundp 'thgcmd-use-nearest-thing-flag)
                           thgcmd-use-nearest-thing-flag))
         (bds         (if use-near-p
                          (tap-bounds-of-thing-nearest-point
                           (intern thing))
                        (thgcmd-bounds-of-thing-at-point
                         (intern thing))))
         (start       (car bds))
         (end         (cdr bds)))
    (cond ((and start  end)
           (buffer-substring-no-properties start end))
          (t
           (message "No `%s' %s point"
                    thing (if use-near-p 'near 'at))
           (setq deactivate-mark  nil)
           nil))))
(autoload 'thgcmd-bounds-of-thing-at-point "thing-cmds" nil t)

;; (defun next-thing-like-this (this)
;;   (interactive (list
;;                 (cond
;;                  ((and current-prefix-arg
;;                        thgcmd--last-like-this)
;;                   thgcmd--last-like-this)
;;                  ((memq last-command '(next-thing-like-this
;;                                        previous-thing-like-this))
;;                   (buffer-substring-no-properties-thing
;;                    (symbol-name thgcmd-last-thing-type)))
;;                  (t
;;                   (buffer-substring-no-properties-thing
;;                    (let* ((icicle-sort-function  nil)
;;                           (def (symbol-name thgcmd-last-thing-type))
;;                           (thing
;;                            (completing-read
;;                             (concat "Thing (" def "): ")
;;                             (thgcmd-things-alist) nil t nil nil
;;                             def)))
;;                      (setq thgcmd-last-thing-type  (intern thing))
;;                      thing))))))
;;   (when this
;;     (setq thgcmd--last-like-this this)
;;     (if (re-search-forward "\\_>" nil t)
;;         (goto-char (1- (match-end 0))))
;;     (if (null (re-search-forward (format "\\_<%s\\_>"
;;                                          (regexp-quote this)) nil t))
;;         (message "No next match of `%s'" this)
;;       (goto-char (match-beginning 0))
;;       (mapc (lambda (ov)
;;               (overlay-put ov 'invisible nil))
;;             (overlays-at (point)))
;;       (message "Found next match of `%s'" this))))

;; (defun previous-thing-like-this (this)
;;   (interactive (list
;;                 (cond
;;                  ((and current-prefix-arg
;;                        thgcmd--last-like-this)
;;                   thgcmd--last-like-this)
;;                  ((memq last-command '(next-thing-like-this
;;                                        previous-thing-like-this))
;;                   (buffer-substring-no-properties-thing
;;                    (symbol-name thgcmd-last-thing-type)))
;;                  (t
;;                   (buffer-substring-no-properties-thing
;;                    (let* ((icicle-sort-function  nil)
;;                           (def (symbol-name thgcmd-last-thing-type))
;;                           (thing
;;                            (completing-read
;;                             (concat "Thing (" def "): ")
;;                             (thgcmd-things-alist) nil t nil nil
;;                             def)))
;;                      (setq thgcmd-last-thing-type  (intern thing))
;;                      thing))))))
;;   (when this
;;     (setq thgcmd--last-like-this this)
;;     (if (null (re-search-backward (format "\\_<%s\\_>"
;;                                           (regexp-quote this)) nil t))
;;         (message "No previous match of `%s'" this)
;;       (goto-char (match-beginning 0))
;;       (mapc (lambda (ov)
;;               (overlay-put ov 'invisible nil))
;;             (overlays-at (point)))
;;       (message "Found previous match of `%s'" this))))

(defun minibuffer-yank-word (&optional arg)
  "Yank word at point in the buffer when entering minibuffer into minibuffer."
  (interactive "P")
  (when-let ((text
              (with-selected-window (minibuffer-selected-window)
                (let* ((thing (if arg
                                  (intern
                                   (let ((enable-recursive-minibuffers t))
                                     (completing-read
                                      "Thing (word): "
                                      (thgcmd-things-alist) nil t nil nil
                                      "word")))
                                'word))
                       (bds (tap-bounds-of-thing-at-point thing)))
                  (when bds
                    (goto-char (car bds)))
                  (let ((beg (point)))
                    (when (or (and bds (goto-char (cdr bds)))
                              (forward-word))
                      (buffer-substring-no-properties beg (point))))))))
    (insert text)))
(autoload 'thgcmd-things-alist "thing-cmds" nil t)
(autoload 'tap-bounds-of-thing-at-point "thingatpt+" nil t)

;;;;;;;;;;
;; Keys ;;
;;;;;;;;;;
(with-eval-after-load 'simple
  (define-key read-expression-map "("  #'insert-pair)
  (define-key read-expression-map "["  #'insert-pair)
  (define-key read-expression-map "{"  #'insert-pair)
  (define-key read-expression-map "\""  #'insert-pair))
;; (global-set-key (kbd "M-y") #'kill-ring-insert)
(global-set-key (kbd "C-M-º") #'indent-region)
(global-set-key (kbd "M-s º") #'indent-region)
(global-set-key (kbd "C-x <C-tab>") #'align-regexp)
;; (global-set-key (kbd "C-:") 'next-thing-like-this)
;; (global-set-key (kbd "C-;") 'previous-thing-like-this)
(global-set-key (kbd "C-(") 'surround-change-pair)
(global-set-key (kbd "C-)") 'surround-delete-pair)
(global-set-key (kbd "C-M-(") 'blink-matching-open)
(define-key prog-mode-map "("  #'insert-pair)
(define-key prog-mode-map "["  #'insert-pair)
(define-key prog-mode-map "{"  #'insert-pair)
(define-key prog-mode-map "\""  #'insert-pair)
(define-key prog-mode-map (kbd "RET") 'newline-indent)
(define-key prog-mode-map (kbd "S-<return>") 'newline-blankline-indent)
(define-key prog-mode-map (kbd "M-s 6 +") #'rotate-text)
(define-key prog-mode-map (kbd "M-s 6 -") #'rotate-text-backward)
(define-key prog-mode-map (kbd "M-s 6 n") #'string-inflection-all-cycle)
;; (global-set-key (kbd "ŧ") #'rotate-text)                            ;; AltGr-t
;; (global-set-key (kbd "→") #'string-inflection-all-cycle)            ;; AltGr-i
;; (global-set-key (kbd "ħ") #'pulse-momentary-highlight-current-line) ;; AltGr-h
;; (global-set-key (kbd "½") #'query-replace-regexp)                   ;; AltGr-5
;; (global-set-key (kbd "ð") #'kill-sexp)                              ;; AltGr-d
;; (global-set-key (kbd "ĸ") #'kill-whole-line)                        ;; AltGr-k
;; (global-set-key (kbd "“") #'scroll-other-window)                    ;; AltGr-v
;; (global-set-key (kbd "”") 'sp-or-backward-sexp)                     ;; AltGr-b
;; (global-set-key (kbd "đ") 'sp-or-forward-sexp)                      ;; AltGr-f
;; (global-set-key (kbd "€") 'end-of-defun)                            ;; AltGr-e
;; (global-set-key (kbd "æ") 'beginning-of-defun)                      ;; AltGr-a
(global-set-key (kbd "M-s 7 d") #'toggle-debug-on-error)
(global-set-key (kbd "M-s 7 b") #'toggle-enable-multibyte-characters)
(global-set-key (kbd "M-s 7 c") #'toggle-buffer-coding-system)
(global-set-key (kbd "M-s 7 i") #'toggle-case-fold-search)
(global-set-key (kbd "M-s k w") #'backward-kill-word)
(global-set-key (kbd "M-n") #'forward-paragraph)
(global-set-key (kbd "M-p") #'backward-paragraph)
(global-set-key (kbd "C-<left>") #'left-word)
(global-set-key (kbd "C-<right>") #'right-word)
(global-set-key (kbd "<S-delete>") #'kill-sexp)
(global-set-key (kbd "<C-M-backspace>") #'sp-or-backward-kill-sexp)
;; (global-set-key (kbd "M-s DEL") #'backward-kill-sexp)
;; (global-set-key (kbd "S-<delete>") #'kill-sexp)
(global-set-key (kbd "C-x C-u") #'undo-propose)
(global-set-key (kbd "M-s <deletechar>") #'kill-sexp)
(global-set-key (kbd "C-*") #'duplicate-current-line-or-region)
(global-set-key (kbd "M-s *") #'duplicate-current-line-or-region)
;; (global-set-key (kbd "M-s SPC") #'set-mark-command)
(global-set-key (kbd "M-s SPC") #'fixup-whitespace)
(global-set-key (kbd "C-S-<backspace>") #'kill-whole-line)
(global-set-key (kbd "M-s k l") #'kill-whole-line)
(global-set-key (kbd "M-s <insertchar>") #'kill-whole-line)
(global-set-key (kbd "<M-dead-circumflex>") #'delete-indentation)
(global-set-key (kbd "S-<next>") #'scroll-other-window)
(global-set-key (kbd "S-<prior>") #'scroll-other-window-down)
(global-set-key (kbd "C-<next>") #'hscroll-right)
(global-set-key (kbd "M-s <next>") #'hscroll-right)
(global-set-key (kbd "C-x >") #'hscroll-right)
(global-set-key (kbd "C-<prior>") #'hscroll-left)
(global-set-key (kbd "M-s <prior>") #'hscroll-left)
(global-set-key (kbd "C-x <") #'hscroll-left)
(global-set-key (kbd "M-<right>") #'forward-alt)
(global-set-key (kbd "M-<left>") #'backward-alt)
(global-set-key (kbd "C-ñ") 'find-next-unsafe-char)
(global-set-key (kbd "C-x C-k C-i") 'select-kbd-macro)
(global-set-key (kbd "C-x M-l") 'recenter-horizontal)
;; Case
(global-set-key (kbd "M-c") #'capitalize-dwim)
(global-set-key (kbd "M-l") #'downcase-dwim)
(global-set-key (kbd "M-u") #'upcase-dwim)
;; thingatpt+
(global-set-key (kbd "C-M-SPC") #'select-thing)
(global-set-key (kbd "M-s m") #'select-things)
(global-set-key (kbd "M-s 6 s") #'cycle-select-something)
(global-set-key (kbd "M-s l") #'select-enclosing-list)
(global-set-key (kbd "M-s f") #'select-enclosing-list-forward)
(global-set-key (kbd "M-s b") #'select-enclosing-list-backward)
(global-set-key (kbd "M-s n") #'next-visible-thing-repeat)
(global-set-key (kbd "M-s p") #'previous-visible-thing-repeat)
(global-set-key (kbd "C-c l") #'display-line-numbers-mode)

(global-set-key (kbd "M-g f") #'find-dired)

(define-key minibuffer-local-map "\C-w" #'minibuffer-yank-word)
(define-key minibuffer-local-map (kbd "C-c C-l") 'helm-minibuffer-history)

;; Usa el clipboard del sistema
;; (global-set-key [(shift delete)] 'clipboard-kill-region)
;; (global-set-key [(control insert)] 'clipboard-kill-ring-save)
;; (global-set-key [(shift insert)] 'clipboard-yank)
#+end_src

* Buffers

#+begin_src elisp
(setq revert-without-query '("\\.calc\\.py\\'"))

(defun buffers-from-file (&optional frame)
  "Get buffers from file in FRAME."
  (let ((tmp-list '()))
    (dolist (buffer (buffer-list frame))
      (when (buffer-file-name buffer)
        (setq tmp-list (cons buffer tmp-list))))
    tmp-list))

(defun kill-buffers-from-file (&optional frame)
  "Kill buffers from file in FRAME."
  (interactive (list (if current-prefix-arg
                         (read-from-minibuffer "Frame: ")
                       nil)))
  (let ((file-list (buffers-from-file frame)))
    (when file-list
      (mapc #'kill-buffer file-list))))

(defun kill-buffer-or-buffers-from-file (&optional frame)
  "Kill buffers or buffers from file in FRAME."
  (interactive (list (if current-prefix-arg
                         (selected-frame)
                       nil)))
  (if frame
      (kill-buffers-from-file frame)
    (kill-buffer)))

;; already exists
;; (defun kill-buffer-and-window (buffer)
;;   (interactive (list (current-buffer)))
;;   (let ((win (get-buffer-window buffer)))
;;     (kill-buffer buffer)
;;     (when (window-live-p win)
;;       (delete-window win))))

(defun buffers-with-window (&optional frame)
  "Get buffers with window in FRAME."
  (let ((tmp-list '()))
    (dolist (window (window-list frame))
      (let ((buffer (window-buffer window)))
        (when (buffer-file-name buffer)
          (setq tmp-list (cons buffer tmp-list)))))
    (delete-dups tmp-list)))

;; Kill all file buffers with window
(defun kill-buffers-with-window (&optional frame)
  "Kill all buffers from file with window in FRAME."
  (interactive (list (if current-prefix-arg
                         (read-from-minibuffer "Frame: ")
                       nil)))
  (let ((file-list (buffers-with-window frame)))
    (when file-list
      (mapc 'kill-buffer file-list))))

;; Kill buffer if you wish when close frame.
(defun kill-buffers-group-choice (&optional frame)
  "Kill buffers if you wish when close FRAME."
  (interactive (list (if current-prefix-arg
                         (read-from-minibuffer "Frame: ")
                       nil)))
  (when (buffers-with-window)
    (cl-case (read-char-choice "Kill buffers [c]urrent/[f]iles/[w]indows/[n]othing? "
                            (append "cCfFwWnNqQ" nil))
      ((?c ?C)
       (kill-buffer))
      ((?f ?F)
       (kill-buffers-from-file frame))
      ((?w ?W)
       (kill-buffers-with-window frame)))))

(defun list-all-buffers (&optional files-only)
  "Display a list of names of existing buffers.
The list is displayed in a buffer named `*Buffer List*'.
Non-null optional arg FILES-ONLY means mention only file buffers.

For more information, see the function `buffer-menu'."
  (interactive "P")
  (select-window
   (display-buffer (list-buffers-noselect files-only (buffer-list)))))

(define-key global-map [remap list-buffers] 'ibuffer)
(define-key global-map (kbd "C-x C-b") 'ibuffer-other-window)
#+end_src

* Windows

#+begin_src elisp
;; display left rotating anticlockwise
(defun display-buffer-tiling-anticlockwise (buffer alist)
  (rotate-frame-anticlockwise)
  (display-buffer-in-direction buffer (cons '(direction . leftmost) alist)))

;; display right
(defun display-buffer-help-condition (buffer-name action)
  (with-current-buffer buffer-name
    (derived-mode-p 'help-mode)))

(defun display-buffer-at-right (buffer alist)
  (display-buffer-in-direction buffer (cons '(direction . rightmost) alist)))

;; (push '(display-buffer-help-condition
;;         display-buffer-at-right)
;;       display-buffer-alist)

;; display bottom
(defun display-buffer-term-condition (buffer-name action)
  (with-current-buffer buffer-name
    (derived-mode-p 'term-mode 'shell-mode 'eshell-mode
                    'docker-container-mode)))

;; (push '(display-buffer-term-condition
;;         display-buffer-at-bottom)
;;       display-buffer-alist)

;; display left
(defun display-buffer-main-condition (buffer-name action)
  (with-current-buffer buffer-name
    (derived-mode-p 'prog-mode 'org-mode)))

(defun display-buffer-at-left (buffer alist)
  (display-buffer-in-direction buffer (cons '(direction . leftmost) alist)))

;; (push '(display-buffer-main-condition
;;         display-buffer-at-left)
;;       display-buffer-alist)

;; split window
(defun split-window-mode-sensibly (&optional window)
  (or window (setq window (selected-window)))
  (cond
   ((with-selected-window window
      (derived-mode-p 'prog-mode 'org-mode 'help-mode 'compilation-mode))
    (let ((split-height-threshold nil)
          (split-width-threshold 140))
      (split-window-sensibly window)))
   ((with-selected-window window
      (derived-mode-p 'term-mode 'shell-mode 'eshell-mode
                      'docker-container-mode))
    (let ((split-height-threshold 20))
      (split-window-sensibly window)))
   (t
    (split-window-sensibly window))))

(defun split-window-mode-rigid (&optional window)
  (or window (setq window (selected-window)))
  (cond
   ((with-selected-window window
      (derived-mode-p 'prog-mode 'org-mode 'help-mode 'compilation-mode))
    (split-window-right))
   ((with-selected-window window
      (derived-mode-p 'term-mode 'shell-mode 'eshell-mode
                      'docker-container-mode))
    (split-window-below))
   (t
    (split-window-sensibly window))))

(defvar hscroll-aggressive nil)
(setq fit-window-to-buffer-horizontally nil
      register-preview-delay nil
      split-window-preferred-function 'split-window-mode-sensibly
      message-truncate-lines nil
      ;; Vertical Scroll
      ;; scroll-preserve-screen-position 'always
      ;; scroll-margin 2
      ;; scroll-step 2
      ;; [ Nil means display update is paused when input is detected
      ;; obsolete variable, annoying hold down key if nil
      ;; redisplay-dont-pause t
      ;; ]
      ;; Dangerous, annoying scroll holding next-line
      ;; fast-but-imprecise-scrolling t
      redisplay-skip-fontification-on-input t
      ;; mouse-wheel-progressive-speed nil
      ;; > 100 Never recenter point
      ;; scroll-conservatively 101
      ;; Horizontal Scroll
      ;;hscroll-margin 2
      ;;hscroll-step (* 2 hscroll-margin)
      auto-window-vscroll nil)

(add-hook 'term-mode-hook
          (lambda ()
            (set (make-local-variable 'scroll-margin) 0)))

(defun toggle-message-truncate-lines ()
  "Toggle truncate lines in messages."
  (interactive)
  (setq message-truncate-lines (not message-truncate-lines)))

(defun toggle-hscroll-aggressive ()
  "Toggle hscroll aggressive."
  (interactive)
  (if hscroll-aggressive
      (progn
        (setq  hscroll-margin 2
               hscroll-step 1
               hscroll-aggressive nil))
    (progn
      (setq  hscroll-margin 10
             hscroll-step 25
             hscroll-aggressive t))))
;; [ filter annoying messages
;; (defvar message-filter-regexp-list '("^Starting new Ispell process \\[.+\\] \\.\\.\\.$"
;;                                      "^Ispell process killed$")
;;   "filter formatted message string to remove noisy messages")
;; (defadvice message (around message-filter-by-regexp activate)
;;   (if (not (ad-get-arg 0))
;;       ad-do-it
;;     (let ((formatted-string (apply 'format (ad-get-args 0))))
;;       (if (and (stringp formatted-string)
;;                (some (lambda (re) (string-match re formatted-string)) message-filter-regexp-list))
;;           (save-excursion
;;             (set-buffer "*Messages*")
;;             (goto-char (point-max))
;;             (insert formatted-string "\n"))
;;         (progn
;;           (ad-set-args 0 `("%s" ,formatted-string))
;;           ad-do-it)))))
;; ]
;; message timestamp
;; thanks to: https://emacs.stackexchange.com/questions/32150/how-to-add-a-timestamp-to-each-entry-in-emacs-messages-buffer
(defun message-timestamp-advice (format-string &rest _args)
  "Advice to run before `message' with FORMAT-STRING ARGS that prepend a timestamp to each message."
  (unless (string-equal format-string "%s%s")
    (let ((deactivate-mark nil)
          (inhibit-read-only t))
      (with-current-buffer "*Messages*"
        (goto-char (point-max))
        (if (not (bolp))
            (newline))
        (let* ((nowtime (current-time))
               (now-ms (nth 2 nowtime)))
          (insert (format-time-string "[%Y-%m-%d %T" nowtime)
                  (format ".%06d]" now-ms) " "))))))
(defvar message-advice-timestamp nil)
(defun advice-message-timestamp ()
  (interactive)
  (set 'message-advice-timestamp t))
(defun unadvice-message-timestamp ()
  (interactive)
  (set 'message-advice-timestamp nil))
;; not necesary, included in message-filter
;; (advice-add 'message :before 'message-timestamp-advice)
(defun signal-timestamp-advice (error-symbol data)
  "Advice to run before `signal' with ERROR-SYMBOL DATA that prepend a timestamp to each message."
  (let ((deactivate-mark nil)
        (inhibit-read-only t))
    (with-current-buffer "*Messages*"
      (goto-char (point-max))
      (if (not (bolp))
          (newline))
      (let* ((nowtime (current-time))
             (now-ms (nth 2 nowtime)))
        (insert (format-time-string "<%Y-%m-%d %T" nowtime)
                (format ".%06d>" now-ms) " " (if data (format "%s" data)))))))
(defun advice-signal-timestamp ()
  (interactive)
  (advice-add 'signal :before 'signal-timestamp-advice))
(defun unadvice-signal-timestamp ()
  (interactive)
  (advice-remove 'signal 'signal-timestamp-advice))
;; Truncate lines in messages and filter messages buffer
(defvar message-nillog-filter-functions '()) ;; (lambda (str) (string-match-p "oading" str))
(defvar message-inhibit-filter-functions '())
(defun message-filter (orig-fun msg &rest args)
  "Advice ORIG-FUN with args MSG and ARGS.  Filter arguments."
  (if (and
       message-log-max
       (not inhibit-message)
       msg)
      (let ((msg-str (apply #'format msg args)))
        (let ((inhibit-message
               (and
                message-inhibit-filter-functions
                (cl-some #'(lambda (func)
                             (funcall func msg-str)) message-inhibit-filter-functions)))
              (message-log-max
               (if (and
                    message-nillog-filter-functions
                    (cl-some #'(lambda (func)
                                 (funcall func msg-str)) message-nillog-filter-functions))
                   nil
                 message-log-max)))
          (if message-advice-timestamp (message-timestamp-advice msg))
          (apply orig-fun msg args)))
    (apply orig-fun msg args)))
;;(advice-add 'message :around #'message-filter)

;; Don't show on windows buffers currently showed
;; (defun diplay-buffer-advice (orig-fun buffer-or-name &optional action frame)
;;   (let ((window (funcall orig-fun buffer-or-name action frame)))
;;     (when (and (windowp window)
;;                (window-live-p window))
;;       (select-window window))))
;; (advice-add 'display-buffer :around 'diplay-buffer-advice)

;; (with-selected-window window
;;   (pulse-momentary-highlight-region (window-start window)
;;                                     (window-end window)))

;; [ Conflict with *Completions* buffer
;; (defun display-buffer-if-not-showed (orig-fun buffer-or-name &rest args)
;;   "Advice ORIG-FUN with args BUFFER-OR-NAME and ARGS.
;; Don't show on windows buffers currently showed."
;;   (let ((window (get-buffer-window buffer-or-name 0)))
;;     (if (windowp window)
;;         window
;;       (apply orig-fun buffer-or-name args))))
;; (advice-add 'display-buffer :around #'display-buffer-if-not-showed)
;; ]

;; Thanks to: https://superuser.com/questions/132225/how-to-get-back-to-an-active-minibuffer-prompt-in-emacs-without-the-mouse
(defun switch-to-minibuffer-window ()
  "switch to minibuffer window (if active)"
  (interactive)
  (if (and (bound-and-true-p mini-frame-frame)
           (frame-live-p mini-frame-frame)
           (frame-visible-p mini-frame-frame))
      (select-frame mini-frame-frame)
    (when-let (minibuffer-window (active-minibuffer-window))
      (if (window-minibuffer-p)
          (switch-to-completions)
        (select-frame-set-input-focus (window-frame minibuffer-window))
        (select-window minibuffer-window)))))

;; undo and redo window distributions
(setq winner-dont-bind-my-keys t)
(winner-mode)

(require 'windmove)
;;(windmove-default-keybindings 'meta)

(require 'find-file)
(defun switch-to-other-buffer ()
  "Switch to dual buffer whether exists."
  (interactive)
  (let ((ignore ff-ignore-include)
        (create ff-always-try-to-create))
    (setq ff-ignore-include t)
    (setq ff-always-try-to-create nil)
    (unless (or (not (fboundp 'ff-find-the-other-file))
                (ff-find-the-other-file))
      (let ((file-list (buffers-from-file)))
        (if file-list
            (switch-to-buffer (cl-first file-list))
          (switch-to-prev-buffer))))
    (setq ff-ignore-include ignore)
    (setq ff-always-try-to-create create)))

(defun vsplit-last-buffer (&optional size)
  "Split last buffer vertically."
  (interactive "P")
  (split-window-vertically size)
  (other-window 1)
  (switch-to-other-buffer))

(defun hsplit-last-buffer (&optional size)
  "Split last buffer horizontally."
  (interactive "P")
  (split-window-horizontally size)
  (other-window 1)
  (switch-to-other-buffer))

;; Desbalancea el split vertical
;;(defadvice split-window-vertically
;;   (after my-window-splitting-advice activate)
;;    (enlarge-window (truncate (/ (window-body-height) 2))))

(defun halve-other-window-height ()
  "Expand current window to use half of the other window's lines."
  (interactive)
  (balance-windows)
  (enlarge-window (truncate (/ (window-height) 2))))

;; use Shift+arrow_keys to move cursor around split panes
;;(windmove-default-keybindings)

;; when cursor is on edge, move to the other side, as in a toroidal space
;;(setq windmove-wrap-around t )

(defun window-dedicate-this ()
  "Dedicate focus window."
  (interactive)
  (set-window-dedicated-p (selected-window) t))

(defun window-undedicate-this ()
  "Dedicate focus window."
  (interactive)
  (set-window-dedicated-p (selected-window) nil))

(defun window-dedicate-all (&optional frame)
  "Dedicate all windows in the presente FRAME."
  (interactive)
  (dolist (window (window-list frame))
    (set-window-dedicated-p window t)))

(defun window-undedicate-all (&optional frame)
  "Dedicate all windows in the presente FRAME."
  (interactive)
  (dolist (window (window-list frame))
    (set-window-dedicated-p window nil)))

;; Switch window
(defun switch-to-window (arg)
  (interactive "P")
  (let ((windows (pcase arg
                   ('()
                    (window-list))
                   ('(4)
                    (apply #'append (mapcar #'window-list (visible-frame-list))))
                   ('(16)
                    (apply #'append (mapcar #'window-list (frame-list)))))))
    (setq windows (delq (selected-window) windows))
    (pcase (length windows)
      (0)
      (1 (select-window (car windows)))
      (_
       (let* ((windows-strings (mapcar #'buffer-name (mapcar #'window-buffer windows)))
              (windows-alist (cl-mapcar #'cons windows-strings windows))
              (option (completing-read
                       "Switch to: "
                       `(,@windows-strings windmove-left windmove-right windmove-up windmove-down)
                       nil t nil nil (car windows-strings)))
              (window-assoc (assoc option windows-alist)))
         (if window-assoc
             (select-window (cdr window-assoc))
           (funcall (intern option))))))))

;; window resize
(defun window-resize-width (arg &optional window max-width min-width preserve-size)
  "ARG nil Fit WINDOW according to its buffer's width.
WINDOW, MAX-WIDTH and MIN-WIDTH have the same meaning as in
`fit-window-to-buffer'.

ARG non-nil resize window to ARG width."
  (interactive "P")
  (if arg
      (window-resize (or window (selected-window)) (- arg (window-width)) t)
    (let ((fit-window-to-buffer-horizontally 'only))
      (fit-window-to-buffer window nil nil max-width min-width preserve-size))))

(defun window-resize-height (arg &optional window max-height min-height preserve-size)
  "ARG nil Fit WINDOW according to its buffer's height.
WINDOW, MAX-HEIGHT and MIN-HEIGHT have the same meaning as in
`fit-window-to-buffer'.

ARG non-nil resize window to ARG height."
  (interactive "P")
  (if arg
      (window-resize (or window (selected-window)) (- arg (window-height)))
    (let ((fit-window-to-buffer-horizontally nil))
      (fit-window-to-buffer window max-height min-height nil nil preserve-size))))

(defun window-preserve-width (&optional window)
  (interactive)
  (window-preserve-size window t t))

(defun window-resize-equal (arg size)
  (interactive "P\nnSize: ")
  (let ((window (selected-window))
        (horizontal (not arg)))
    (window-resize window (- (if (< 0 size) size 80)
                             (window-size window horizontal))
                   horizontal)))

(defun window-resize-delta (arg delta)
  (interactive "P\nnDelta: ")
  (window-resize (selected-window) delta (not arg)))

(defun window-resize-factor (arg factor)
  (interactive "P\nnFactor: ")
  (let ((window (selected-window))
        (horizontal (not arg)))
    (window-resize window (round
                           (* (window-size window horizontal)
                              (1- factor)))
                   horizontal)))

;; autoresize
(defvar-local window-autoresize-size nil)

(defun window-autoresize (window)
  (when (and window-autoresize-size
             (not (active-minibuffer-window)))
    (let ((width-heigth (cdr (assoc (if (eq window (selected-window))
                                        'selected
                                      'unselected)
                                    window-autoresize-size))))
      (if width-heigth
          (let ((width (car width-heigth))
                (height (cdr width-heigth)))
            (if (numberp width)
                (let ((delta-width (- width (window-size window t))))
                  (if (and (/= 0 delta-width)
                           (/= 0 (setq delta-width
                                       (window-resizable
                                        window
                                        delta-width
                                        t))))
                      (window-resize window
                                     delta-width
                                     t))))
            (if (numberp height)
                (let ((delta-height (- height (window-size window))))
                  (if (and (/= 0 delta-height)
                           (/= 0 (setq delta-height
                                       (window-resizable
                                        window
                                        delta-height))))
                      (window-resize window
                                     delta-height)))))))))
(add-hook 'pre-redisplay-functions 'window-autoresize)

(defun window-autoresize-set-size (selected-width selected-height
                                                  unselected-width unselected-height)
  (interactive
   "xWidth selected: \nxHeight selected: \nxWidth unselected: \nxHeight unselected: ")
  (setq window-autoresize-size
        (list (cons 'selected (cons selected-width selected-height))
              (cons 'unselected (cons unselected-width unselected-height)))))

(defun window-autoresize-set-default (unselected-width)
  (interactive "p")
  (cond
   ((or (derived-mode-p 'org-mode)
        (derived-mode-p 'python-mode))
    (let ((numbers-margin (if display-line-numbers
                              (if (numberp display-line-numbers-width)
                                  display-line-numbers-width
                                3)
                            0)))
      (window-autoresize-set-size
       (+ 82 numbers-margin)
       30
       (if (<= unselected-width 1)
           (+ 19 numbers-margin)
         (+ 2 unselected-width numbers-margin))
       4)))))

(defun window-autoresize-unset ()
  (interactive)
  (setq window-autoresize-size nil))

;; [ Visual line mode
(defun toggle-continuation-lines (&optional arg)
  (interactive "P")
  (if (if (numberp arg)
          (< 0 arg)
        (or visual-line-mode
            (null truncate-lines)))
      (progn
        (visual-line-mode -1)
        (toggle-truncate-lines 1))
    (unless (default-value 'truncate-lines)
      (toggle-truncate-lines -1))
    (when global-visual-line-mode
      (visual-line-mode 1))))
;; ]

;; winner
(require 'winner)
(with-eval-after-load 'hydra
  (eval-when-compile
    (require 'hydra))
  (defhydra hydra-win (:foreign-keys warn)
    "WIN"
    ("C-<right>" (lambda () (interactive)
                   (enlarge-window-horizontally 1)
                   (message "Width: %i" (window-width))))
    ("S-<right>" (lambda () (interactive)
                   (enlarge-window-horizontally 10)
                   (message "Width: %i" (window-width))) "↔+")
    ("C-<left>" (lambda () (interactive)
                  (shrink-window-horizontally 1)
                  (message "Width: %i" (window-width))))
    ("S-<left>" (lambda () (interactive)
                  (shrink-window-horizontally 10)
                  (message "Width: %i" (window-width))) "↔-")
    ("C-<up>" (lambda () (interactive)
                (enlarge-window 1)
                (message "Height: %i" (window-height))))
    ("S-<up>" (lambda () (interactive)
                (enlarge-window 10)
                (message "Height: %i" (window-height))) "↕+")
    ("C-<down>" (lambda () (interactive)
                  (shrink-window 1)
                  (message "Height: %i" (window-height))))
    ("S-<down>" (lambda () (interactive)
                  (shrink-window 10)
                  (message "Height: %i" (window-height))) "↕-")
    ("C-p" winner-undo "undo")
    ("C-n" winner-redo "redo")
    ("M-q" nil "quit"))
  (global-set-key (kbd "C-c w m") 'hydra-win/body))

(define-key winner-mode-map [(control c) left] nil)
(define-key winner-mode-map [(control c) right] nil)
(define-key winner-mode-map (kbd "C-c w -") #'winner-undo)
(define-key winner-mode-map (kbd "<s-f11>") #'winner-undo)
(define-key winner-mode-map (kbd "C-c w _") #'winner-redo)
(define-key winner-mode-map (kbd "<s-f12>") #'winner-redo)

(global-set-key (kbd "M-s 0") 'switch-to-minibuffer-window)
(global-set-key (kbd "M-s 7 w") 'toggle-continuation-lines)
(global-set-key (kbd "M-s 7 v") #'visual-line-mode)
(global-set-key (kbd "C-x `") 'shrink-window)
#+end_src

* Frames

#+begin_src elisp
;; (setq initial-frame-alist (nconc '((minibuffer . only)) initial-frame-alist)
;;       default-frame-alist (nconc '((minibuffer . nil)) default-frame-alist)
;;       minibuffer-auto-raise t)
;; (add-hook 'minibuffer-exit-hook 'lower-frame)
;; Ajusta el tamaño de la ventana a la resolución.
;; (defun set-frame-size-according-to-resolution ()
;;   (interactive)
;;   (if window-system
;;   (progn
;;     ;; use 100 char wide window for largeish displays
;;     ;; and smaller 80 column windows for smaller displays
;;     ;; pick whatever numbers make sense for you
;;     (if (> (x-display-pixel-width) 1280)
;;            (add-to-list 'default-frame-alist (cons 'width 100))
;;            (add-to-list 'default-frame-alist (cons 'width 80)))
;;     ;; for the height, subtract a couple hundred pixels
;;     ;; from the screen height (for panels, menubars and
;;     ;; whatnot), then divide by the height of a char to
;;     ;; get the height we want
;;     (add-to-list 'default-frame-alist
;;          (cons 'height (/ (- (x-display-pixel-height) 250)
;;                              (+ (frame-char-height) 1)))))))
;;
;; (set-frame-size-according-to-resolution)

;; (when (executable-find "bspc")
;;   (let ((color
;;          (substring
;;           (shell-command-to-string "bspc config focused_border_color") 0 -1)))
;;     (when (and (stringp color)
;;                (string-match-p "#[0-9abcdef]\\{6\\}" color))
;;       (modify-all-frames-parameters `((border-color . ,color))))))

;; Call last keyboard macro in windows
(defun kmacro-call-other-windows-all-frames (window &optional all-frames)
  "Call last keyboard macro in windows other than WINDOW.

Optional argument ALL-FRAMES nil or omitted means consider all windows
on WINDOW’s frame, plus the minibuffer window if specified by the
MINIBUF argument.  If the minibuffer counts, consider all windows on all
frames that share that minibuffer too.  The following non-nil values of
ALL-FRAMES have special meanings:

- t means consider all windows on all existing frames.

- ‘visible’ means consider all windows on all visible frames.

- 0 (the number ero) means consider all windows on all visible and
  iconified frames.

- A frame means consider all windows on that frame only.

Anything else means consider all windows on WINDOW’s frame and no
others."
  (interactive (list (selected-window) 'visible))
  (save-selected-window
    (dolist (other-window (cdr (window-list-1 window 0 all-frames)))
      (select-window other-window)
      (kmacro-call-macro 1))))

(defun kmacro-call-all-windows-all-frames (&optional all-frames)
  "Call last keyboard macro in windows other than WINDOW.

Optional argument ALL-FRAMES nil or omitted means consider all windows
on WINDOW’s frame, plus the minibuffer window if specified by the
MINIBUF argument.  If the minibuffer counts, consider all windows on all
frames that share that minibuffer too.  The following non-nil values of
ALL-FRAMES have special meanings:

- t means consider all windows on all existing frames.

- ‘visible’ means consider all windows on all visible frames.

- 0 (the number zero) means consider all windows on all visible and
  iconified frames.

- A frame means consider all windows on that frame only.

Anything else means consider all windows on WINDOW’s frame and no
others."
  (interactive (list 'visible))
  (save-selected-window
    (dolist (window (window-list-1 nil 0 all-frames))
      (select-window window)
      (kmacro-call-macro 1))))

(defun kmacro-call-other-windows-in-frame (&optional frame window)
  "Call last keyboard macro in FRAME's windows other than WINDOW."
  (interactive (list (selected-frame) (selected-window)))
  (save-selected-window
    (dolist (other-window (cdr (window-list frame 0 window)))
      (select-window other-window)
      (kmacro-call-macro 1))))

(defun kmacro-call-all-windows-in-frame (&optional frame)
  "Call last keyboard macro in FRAME's windows."
  (interactive (list (selected-frame)))
  (save-selected-window
    (dolist (window (window-list frame 0))
      (select-window window)
      (kmacro-call-macro 1))))

;;(add-hook 'delete-frame-functions #'kill-buffers-group-choice)
(require 'server)
(defun save-buffers-kill-terminal-with-choice (&optional arg)
  "Exit Emacs with ARG option."
  (interactive "P")
  (cond
   ((not (frame-parameter nil 'client))
    (save-buffers-kill-emacs arg))
   ((equal arg '(4))
    (save-buffers-kill-terminal arg))
   ((equal arg '(16))
    (save-buffers-kill-emacs arg))
   (t
    (progn
      (save-some-buffers arg)
      (kill-buffers-group-choice)
      (let ((proc (frame-parameter nil 'client)))
        (cond ((eq proc 'nowait)
               ;; Nowait frames have no client buffer list.
               (if (cdr (frame-list))
                   (delete-frame)
                 ;; If we're the last frame standing, kill Emacs.
                 (save-buffers-kill-emacs arg)))
              ((processp proc)
               (let ((buffers (process-get proc 'buffers)))
                 ;; If client is bufferless, emulate a normal Emacs exit
                 ;; and offer to save all buffers.  Otherwise, offer to
                 ;; save only the buffers belonging to the client.
                 (save-some-buffers
                  arg (if buffers
                          (lambda () (memq (current-buffer) buffers))
                        t))
                 (server-delete-client proc)))
              (t (error "Invalid client frame"))))))))

(require 'transpose-frame)
;; [ Frames layouts
(defun shell-3-window-frame ()
  "Development window format."
  (interactive)
  (delete-other-windows)
  (split-window-horizontally)
  (split-window-vertically)
  (shrink-window (truncate (/ (* (window-height) 2) 5)))
  (other-window 1)
  (other-window 1)
  (shell)
  (other-window 2)
  (switch-to-other-buffer))

(defun shell-2-window-frame ()
  "Test window format."
  (interactive)
  (delete-other-windows)
  (split-window-horizontally)
  (other-window 1)
  (shell))
;; ]
;;;;;;;;;;
;; Keys ;;
;;;;;;;;;;
(global-set-key (kbd "C-c <left>") 'windmove-left)
(global-set-key (kbd "C-c <right>") 'windmove-right)
(global-set-key (kbd "C-c <up>") 'windmove-up)
(global-set-key (kbd "C-c <down>") 'windmove-down)
(global-set-key (kbd "C-c w b") 'windmove-left)
(global-set-key (kbd "C-c w f") 'windmove-right)
(global-set-key (kbd "C-c w p") 'windmove-up)
(global-set-key (kbd "C-c w n") 'windmove-down)
(global-set-key (kbd "C-c b p") #'previous-buffer)
(global-set-key (kbd "C-c b n") #'next-buffer)
(global-set-key (kbd "C-x B") 'list-all-buffers)

;; (defhydra hydra-win (global-map "C-c")
;;   "WIN"
;;   ("<left>" windmove-left)
;;   ("<right>" windmove-right)
;;   ("<up>" windmove-up)
;;   ("<down>" windmove-down))

(global-set-key (kbd "C-c M-r") #'revert-buffer)
(global-set-key (kbd "C-x C-c") 'save-buffers-kill-terminal-with-choice)
(global-set-key (kbd "C-x k") 'kill-buffer-or-buffers-from-file)
(global-set-key (kbd "C-x K") 'kill-buffer-and-window)

(global-set-key (kbd "C-c b t") #'toggle-tool-bar-mode-from-frame)
(global-set-key (kbd "C-c b m") #'toggle-menu-bar-mode-from-frame)
(global-set-key (kbd "M-s 7 e") 'toggle-message-truncate-lines)

;; (global-set-key (kbd "C-x o") 'switch-to-window)
;; (global-set-key (kbd "C-x 2") 'vsplit-last-buffer)
;; (global-set-key (kbd "C-x 3") 'hsplit-last-buffer)


(global-set-key (kbd "<s-f10>") #'window-configuration-to-register)
(global-set-key (kbd "<s-f9>") #'jump-to-register)
(global-set-key (kbd "C-c w =") 'window-resize-equal)
(global-set-key (kbd "C-c w +") 'window-resize-delta)
(global-set-key (kbd "C-c w *") 'window-resize-factor)
(global-set-key (kbd "C-c w .") 'fit-window-to-buffer)
(global-set-key (kbd "C-c w t") #'transpose-frame)
(global-set-key (kbd "C-c w h") #'flop-frame)
(global-set-key (kbd "C-c w v") #'flip-frame)
(global-set-key (kbd "C-c w r") #'rotate-frame-clockwise)
(global-set-key (kbd "C-c w C-r") #'rotate-frame-anticlockwise)
(global-set-key (kbd "C-c w 2") 'shell-2-window-frame)
(global-set-key (kbd "C-c w 3") 'shell-3-window-frame)
(global-set-key (kbd "C-c w a") 'toggle-hscroll-aggressive)
(global-set-key (kbd "C-c w o") 'halve-other-window-height)
(global-set-key (kbd "C-c w d a") 'window-dedicate-all)
(global-set-key (kbd "C-c w u a") 'window-undedicate-all)
(global-set-key (kbd "C-c w d t") 'window-dedicate-this)
(global-set-key (kbd "C-c w u t") 'window-undedicate-this)
(global-set-key (kbd "C-c w A d") 'window-autoresize-set-default)
(global-set-key (kbd "C-c w A s") 'window-autoresize-set-size)
(global-set-key (kbd "C-c w A u") 'window-autoresize-unset)
(global-set-key (kbd "C-c w P w") 'window-preserve-width)
(global-set-key (kbd "C-c w C-h") 'window-resize-height)
(global-set-key (kbd "C-c w C-w") 'window-resize-width)
(global-set-key (kbd "C-c w S") 'balance-windows-area)
(global-set-key (kbd "C-x 5 r") (lambda () (interactive) (redraw-frame)))
#+end_src

* EXWM

Avoid /Ubuntu 20.04/ slow startup

#+begin_src sh
sudo apt-get remove --purge dbus-user-session
#+end_src

#+RESULTS:

#+begin_src elisp
(with-eval-after-load 'exwm
  ;; Below are configurations for EXWM.
  (message "Importing exwm-startup-config")
  ;; Add paths (not required if EXWM is installed from GNU ELPA).
                                        ;(add-to-list 'load-path "/path/to/xelb/")
                                        ;(add-to-list 'load-path "/path/to/exwm/")

  ;; Fix problems with Ido (if you use it).
  ;; (require 'exwm-config)
  ;; (exwm-config-ido)
  (require 'exwm-randr)

  ;; ;;;;;;;;; ;;
  ;; Variables ;;
  ;; ;;;;;;;;; ;;
  (defvar exwm-close-window-on-kill nil
    "EXWM close window when kill buffer.")

  (defvar exwm-exclude-transparency '("totem" "vlc" "darkplaces" "doom" "gzdoom")
    "EXWM instances without transparency.")

  (defvar exwm-default-transparency 0.85
    "EXWM default transparency.")

  (defvar exwm-char-mode-classes '("Emacs" "st-256color" "Alacritty" "URxvt" "XTerm" "nyxt")
    "EXWM char mode classes")

  ;; example: export EXWM_MONITOR_ORDER="eDP-1 HDMI-1 DP-1"
  (defvar exwm-default-monitor-order
    (let ((monitor-order (getenv "EXWM_MONITOR_ORDER")))
      (if monitor-order
          (condition-case nil
              (split-string monitor-order  " ")
            (error nil))))
    "EXWM default monitor order.")

  ;; example: export EXWM_MONITOR_RESOLUTION="HDMI-1 1280x720 DP-1 800x600"
  (defvar exwm-default-monitor-resolution
    (let ((monitor-resolution (getenv "EXWM_MONITOR_RESOLUTION")))
      (if monitor-resolution
          (condition-case nil
              (split-string monitor-resolution  " ")
            (error nil))))
    "EXWM default monitor resolution.")

  ;; example: export EXWM_MINIBUFFER_NUMBER="1"
  ;; example: export EXWM_MINIBUFFER_NUMBER="eDP-1"
  (defvar exwm-default-minibuffer-workspace-or-screen
    (let ((workspace-or-screen
           (getenv "EXWM_MINIBUFFER_WORKSPACE_OR_SCREEN")))
      (if workspace-or-screen
          (or (cl-parse-integer
               workspace-or-screen :junk-allowed t)
              workspace-or-screen)
        0))
    "EXWM default minibuffer workspace number.")

  (defvar exwm-default-wallpaper-folder "~/Pictures/backgrounds/"
    "EXWM default wallpaper folder.")

  (defvar exwm-screensaver-process nil
    "EXWM screensaver process.")

  (defvar exwm-record-process nil
    "EXWM record process when recording.")

  (defvar exwm-record-recording (propertize "⏺" 'face '(:foreground "red2"))
    "EXWM recording text displayed while recording")

  ;; ;;;;;;;;; ;;
  ;; Functions ;;
  ;; ;;;;;;;;; ;;
  (eval-and-compile
    (require 'xcb))
  (defun exwm-set-border-color (color &optional buffer)
    "Set BUFFER border COLOR color."
    (when-let ((id (car (rassoc (or buffer (current-buffer))
                                exwm--id-buffer-alist))))
      (xcb:+request exwm--connection
          (make-instance 'xcb:ChangeWindowAttributes
                         :window id
                         :value-mask xcb:CW:BorderPixel
                         :border-pixel (exwm--color->pixel color)))
      (xcb:flush exwm--connection)))

  (defun exwm-set-border-width (border-width &optional buffer)
    "Set BUFFER border BORDER-WIDTH width."
    (when-let (id (car (rassoc (or buffer (current-buffer))
                               exwm--id-buffer-alist)))
      (xcb:+request exwm--connection
          (make-instance 'xcb:ConfigureWindow
                         :window id
                         :value-mask xcb:ConfigWindow:BorderWidth
                         :border-width border-width))
      (xcb:flush exwm--connection)))

  (defvar exwm-gap-monitor 20)
  (defun exwm-gap-toggle ()
    (interactive)
    (let* ((result (if exwm-randr--compatibility-mode
                       (exwm-randr--get-outputs)
                     (exwm-randr--get-monitors)))
           (primary-monitor (elt result 0))
           (monitor-geometry-alist (elt result 1))
           (monitor (plist-get exwm-randr-workspace-monitor-plist 0))
           (frame (elt exwm-workspace--list 0))
           (geometry (cdr (assoc monitor monitor-geometry-alist))))
      (unless geometry
        (setq geometry (cdr (assoc primary-monitor
                                   monitor-geometry-alist))))
      (if (equal geometry (frame-parameter frame 'exwm-geometry))
          (exwm-randr-refresh)
        (let ((exwm-gap-monitor 0))
          (exwm-randr-refresh)))))



  (defun exwm-record-stop ()
    (interactive)
    (when exwm-record-process
      (interrupt-process exwm-record-process)
      (message "EXWM Record process interrupted")))

  (defun exwm-record-start (monitor pcm-device)
    (interactive (list (let ((monitors (exwm-xrandr-parse)))
                         (gethash (completing-read
                                   "Select monitor: "
                                   (hash-table-keys monitors)
                                   nil t)
                                  monitors))
                       (completing-read
                        "Select audio input: "
                        (split-string
                         (shell-command-to-string
                          "arecord -L | grep -v -E \"^[[:space:]]\"")
                         "\n" t)
                        nil t nil nil "default")))
    (setq exwm-record-process
          (start-process
           "*exwm-record-process*" (if current-prefix-arg "*ffmpeg output*")
           "ffmpeg" "-thread_queue_size" "512"
           "-nostats" "-hide_banner"
           "-loglevel" (if current-prefix-arg "warning" "quiet")
           ;; video input
           "-video_size" (gethash 'resolution monitor)
           "-framerate" "20"
           "-probesize" "30M"
           "-f" "x11grab"
           "-i" (concat ":0.0+" (gethash 'x monitor) "," (gethash 'y monitor))
           ;; audio imput
           "-f" "pulse" "-ac" "2" "-i" pcm-device
           ;; audio codec
           "-codec:a" "copy"
           ;; video codec
           "-codec:v" "libx264"
           ;; options
           "-crf" "0" "-preset" "ultrafast"
           "-threads" "4"
           (expand-file-name (concat
                              "Capture_"
                              (gethash 'resolution monitor)
                              (format-time-string "_%Y-%m-%d_%H.%M.%S.mkv"))
                             (if (file-directory-p "~/Videos/")
                                 "~/Videos/"
                               "~/"))))
    (if (eq 'run (process-status exwm-record-process))
        (message "EXWM Record process started")
      (message "EXWM Record process failed")))

  (defun exwm-record-toggle ()
    (interactive)
    (if exwm-record-process
        (if (eq 'run (process-status exwm-record-process))
            (exwm-record-stop)
          (call-interactively 'exwm-record-start))
      (call-interactively 'exwm-record-start)))

  (defun exwm-screensaver-lock ()
    (interactive)
    (when (not (setq exwm-screensaver-process
                     (car
                      (member "xscreensaver"
                              (mapcar
                               (lambda (item) (cdr (assoc 'comm item)))
                               (mapcar 'process-attributes (list-system-processes)))))))
      (setq exwm-screensaver-process
            (start-process " *xscreensaver" nil "xscreensaver" "-no-splash"))
      (sit-for 1))
    (start-process " *xscreensaver-command" nil "xscreensaver-command" "-lock"))

  (defun exwm-screensaver-interrupt ()
    (interactive)
    (when exwm-screensaver-process
      (interrupt-process exwm-screensaver-process)))

  (defun exwm-screenshot ()
    (interactive)
    (start-process " *screenshot" nil "gnome-screenshot"))

  (defun exwm-set-random-wallpaper (path &optional reason)
    (interactive (list (read-directory-name "Random image from: "
                                            exwm-default-wallpaper-folder)))
    (let* ((paths (directory-files path t "^[^.]"))
           (random-picture (nth (random (length paths)) paths)))
      (start-process " *feh" " *feh outputs*"
                     "feh" "--bg-fill" random-picture)
      (let ((inhibit-message t))
        (message "EXWM wallpaper%s: %s" (if reason
                                            (concat " (" reason ")")
                                          "")
                 (abbreviate-file-name random-picture)))
      (when (and
             nil ;; TODO
             (executable-find "dominant-color"))
        (set-process-sentinel
         (start-process "*dominant color*" " *dominant color*"
                        "dominant-color" random-picture)
         `(lambda (proc signal)
            (when (memq (process-status proc) '(exit signal))
              (with-current-buffer " *dominant color*"
                (let* ((pos (1- (point-max)))
                       (color (buffer-substring-no-properties
                               (progn
                                 (goto-char pos)
                                 (beginning-of-line)
                                 (point))
                               pos)))
                  (set-face-background 'default color)
                  (let ((inhibit-message t))
                    (message "Setted %s background color" color)))
                (erase-buffer))))))))

  (defun exwm-set-window-transparency (buffer &optional opacity)
    (interactive (list (current-buffer)
                       (read-number "Opacity: " exwm-default-transparency)))
    (let ((window-id (exwm--buffer->id buffer)))
      (if window-id
          (start-process " *transset" " *transset outputs*"
                         "transset" "--id"
                         (int-to-string window-id)
                         (int-to-string (or opacity exwm-default-transparency)))
        (message "Buffer %s without window." (buffer-name buffer)))))
  ;; (add-to-list 'xcb:ewmh:-atoms '_NET_WM_WINDOW_OPACITY)
  ;; (defvar xcb:Atom:_NET_WM_WINDOW_OPACITY nil)
  ;; (defun exwm-set-window-transparency (buffer &optional opacity)
  ;;   (interactive (list (current-buffer)
  ;;                      (read-number "Opacity: " exwm-default-transparency)))
  ;;   (let ((window-id (exwm--buffer->id buffer)))
  ;;     (if window-id
  ;;         (let* ((as-integer
  ;;                 (round (* 4294967295
  ;;                           (or opacity exwm-default-transparency))))
  ;;                (as-char-array
  ;;                 (cl-labels ((thunk (as-integer depth)
  ;;                                    (if (= depth 4)
  ;;                                        nil
  ;;                                      (cons (% as-integer 256)
  ;;                                            (thunk (/ as-integer 256)
  ;;                                                   (1+ depth))))))
  ;;                   (thunk as-integer 0))))
  ;;           (xcb:+request exwm--connection
  ;;               (make-instance xcb:ChangeProperty
  ;;                              :mode xcb:PropMode:Replace
  ;;                              :window window-id
  ;;                              :property xcb:Atom:_NET_WM_WINDOW_OPACITY
  ;;                              :type xcb:Atom:CARDINAL
  ;;                              :format 32 :data-len 1
  ;;                              :data as-char-array))
  ;;           (xcb:flush exwm--connection))
  ;;       (message "Buffer %s without window." (buffer-name buffer)))))

  (defun exwm-toggle-transparency ()
    (interactive)
    (if (= 1 exwm-default-transparency)
        (progn
          (setq exwm-default-transparency 0.85)
          (mapc (lambda (buffer)
                  (with-current-buffer buffer
                    (unless (member exwm-instance-name exwm-exclude-transparency)
                      (exwm-set-window-transparency
                       buffer
                       exwm-default-transparency))))
                (exwm-buffer-list)))
      (setq exwm-default-transparency 1)
      (mapc 'exwm-set-window-transparency (exwm-buffer-list))))

  (defun exwm-xrandr-parse ()
    (let ((monitors (make-hash-table :test 'equal)))
      (with-temp-buffer
        (call-process "xrandr" nil t nil)
        (goto-char (point-min))
        (while (re-search-forward "\n\\([^ ]+\\) connected " nil 'noerror)
          (let ((monitor (make-hash-table :test 'eq))
                (monitor-name (match-string 1)))
            (let ((primary (string-equal "primary" (thing-at-point 'word))))
              (puthash 'primary primary monitor)
              (when primary
                (forward-word)
                (forward-char)))
            (let* ((resolution-pos (thing-at-point 'sexp))
                   (values (split-string resolution-pos "+")))
              (puthash 'resolution (nth 0 values) monitor)
              (puthash 'x (nth 1 values) monitor)
              (puthash 'y (nth 2 values) monitor))
            (forward-line)
            (forward-word)
            (puthash 'max (thing-at-point 'sexp) monitor)
            (puthash monitor-name monitor monitors))))
      monitors))

  (defun exwm-get-default-monitor-resolution (monitor)
    (let ((pos (cl-position monitor exwm-default-monitor-resolution :test 'string-equal)))
      (if pos
          (nth (1+ pos) exwm-default-monitor-resolution))))

  (eval-and-compile
    (require 'crm))
  (defun exwm-update-screens ()
    (interactive)
    ;; when (null (member
    ;;              "arandr"
    ;;              (mapcar (lambda (pid)
    ;;                        (cdr (assq 'comm (process-get-attrs pid '(comm)))))
    ;;                      (list-system-processes))))
    (let* ((monitors (exwm-xrandr-parse))
           (names (hash-table-keys monitors)))
      (when (called-interactively-p 'interactive)
        (setq exwm-default-monitor-order
              (or (completing-read-multiple
                   (concat
                    "External monitor order (" crm-separator "): ")
                   names
                   nil t)
                  exwm-default-monitor-order)
              exwm-randr-workspace-monitor-plist nil))
      (when (null exwm-default-monitor-order)
        (setq exwm-default-monitor-order
              (list
               (cl-some (lambda (name)
                          (if (gethash 'primary (gethash name monitors))
                              name))
                        names))))
      (let ((names (cl-remove-if-not (lambda (name)
                                       (member name names))
                                     exwm-default-monitor-order)))
        (unless (equal (-slice exwm-randr-workspace-monitor-plist 1 nil 2) names)
          (let* ((posx 0)
                 (gety-lambda
                  (lambda (name)
                    (string-to-number
                     (nth 1 (split-string
                             (or
                              (exwm-get-default-monitor-resolution name)
                              (gethash 'max (gethash name monitors))) "x")))))
                 (ymax (apply 'max (mapcar gety-lambda names)))
                 (args
                  (apply
                   'nconc
                   (mapcar
                    (lambda (name)
                      (let* ((monitor (gethash name monitors))
                             (resolution
                              (or
                               (exwm-get-default-monitor-resolution name)
                               (gethash 'max monitor))))
                        (prog1
                            (list "--output" name
                                  "--mode" resolution
                                  "--pos" (concat (number-to-string posx)
                                                  "x"
                                                  (number-to-string
                                                   (- ymax (funcall gety-lambda name))))
                                  "--rotate" "normal")
                          (setq posx (+ posx
                                        (string-to-number
                                         (nth 0 (split-string
                                                 (or
                                                  (exwm-get-default-monitor-resolution name)
                                                  (gethash 'max monitor)) "x"))))))))
                    names))))
            (message "Calling: xrandr %s" (mapconcat 'identity args " "))
            (apply 'call-process "xrandr" nil nil nil args)
            (exwm-set-random-wallpaper exwm-default-wallpaper-folder "update")
            (when exwm-randr-workspace-monitor-plist
              (setq exwm-randr-workspace-monitor-plist nil))
            (let ((monitor-number -1))
              (mapc (lambda (name)
                      (setq exwm-randr-workspace-monitor-plist
                            (nconc exwm-randr-workspace-monitor-plist
                                   (list (cl-incf monitor-number) name))))
                    names)
              (setq exwm-workspace-number (1+ monitor-number))))))))

  (defun exwm-minibuffer-move-to-default-monitor (&optional workspace-or-screen)
    (interactive)
    (let ((minibuffer-pos
           (cl-some (lambda (frame)
                      (when (eq frame (window-frame (minibuffer-window frame)))
                        (exwm-workspace--position frame)))
                    exwm-workspace--list)))
      (if (null
           (and (numberp minibuffer-pos)
                (<= 0 minibuffer-pos)
                (< minibuffer-pos (length exwm-workspace--list))))
          (message "Frame with minibuffer not found.")
        (or workspace-or-screen
            (setq workspace-or-screen
                  exwm-default-minibuffer-workspace-or-screen))
        (cond
         ((and (numberp workspace-or-screen)
               (<= 0 workspace-or-screen)
               (< workspace-or-screen (length exwm-workspace--list)))
          (when (/= minibuffer-pos workspace-or-screen)
            (exwm-workspace-swap (exwm-workspace--workspace-from-frame-or-index
                                  minibuffer-pos)
                                 (exwm-workspace--workspace-from-frame-or-index
                                  workspace-or-screen))))
         ((and (stringp workspace-or-screen)
               (setq workspace-or-screen
                     (cl-position workspace-or-screen
                                  exwm-randr-workspace-monitor-plist
                                  :test 'equal)))
          (setq workspace-or-screen
                (nth (1- workspace-or-screen)
                     exwm-randr-workspace-monitor-plist))
          (when (/= minibuffer-pos workspace-or-screen)
            (exwm-workspace-swap (exwm-workspace--workspace-from-frame-or-index
                                  minibuffer-pos)
                                 (exwm-workspace--workspace-from-frame-or-index
                                  workspace-or-screen))))))))
  (add-hook 'exwm-init-hook 'exwm-minibuffer-move-to-default-monitor 91)

  (defun exwm-screen-count ()
    (let ((monitor-number 0))
      (with-temp-buffer
        (call-process "xrandr" nil t nil)
        (goto-char (point-min))
        (while (re-search-forward "\n\\([^ ]+\\) connected " nil 'noerror)
          (cl-incf monitor-number)
          (forward-line)))
      monitor-number))

  (defun exwm-make-frame (&optional parameters)
    (interactive)
    (plist-put exwm-randr-workspace-monitor-plist
               (exwm-workspace--count)
               (plist-get exwm-randr-workspace-monitor-plist
                          exwm-workspace-current-index))
    (make-frame parameters))

  (defun exwm-delete-frame (&optional frame force)
    (interactive)
    (when-let ((pos (cl-position (if frame
                                     (with-selected-frame frame
                                       exwm-workspace-current-index)
                                   exwm-workspace-current-index)
                                 exwm-randr-workspace-monitor-plist)))
      (setq exwm-randr-workspace-monitor-plist
            (nconc (cl-subseq exwm-randr-workspace-monitor-plist 0 pos)
                   (mapcar
                    (lambda (x) (if (numberp x) (1- x) x))
                    (nthcdr (+ 2 pos) exwm-randr-workspace-monitor-plist)))))
    (delete-frame frame force))

  (defun exwm-randr-workspace-current-list ()
    (let ((current (plist-get exwm-randr-workspace-monitor-plist
                              exwm-workspace-current-index))
          last-idx indexes)
      (mapc (lambda (elt)
              (when (equal elt current)
                (push last-idx indexes))
              (setq last-idx elt))
            exwm-randr-workspace-monitor-plist)
      indexes))

  (defun exwm-randr-workspace-next ()
    (interactive)
    (when-let* ((workspaces (exwm-randr-workspace-current-list))
                (pos (cl-position exwm-workspace-current-index workspaces)))
      (let ((workspace (or (nth (1+ pos) workspaces)
                           (car workspaces))))
        (when (/= workspace exwm-workspace-current-index)
          (exwm-workspace-switch workspace)))))

  (defun exwm-randr-workspace-prev ()
    (interactive)
    (when-let* ((workspaces (exwm-randr-workspace-current-list))
                (pos (cl-position exwm-workspace-current-index workspaces)))
      (let ((workspace (if (= pos 0)
                           (car (last workspaces))
                         (nth (1- pos) workspaces))))
        (when (/= workspace exwm-workspace-current-index)
          (exwm-workspace-switch workspace)))))

  (defun exwm-workspace-index-plus (arg)
    (let* ((workspace-count (exwm-workspace--count))
           (remainer (% (+ arg exwm-workspace-current-index) workspace-count)))
      (if (< remainer 0)
          (+ remainer workspace-count)
        remainer)))

  (defun exwm-workspace-next (arg)
    (interactive "p")
    (exwm-workspace-switch (exwm-workspace-index-plus arg)))

  (defun exwm-workspace-prev (arg)
    (interactive "p")
    (exwm-workspace-switch (exwm-workspace-index-plus (- arg))))

  (defun exwm-randr-workspace-move (workspace monitor)
    (setq exwm-randr-workspace-monitor-plist
          (plist-put exwm-randr-workspace-monitor-plist workspace monitor)))

  (defun exwm-randr-workspace-move-current (monitor)
    (interactive (list (let* ((result (if exwm-randr--compatibility-mode
                                          (exwm-randr--get-outputs)
                                        (exwm-randr--get-monitors)))
                              (primary-monitor (elt result 0))
                              (monitor-list (mapcar 'car (elt result 2))))
                         (completing-read "Move to monitor: "
                                          monitor-list nil t nil nil primary-monitor))))
    (exwm-randr-workspace-move exwm-workspace-current-index monitor)
    (exwm-randr-refresh))

  (defun exwm-buffer-p (buffer-or-name)
    (with-current-buffer buffer-or-name
      (derived-mode-p 'exwm-mode)))

  (defun exwm-buffer-list ()
    (cl-remove-if-not 'exwm-buffer-p (buffer-list)))

  (defun exwm-display-buffer-condition (buffer-name action)
    (and (exwm-buffer-p buffer-name)
         (let ((buf (current-buffer)))
           (and (null (eq buf (get-buffer buffer-name)))
                (exwm-buffer-p buf)))))

  (defun exwm-display-buffer-biggest (buffer alist)
    (let ((avaible-window-list
           (cl-remove-if
            #'window-dedicated-p
            (delete
             (selected-window)
             (apply #'append (mapcar #'window-list (visible-frame-list)))))))
      (if avaible-window-list
          (if (< 1 (length avaible-window-list))
              (let* ((window-width-list (mapcar (lambda (w)
                                                  (+ (* (window-width w) 10) (window-height w)))
                                                avaible-window-list))
                     (window (nth (cl-position
                                   (seq-max window-width-list)
                                   window-width-list) avaible-window-list)))
                (select-frame (window-frame window))
                (set-window-buffer window buffer))
            (select-frame (window-frame (car avaible-window-list)))
            (set-window-buffer (car avaible-window-list) buffer))
        (display-buffer-pop-up-window buffer alist))))

  (defun exwm-display-buffer-tiling-anticlockwise (buffer alist)
    (rotate-frame-anticlockwise)
    (display-buffer-in-direction buffer (cons '(direction . leftmost) alist))
    (with-current-buffer buffer
      (set (make-local-variable 'exwm-close-window-on-kill)
           (get-buffer-window buffer))))

  (defun exwm-display-buffer-cycle (&optional arg)
    (interactive "P")
    (let ((funcs '(exwm-display-buffer-biggest
                   exwm-display-buffer-tiling-anticlockwise
                   ;; display-buffer-pop-up-window
                   ;; display-buffer-at-bottom
                   ;; display-buffer-below-selected
                   ;; display-buffer-in-side-window
                   ;; display-buffer-in-direction
                   ;; display-buffer-same-window
                   )))
      (when arg
        (setq funcs (nreverse funcs)))
      (let* ((display-funcs (cdr (assoc 'exwm-display-buffer-condition
                                        display-buffer-alist)))
             (func (car display-funcs)))
        (if (null func)
            (message "`display-buffer-alist' without EXWM case.")
          (let ((new-func (or (car (cdr (memq func funcs)))
                              (car funcs))))
            (setcar display-funcs new-func)
            (message "EXWM display function: `%s'" new-func))))))

  (defun exwm-windows-processes ()
    (cl-remove-if-not (lambda (p)
                        (and (eq 'run (process-status p))
                             (process-tty-name p)
                             (null (process-buffer p))))
                      (process-list)))

  (defun exwm-kill-emacs-query-function ()
    (mapc (lambda (p)
            (let ((sigcgt (string-to-number
                           (substring
                            (string-trim-right
                             (shell-command-to-string
                              (concat "cat /proc/"
                                      (number-to-string (process-id p))
                                      "/status | grep SigCgt | cut -f2")))
                            -1)
                           16)))
              (cond ((= 1 (mod sigcgt 2))
                     (message "Sending `sighup' to `%s' with cgt %i"
                              (process-name p) sigcgt)
                     (signal-process p 'sighup))
                    ((= 1 (mod (/ sigcgt 2) 2))
                     (message "Sending `sigint' to `%s' with cgt %i"
                              (process-name p) sigcgt)
                     (interrupt-process p))
                    (t
                     (message "Sending `sigkill' to `%s' with cgt %i"
                              (process-name p) sigcgt)
                     (kill-process p)))))
          (exwm-windows-processes))
    (let ((times 30)
          last-procs)
      (while (and (<= 0 (cl-decf times))
                  (let ((procs (exwm-windows-processes)))
                    (unless (equal last-procs procs)
                      (setq last-procs procs)
                      (message "Waiting processes: %s"
                               (mapconcat #'process-name procs ", ")))
                    procs))
        (sit-for 0.1))
      (if last-procs
          (progn
            (message "Interrupting processes failed.")
            nil)
        (message "All processes closed.")
        t)))

  (defun exwm-start-process (command)
    (interactive (list (read-shell-command "> ")))
    (cond ((string-match-p "\\\\ " command)
           (start-process-shell-command command nil command))
          ((string-match-p "\"" command)
           (let ((split (split-string-and-unquote command)))
             (apply #'start-process (car split) nil (pop split) split)))
          (t
           (let ((split (split-string command)))
             (apply #'start-process (car split) nil (pop split) split)))))

  (defun exwm-start-terminal (arg)
    (interactive "P")
    (if arg
        (cond ((executable-find "tmux")
               (cond ((executable-find "st")
                      (message "Starting st with tmux")
                      (start-process "st" nil "st" "-e" "tmux"))
                     ((executable-find "urxvt")
                      (message "Starting urxvt with tmux")
                      (start-process "urxvt" nil "urxvt" "-e" "tmux"))))
              ((executable-find "screen")
               (cond ((executable-find "st")
                      (message "Starting st with screen")
                      (start-process "st" nil "st" "-e" "screen"))
                     ((executable-find "urxvt")
                      (message "Starting urxvt with screen")
                      (start-process "urxvt" nil "urxvt" "-e" "screen"))))
              (t (message "Terminal multiplexer not found")))
      (cond ((executable-find "alacritty")
             (message "Starting alacritty")
             (start-process "alacritty" nil "alacritty"))
            ((executable-find "urxvt")
             (message "Starting urxvt")
             (start-process "urxvt" nil "urxvt"))
            ((executable-find "xterm")
             (message "Starting xterm")
             (start-process "xterm" nil "xterm"))
            ((executable-find "st")
             (message "Starting st")
             (start-process "st" nil "st")))))

  (defun exwm-start-emacs (filepath)
    (interactive (list (buffer-file-name)))
    (cond ((or current-prefix-arg
               (null filepath))
           (start-process "emacs" nil "emacs"))
          ((and (stringp filepath)
                (file-exists-p filepath))
           (start-process "emacs" nil
                          "emacs" (concat
                                   "+" (number-to-string (line-number-at-pos))
                                   ":" (number-to-string (1+ (current-column))))
                          filepath))
          (t
           (message "File not found: %s" filepath))))

  (defun exwm-ace-window-dwim (arg)
    (interactive "p")
    (if (and (derived-mode-p 'exwm-mode)
             (eq exwm--input-mode 'char-mode))
        (if (equal exwm-class-name "Emacs")
            (exwm-input--fake-key last-input-event)
          (let ((id (exwm--buffer->id (window-buffer))))
            (exwm-input-grab-keyboard id)
            (unwind-protect
                (ace-window arg)
              (exwm-input-release-keyboard id))))
      (ace-window arg)))

  (defun exwm-ace-window (arg)
    (interactive "p")
    (if (and (derived-mode-p 'exwm-mode)
             (eq exwm--input-mode 'char-mode))
        (let ((id (exwm--buffer->id (window-buffer))))
          (exwm-input-grab-keyboard id)
          (unwind-protect
              (ace-window arg)
            (exwm-input-release-keyboard id)))
      (ace-window arg)))

  (defun exwm-M-x ()
    (interactive)
    (if (and (derived-mode-p 'exwm-mode)
             (eq exwm--input-mode 'char-mode))
        (let ((id (exwm--buffer->id (window-buffer))))
          (exwm-input-grab-keyboard id)
          (unwind-protect
              (call-interactively 'execute-extended-command)
            (exwm-input-release-keyboard id)))
      (call-interactively 'execute-extended-command)))

  (defvar exwm-ctrl-space nil)
  (defun exwm-ctrl-space (arg)
    (interactive "P")
    (if (derived-mode-p 'exwm-mode)
        (progn
          (if exwm-ctrl-space
              (progn
                (call-process "xdotool" nil nil nil
                              "keyup"
                              "Shift_L")
                (message "EXWM Mark deactivated"))
            (call-process "xdotool" nil nil nil
                          "keydown"
                          "--clearmodifiers"
                          "Shift_L")
            (message "EXWM Mark set"))
          (setq exwm-ctrl-space (null exwm-ctrl-space)))
      (setq this-command 'set-mark-command)
      (set-mark-command arg)))

  (defun exwm-shutdown (&optional arg)
    (interactive "P")
    (let ((shutdown
           (lambda ()
             (call-process "systemctl" nil nil nil "poweroff"))))
      (add-hook 'kill-emacs-hook shutdown t)
      (unwind-protect
          (save-buffers-kill-terminal-with-choice arg)
        (remove-hook 'kill-emacs-hook shutdown))))

  (defun exwm-close-window-if-exwm-mode ()
    (when (and (derived-mode-p 'exwm-mode)
               (< 1 (length (window-list)))
               exwm-close-window-on-kill)
      (if (null (eq exwm-close-window-on-kill (get-buffer-window (current-buffer))))
          (delete-window)
        (delete-window)
        (when (eq (car (cdr (assoc 'exwm-display-buffer-condition
                                   display-buffer-alist)))
                  'exwm-display-buffer-tiling-anticlockwise)
          (rotate-frame-clockwise)))))

  (defun exwm-display-input-mode ()
    (interactive)
    (cl-case exwm--input-mode
      (line-mode
       ;; (let (message-log-max)
       ;;   (message "EXWM %s window in line-mode" (buffer-name)))
       (exwm-set-border-color "dark blue")
       )
      (char-mode
       ;; (let (message-log-max)
       ;;   (message "EXWM %s window in char-mode" (buffer-name)))
       (exwm-set-border-color "magenta")
       )))

  (defun exwm-selected-window-advice (&rest _args)
    (when (derived-mode-p 'exwm-mode)
      (exwm-display-input-mode)
      ;; (set-face-attribute 'window-divider (selected-frame) :foreground "red")
      ))
  (advice-add 'select-frame :after 'exwm-selected-window-advice)
  (advice-add 'select-window :after 'exwm-selected-window-advice)

  (defun exwm-unselected-window-advice (&rest _args)
    (when (derived-mode-p 'exwm-mode)
      (exwm-set-border-color "black")
      ;; (set-face-attribute 'window-divider (selected-frame) :foreground "white")
      (when exwm-ctrl-space
        (call-process "xdotool" nil nil nil
                      "keyup"
                      "Shift_L")
        (setq exwm-ctrl-space nil))))
  (advice-add 'select-frame :before 'exwm-unselected-window-advice)
  (advice-add 'select-window :before 'exwm-unselected-window-advice)

  ;; ;;;;;;; ;;
  ;; Layouts ;;
  ;; ;;;;;;; ;;



  ;; ;;;;;;;;;;;;;; ;;
  ;; Customizations ;;
  ;; ;;;;;;;;;;;;;; ;;
  (add-hook 'exwm-input-input-mode-change-hook
            'exwm-display-input-mode)

  ;; display buffer rules
  (push '(exwm-display-buffer-condition
          ;; exwm-display-buffer-biggest
          exwm-display-buffer-tiling-anticlockwise)
        display-buffer-alist)

  (add-hook 'kill-buffer-hook 'exwm-close-window-if-exwm-mode)

  ;; Turn on `display-time-mode' if you don't use an external bar.
  (setq display-time-default-load-average nil
        display-time-day-and-date t
        display-time-24hr-format t
        display-time-mail-string "✉")

  ;; You are strongly encouraged to enable something like `ido-mode' to alter
  ;; the default behavior of 'C-x b', or you will take great pains to switch
  ;; to or back from a floating frame (remember 'C-x 5 o' if you refuse this
  ;; proposal however).
  ;; You may also want to call `exwm-config-ido' later (see below).
  ;; (ido-mode 1)

  ;; Emacs server is not required to run EXWM but it has some interesting uses
  ;; (see next section).
  (server-start)
  (push 'exwm-kill-emacs-query-function kill-emacs-query-functions)

  ;; (require 'mini-modeline)                     ;; + with mini-modeline
  ;; (setq mini-modeline-frame (selected-frame))  ;; + with mini-modeline

  ;; Set the initial number of workspaces (they can also be created later).
  (setq exwm-workspace-number (exwm-screen-count)
        exwm-workspace-minibuffer-position nil
        exwm-workspace-show-all-buffers t
        exwm-layout-show-all-buffers t)

  ;; All buffers created in EXWM mode are named "*EXWM*". You may want to
  ;; change it in `exwm-update-class-hook' and `exwm-update-title-hook', which
  ;; are run when a new X window class name or title is available.  Here's
  ;; some advice on this topic:
  ;; + Always use `exwm-workspace-rename-buffer` to avoid naming conflict.
  ;; + For applications with multiple windows (e.g. GIMP), the class names of
                                        ;    all windows are probably the same.  Using window titles for them makes
  ;;   more sense.
  ;; In the following example, we use class names for all windows expect for
  ;; Java applications and GIMP.
  (defun exwm-update-class-defaults ()
    (unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                (string-equal "gimp" exwm-instance-name))
      (exwm-workspace-rename-buffer exwm-class-name))
    (unless (member exwm-instance-name exwm-exclude-transparency)
      (exwm-set-window-transparency (current-buffer) exwm-default-transparency)))
  (add-hook 'exwm-update-class-hook 'exwm-update-class-defaults)

  (defun exwm-update-title-defaults ()
    (exwm-workspace-rename-buffer
     (concat exwm-class-name ": " exwm-title)))
  (add-hook 'exwm-update-title-hook 'exwm-update-title-defaults)

  (defun exwm-workspace-switch-with-titles ()
    (interactive)
    (let* ((titles (seq-map-indexed
                    (lambda (frame idx)
                      (concat
                       (number-to-string idx) " - "
                       (mapconcat 'buffer-name
                                  (mapcar 'window-buffer (window-list frame))
                                  (propertize " & " 'face '(:foreground "sky blue")))))
                    exwm-workspace--list))
           (candidate
            (completing-read "Select frame: " titles nil t)))
      (exwm-workspace-switch (cl-position candidate titles :test 'string-equal))))

  (global-set-key (kbd "<XF86PowerOff>") 'exwm-shutdown)
  ;; ace-window
  (define-key exwm-mode-map (kbd "M-o") 'exwm-ace-window-dwim)
  ;; C-SPC trick
  (define-key exwm-mode-map (kbd "C-SPC") 'exwm-ctrl-space)
  (define-key exwm-mode-map (kbd "C-S-SPC") 'exwm-ctrl-space)
  (with-eval-after-load 'exwm-input
    ;; line-mode prefix keys
    (push ?\M-o exwm-input-prefix-keys)
    (push ?\C-\  exwm-input-prefix-keys)
    (push ?\C-\S-\  exwm-input-prefix-keys)
    (cl-pushnew 'XF86PowerOff exwm-input-prefix-keys)

    ;; Global keybindings can be defined with `exwm-input-global-keys'.
    ;; Here are a few examples:
    (setq exwm-input-global-keys
          `(;; Universal argument
            ([?\s-u] . universal-argument)
            ;; Bind "s-r" to exit char-mode and fullscreen mode.
            ([?\s-r] . exwm-reset)
            ;; Bind "s-w" to switch workspace interactively.
            ([?\s-w] . exwm-workspace-switch-with-titles)
            ;; Bind "s-1" to "s-0" to switch to a workspace by its index.
            ([?\s-0] . (lambda ()
                         (interactive)
                         (exwm-workspace-switch 9)))
            ,@(mapcar (lambda (i)
                        `(,(kbd (format "s-%d" (1+ i))) .
                          (lambda ()
                            (interactive)
                            (exwm-workspace-switch ,i))))
                      (number-sequence 0 8))
            (,(kbd "S-s-0") . (lambda ()
                                (interactive)
                                (exwm-workspace-switch-create 9)))
            ,@(mapcar (lambda (i)
                        `(,(kbd (format "S-s-%d" (1+ i))) .
                          (lambda ()
                            (interactive)
                            (exwm-workspace-switch-create ,i))))
                      (number-sequence 0 8))
            ;; Bind "s-&" to launch applications ('M-&' also works if the output
            ;; buffer does not bother you).
            ([?\s-&] . exwm-start-process)
            ;; New terminal
            ([s-return] . exwm-start-terminal)
            ([s-S-return] . exwm-start-emacs)
            ;; Bind "s-<f2>" to "slock", a simple X display locker.
            ([s-f2] . (lambda ()
                        (interactive)
                        (start-process "" nil "/usr/bin/slock")))
            ;; Toggle char-line modes
            ([?\s-q] . exwm-input-toggle-keyboard)
            ([?\s-Q] . exwm-display-input-mode)
            ;; Display datetime
            ([?\s-a] . display-time-mode)
            ;; Workspaces
            ([?\s-D] . exwm-delete-frame)
            ([?\s-I] . exwm-make-frame)
            ([?\s-n] . exwm-randr-workspace-next)
            ([?\s-p] . exwm-randr-workspace-prev)
            ([?\s-N] . exwm-workspace-next)
            ([?\s-P] . exwm-workspace-prev)
            ([?\s-S] . exwm-workspace-swap)
            ([?\s-M] . exwm-randr-workspace-move-current)
            ;; windows
            ([?\s-f] . exwm-layout-toggle-fullscreen)
            ([?\s-s ?6] . exwm-display-buffer-cycle)
            ([?\s-s ?7 ?7] . frame-transparency)
            ([?\s-s ?7 ?g] . exwm-gap-toggle)
            ([?\s-s ?7 ?T] . exwm-toggle-transparency)
            ([?\s-s ?7 ?t] . toggle-transparency)
            ([?\s-s ?7 ?m] . exwm-layout-toggle-mode-line)
            ([?\s-s ?7 ?f] . exwm-floating-toggle-floating)
            ;; Switch to minibuffer window
            ([?\s-s ?0] . switch-to-minibuffer-window)
            ;; switch buffer
            ([?\s-b] . switch-to-buffer)
            ;; ace-window
            ([?\s-o] . exwm-ace-window)
            ;; Bind lock screen
            (,(kbd "<s-escape>") . exwm-screensaver-lock)
            (,(kbd "<C-s-escape>") . exwm-screensaver-interrupt)
            ;; Screenshot
            (,(kbd "<s-print>") . exwm-screenshot)
            ;; Record audio and video
            (,(kbd "<S-s-print>") . exwm-record-toggle)
            ;; Execute command menu
            ([?\s-x] . exwm-M-x)
            ;; shutdown computer
            (,(kbd "<s-end>") . exwm-shutdown))))

  (with-eval-after-load 'exwm-manage
    (setq exwm-manage-configurations
          '(((member exwm-class-name
                     exwm-char-mode-classes)
             char-mode t
             tiling-mode-line nil
             floating-mode-line nil)
            ((member exwm-class-name
                     '("darkplaces" "doom" "gzdoom"))
             floating nil
             tiling-mode-line nil
             floating-mode-line nil)
            (t tiling-mode-line nil
               floating-mode-line nil)))

    (defun exwm-manage-set-border ()
      (exwm-set-border-width 1))
    (add-hook 'exwm-manage-finish-hook 'exwm-manage-set-border))

  ;; To add a key binding only available in line-mode, simply define it in
  ;; `exwm-mode-map'.  The following example shortens 'C-c q' to 'C-q'.
  (define-key exwm-mode-map [?\C-q] #'exwm-input-send-next-key)

  ;; The following example demonstrates how to use simulation keys to mimic
  ;; the behavior of Emacs.  The value of `exwm-input-simulation-keys` is a
  ;; list of cons cells (SRC . DEST), where SRC is the key sequence you press
  ;; and DEST is what EXWM actually sends to application.  Note that both SRC
  ;; and DEST should be key sequences (vector or string).
  (setq exwm-input-simulation-keys
        `(;; movement
          ([?\C-b] . [left])
          ([?\M-b] . [C-left])
          ([?\C-f] . [right])
          ([?\M-f] . [C-right])
          ([?\C-p] . [up])
          ([?\C-n] . [down])
          (,(kbd "C-a") . [home])
          ([?\M-<] . [C-home])
          ([?\C-e] . [end])
          ([?\M->] . [C-end])
          ([?\M-v] . [prior])
          ([?\C-v] . [next])
          ;; shift movement
          (,(kbd "C-S-b") . [S-left])
          (,(kbd "M-S-b") . [C-S-left])
          (,(kbd "C-S-f") . [S-right])
          (,(kbd "M-S-f") . [C-S-right])
          (,(kbd "C-S-p") . [S-up])
          (,(kbd "C-S-n") . [S-down])
          (,(kbd "C-S-a") . [S-home])
          (,(kbd "M-S-<") . [C-S-home])
          (,(kbd "C-S-e") . [S-end])
          (,(kbd "M-S->") . [C-S-end])
          (,(kbd "M-S-v") . [S-prior])
          (,(kbd "C-S-v") . [S-next])
          ;; edition
          ([?\C-d] . [delete])
          ([?\M-d] . [C-delete])
          ([?\C-k] . [S-end delete])
          ([?\C-u] . [S-home delete])
          (,(kbd "<C-S-backspace>") . [home S-end delete])
          ;; jumps
          (,(kbd "M-g M-g") . [?\C-g])
          (,(kbd "M-g M-n") . ,(kbd "<f8>"))
          (,(kbd "M-g M-p") . ,(kbd "<S-f8>"))
          (,(kbd "M-.") . ,(kbd "<C-f12>"))
          (,(kbd "C-,") . ,(kbd "C-S--"))
          (,(kbd "C-.") . ,(kbd "C-M--"))
          (,(kbd "C-x C-SPC") . ,(kbd "C-M--"))
          ;; comments
          (,(kbd "M-;") . ,(kbd "M-S-a"))
          ;; select
          ([?\C-x ?h] . [?\C-a])
          ;; cut/paste
          ([?\C-w] . [?\C-x])
          ([?\M-w] . [?\C-c])
          ([?\C-y] . [?\C-v])
          ;; shift cut/paste
          (,(kbd "C-S-w") . [?\C-x])
          (,(kbd "M-W") . [?\C-c])
          (,(kbd "C-S-y") . [?\C-v])
          ;; search
          ([?\C-s] . [?\C-f])
          ;; files
          ([?\C-x ?\C-s] . [?\C-s])
          ;; undo redo
          (,(kbd "C-_") . [?\C-z])
          (,(kbd "M-_") . [?\C-y])
          ;; format
          (,(kbd "M-SPC") . ,(kbd "C-S-i"))
          ;; tabs
          (,(kbd "C-x t 0") . [?\C-w])
          (,(kbd "C-x t 2") . [?\C-t])
          ;; escape keys
          (,(kbd "C-c C-d") . [?\C-d])
          (,(kbd "C-c C-e") . [?\C-e])))

  ;; You can hide the minibuffer and echo area when they're not used, by
  ;; uncommenting the following line.
                                        ;(setq exwm-workspace-minibuffer-position 'bottom)

  ;; Do not forget to enable EXWM. It will start by itself when things are
  ;; ready.  You can put it _anywhere_ in your configuration.
  ;; (exwm-enable)

  ;; Multi-monitor
  (add-hook 'exwm-randr-screen-change-hook 'exwm-update-screens)
  (exwm-randr-enable)

  ;; System tray
  (require 'exwm-systemtray)
  (exwm-systemtray-enable)

  ;; Background
  (defvar exwm-timer-random-wallpaper nil
    "Random wallpaper timer")

  (defun exwm-start-random-wallpaper ()
    (interactive)
    (if exwm-timer-random-wallpaper
        (message "Exists previous random wallpaper timer")
      (setq exwm-timer-random-wallpaper
            (run-at-time 600 600
                         'exwm-set-random-wallpaper
                         exwm-default-wallpaper-folder
                         "timer"))))
  (exwm-start-random-wallpaper)

  (defun exwm-cancel-random-wallpaper ()
    (interactive)
    (if (null exwm-timer-random-wallpaper)
        (message "Nil random wallpaper timer")
      (cancel-timer exwm-timer-random-wallpaper)
      (setq exwm-timer-random-wallpaper nil)))

  ;; Applications
  ;; (add-hook 'exwm-init-hook
  ;;           (lambda ()
  ;;             (dolist (program-and-args-list '(("compton")
  ;;                                              ("volumeicon")
  ;;                                              ("nm-applet")))
  ;;               (let ((executable (car program-and-args-list)))
  ;;                 (if (executable-find executable)
  ;;                     (apply 'start-process
  ;;                            (concat " *" executable)
  ;;                            (concat " *" executable " outputs*")
  ;;                            program-and-args-list)
  ;;                   (message "Unable to find `%s' executable." executable)))))
  ;;           92)

  (when (load "helm-exwm" t t)
    (setq helm-exwm-emacs-buffers-source (helm-exwm-build-emacs-buffers-source)
          helm-exwm-source (helm-exwm-build-source)
          helm-mini-default-sources `(helm-exwm-emacs-buffers-source
                                      helm-exwm-source
                                      helm-source-recentf)))

  (with-eval-after-load 'helm-posframe
    (defvar exwm-helm-posframe-display-buffer nil)
    (defun helm-posframe-display-advice (&rest _args)
      (let ((buffer (current-buffer)))
        (when (exwm-buffer-p buffer)
          (exwm-set-window-transparency buffer 0.2)
          (setq exwm-helm-posframe-display-buffer buffer))))
    (advice-add 'helm-posframe-display :before 'helm-posframe-display-advice)

    (defun helm-posframe-cleanup-advice (&rest _args)
      (when exwm-helm-posframe-display-buffer
        (with-current-buffer exwm-helm-posframe-display-buffer
          (exwm-set-window-transparency
           exwm-helm-posframe-display-buffer
           (if (member exwm-instance-name exwm-exclude-transparency)
               1 exwm-default-transparency)))
        (setq exwm-helm-posframe-display-buffer nil)))
    (advice-add 'helm-posframe-cleanup :after 'helm-posframe-cleanup-advice))

  (with-eval-after-load 'winum
    (defun exwm-winum-bindings ()
      (if winum-mode
          (winum--define-keys exwm-mode-map)
        (winum--undefine-keys exwm-mode-map)))
    (exwm-winum-bindings)
    (add-hook 'winum-mode-hook 'exwm-winum-bindings))

  (with-eval-after-load 'ace-window
    (defun aw-select-advice (orig-fun &rest args)
      (let ((exwm-buffer-list (exwm-buffer-list)))
        (mapc (lambda (buffer)
                (exwm-set-window-transparency buffer 0.2))
              exwm-buffer-list)
        (unwind-protect
            (apply orig-fun args)
          (mapc (lambda (buffer)
                  (exwm-set-window-transparency buffer exwm-default-transparency))
                exwm-buffer-list))))
    (advice-add 'aw-select :around 'aw-select-advice))

  ;; gaps
  ;; (let ((color (face-attribute 'default :background)))
  ;;   (set-face-attribute 'window-divider nil :foreground color)
  ;;   (set-face-attribute 'window-divider-first-pixel nil :foreground "#353024")
  ;;   (set-face-attribute 'window-divider-last-pixel nil :foreground "#353024"))
  ;; (window-divider-mode)


  ;; minibuffer
  (when (load "mini-frame" t t)
    (setq mini-frame-show-parameters
          (if (featurep 'helm)
              '((left . -1) (top . -1) (width . 0.75) (height . 1) (alpha . 75)
                (border-width . 0) (internal-border-width . 0)
                (background-color . "black"))
            (setq mini-frame-completions-show-parameters
                  (defun mini-frame-completions-show-parameters-dwim ()
                    (let ((workarea (nth exwm-workspace-current-index
                                         exwm-workspace--workareas)))
                      `((parent-frame . nil)
                        (z-group . above)
                        (left . ,(+ (aref workarea 0) 20))
                        ;; (height . ,(cons 'text-pixels (round (* (aref workarea 3) 0.3))))
                        (height . ,(round (* (aref workarea 3) (default-font-height) 0.001)))
                        ;; [ in this fuction 'text-pixels then white mini frame
                        (width . ,(round (* (aref workarea 2) (default-font-width) 0.0186)))
                        ;; (width . ,(cons 'text-pixels (- (aref workarea 2) 60)))
                        ;; ]
                        (background-color . "black")))))
            (defun mini-frame-show-parameters-dwim ()
              (let* ((workarea (nth exwm-workspace-current-index
                                    exwm-workspace--workareas))
                     (workarea-width (aref workarea 2)))
                `((parent-frame . nil)
                  (z-group . above)
                  (top . ,(+ (aref workarea 1) 10))
                  (left . ,(round (+ (aref workarea 0) (* workarea-width 0.05))))
                  (height . 1)
                  (width . ,(round (* workarea-width (default-font-width) 0.018)))
                  ;; (width . ,(cons 'text-pixels (round (* workarea-width 0.9))))
                  (background-color . "black")))))
          mini-frame-resize t  ;; nil when icomplete-exhibit advice
          ;; fix not resizing mini frame on gnome
          ;; x-gtk-resize-child-frames 'resize-mode
          resize-mini-frames t
          mini-frame-ignore-commands '(debugger-eval-expression
                                       objed-ipipe
                                       "edebug-eval-expression"
                                       ;; "exwm-workspace-"
                                       )
          mini-frame-standalone t)

    (defun mini-frame--resize-mini-frame (frame)
      (when (and (eq mini-frame-frame frame)
                 (frame-live-p mini-frame-frame))
        (modify-frame-parameters
         mini-frame-frame
         `((height
            .
            ,(min
              40
              (count-visual-lines-in-string
               (concat
                (minibuffer-prompt)
                (with-selected-window (minibuffer-window mini-frame-frame)
                  (minibuffer-contents-no-properties))
                (when (and icomplete-mode
                           (icomplete-simple-completing-p))
                  (overlay-get icomplete-overlay 'after-string)))
               (frame-width mini-frame-frame))))))
        (when (and (frame-live-p mini-frame-completions-frame)
                   (frame-visible-p mini-frame-completions-frame))
          (modify-frame-parameters
           mini-frame-completions-frame
           `((top
              .
              ,(+ (* 2 (frame-parameter mini-frame-frame 'internal-border-width))
                  (frame-parameter mini-frame-frame 'top)
                  (cdr (window-text-pixel-size
                        (frame-selected-window mini-frame-frame))))))))))

    (add-hook 'exwm-init-hook 'mini-frame-mode 91)
    (add-hook last-startup-hook 'symon-mode 91)

    ;; [ fix not resizing mini frame
    ;; (defun mini-frame-icomplete-exhibit-advice ()
    ;;   (when (and (bound-and-true-p mini-frame-frame)
    ;;              (frame-live-p mini-frame-frame)
    ;;              (frame-visible-p mini-frame-frame))
    ;;     (modify-frame-parameters
    ;;      mini-frame-frame
    ;;      `((height . ,(count-visual-lines-in-string
    ;;                    (concat
    ;;                     (buffer-substring-no-properties (point-min) (point-max))
    ;;                     (overlay-get icomplete-overlay 'after-string))
    ;;                    (frame-width mini-frame-frame)))))
    ;;     (when (and (frame-live-p mini-frame-completions-frame)
    ;;                (frame-visible-p mini-frame-completions-frame))
    ;;       (modify-frame-parameters
    ;;        mini-frame-completions-frame
    ;;        `((top
    ;;           .
    ;;           ,(+ (* 2 (frame-parameter mini-frame-frame 'internal-border-width))
    ;;               (frame-parameter mini-frame-frame 'top)
    ;;               (cdr (window-text-pixel-size
    ;;                     (frame-selected-window mini-frame-frame))))))))))
    ;; (advice-add 'icomplete-exhibit :after 'mini-frame-icomplete-exhibit-advice)

    ;; (defun mini-frame-toggle-resize ()
    ;;   (interactive)
    ;;   (if (setq mini-frame-resize (null mini-frame-resize))
    ;;       (advice-remove 'icomplete-exhibit 'mini-frame-icomplete-exhibit-advice)
    ;;     (advice-add 'icomplete-exhibit :after 'mini-frame-icomplete-exhibit-advice))
    ;;   (message "Custom mini frame resize: %s" (nu mini-frame-resize)))
    ;; (global-set-key (kbd "M-s 7 0") 'mini-frame-toggle-resize)
    ;; ]


    ;; only one minibuffer
    (defun common-minibuffer-all-frames ()
      (let ((frame (car (minibuffer-frame-list))))
        (setf (alist-get 'minibuffer default-frame-alist)
              (if frame nil t))))
    (add-hook 'before-make-frame-hook 'common-minibuffer-all-frames))


  ;; systemtray hold
  (defun exwm-systemtray--on-workspace-switch-advice (orig-fun &rest args)
    (if (eq exwm-workspace--current (window-frame (minibuffer-window)))
        (apply orig-fun args)))
  (advice-add #'exwm-systemtray--on-workspace-switch :around 'exwm-systemtray--on-workspace-switch-advice)

  ;; helm integration
  (when (featurep 'helm)
    (when (bug-check-function-bytecode
           'helm-resolve-display-function
           "csYgcYgIKYY5AIkJPoQ0AAqDHADHyAshIYQ0AAyDLAANhCwAySBHylaENAAODssgnYQ2AMyHzcAhhw==")
      (defun helm-resolve-display-function (com)
        (or (with-helm-buffer helm-display-function)
            (default-value 'helm-display-function))))

    (when (bug-check-function-bytecode
           'helm-display-mode-line
           "xsAhiMcCPIMRAMjJBCKGFADKwCEDIhDLAiGEKgAJhSsAyMwDIgqdhSsAzQuFXQDIzAQiC86JiQM6g1kAA0CyA8jMBEAisgIBBZiDUgACAUKyAQNBsgSCNwCJn7aFCIOhAM/Q0dDSBgbQ0wYIhXkA1NXWBgtHItfYI0TT2QzaQkJE20JCQkJCQkJC3EJCFd0IPIOaAAhBQIKbAAghFiaCpQDKxSEVDieDswDesgPfIIiC1gAOKIPWAMcEPIXDAMjgBgYiBSLh4iDjItTQAwNR1+QjFim2ArYCiYXeAOUghw==")
      (defun helm-display-mode-line (source &optional force)
        "Set up mode line and header line for `helm-buffer'.

SOURCE is a Helm source object.

Optional argument FORCE forces redisplay of the Helm buffer's
mode and header lines."
        (set (make-local-variable 'helm-mode-line-string)
             (helm-interpret-value (or (and (listp source) ; Check if source is empty.
                                            (assoc-default 'mode-line source))
                                       (default-value 'helm-mode-line-string))
                                   source))
        (let ((follow (and (or (helm-follow-mode-p source)
                               (and helm-follow-mode-persistent
                                    (member (assoc-default 'name source)
                                            helm-source-names-using-follow)))
                           " (HF)"))
              (marked (and helm-marked-candidates
                           (cl-loop with cur-name = (assoc-default 'name source)
                                    for c in helm-marked-candidates
                                    for name = (assoc-default 'name (car c))
                                    when (string= name cur-name)
                                    collect c))))
          ;; Setup mode-line.
          (if helm-mode-line-string
              (setq mode-line-format
                    `(:propertize
                      ;; (" " mode-line-buffer-identification " "  ;; -
                      (                                            ;; +
                       (:eval (format "L%-3d" (helm-candidate-number-at-point)))
                       ,follow
                       " "
                       (:eval ,(and marked
                                    (propertize
                                     (format "M%d" (length marked))
                                     'face 'helm-visible-mark)))
                       (:eval (when ,helm--mode-line-display-prefarg
                                (let ((arg (prefix-numeric-value
                                            (or prefix-arg current-prefix-arg))))
                                  (unless (= arg 1)
                                    (propertize (format " [prefarg:%s]" arg)
                                                'face 'helm-prefarg)))))
                       " "
                       (:eval (with-helm-buffer
                               (helm-show-candidate-number
                                (car-safe helm-mode-line-string))))
                       " " helm--mode-line-string-real " "
                       (:eval (make-string (window-width) ? )))
                      keymap (keymap (mode-line keymap
                                                (mouse-1 . ignore)
                                                (down-mouse-1 . ignore)
                                                (drag-mouse-1 . ignore)
                                                (mouse-2 . ignore)
                                                (down-mouse-2 . ignore)
                                                (drag-mouse-2 . ignore)
                                                (mouse-3 . ignore)
                                                (down-mouse-3 . ignore)
                                                (drag-mouse-3 . ignore))))
                    helm--mode-line-string-real
                    (substitute-command-keys (if (listp helm-mode-line-string)
                                                 (cadr helm-mode-line-string)
                                               helm-mode-line-string)))
            (setq mode-line-format (default-value 'mode-line-format)))
          ;; Setup header-line.
          (cond (helm-echo-input-in-header-line
                 (setq force t)
                 (helm--set-header-line))
                (helm-display-header-line
                 (let ((hlstr (helm-interpret-value
                               (and (listp source)
                                    (assoc-default 'header-line source))
                               source))
                       (endstr (make-string (window-width) ? )))
                   (setq header-line-format
                         (propertize (concat " " hlstr endstr)
                                     'face 'helm-header))))))
        (when force (force-mode-line-update)))))

  ;; ;;;; ;;
  ;; Keys ;;
  ;; ;;;; ;;
  (global-set-key (kbd "M-s 7 T") 'exwm-toggle-transparency)

  (after-exwm-config:tmp)
  (fmakunbound 'after-exwm-config:tmp))
#+end_src

* Completions

#+begin_src elisp
(add-hook 'completion-list-mode-hook 'inhibit-mode-line)
(add-hook 'completion-list-mode-hook (lambda () (setq truncate-lines t)))

(setq completion-cycle-threshold 3
      completion-show-help nil
      completions-format 'vertical)

;; (defun switch-to-completions-updating ()
;;   (interactive)
;;   (when (active-minibuffer-window)
;;     (minibuffer-completion-help
;;      ;; (save-excursion
;;      ;;   (when (search-backward (find-tag--default) nil t)
;;      ;;     (point)))
;;      ))
;;   (switch-to-completions))

(with-eval-after-load 'simple
  (define-key minibuffer-local-shell-command-map (kbd "M-v")
    'switch-to-completions)
  (define-key read-expression-map (kbd "M-v") 'switch-to-completions))

(defun return-to-minibuffer-advice (&rest _args)
  (when (active-minibuffer-window)
    (switch-to-minibuffer)))
(advice-add 'quit-window :after 'return-to-minibuffer-advice)

(define-key completion-in-region-mode-map (kbd "M-v")
  'switch-to-completions)
(define-key minibuffer-local-completion-map (kbd "M-v")
  'switch-to-completions)
#+end_src

* CANC Completing at point
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
(defun completing-read-advice (orig-fun prompt collection &optional
                                        predicate require-match initial-input
                                        hist def inherit-input-method)
  (funcall orig-fun (propertize prompt
                                'face
                                (cl-case require-match
                                  (nil 'hi-green-b)
                                  (t 'hi-red-b)
                                  (confirm 'hi-magenta-b)
                                  (confirm-after-completion 'hi-magenta-b)
                                  (otherwise 'hi-yellow-b)))
           collection predicate require-match initial-input
           hist def inherit-input-method))
(advice-add 'completing-read :around 'completing-read-advice)
(with-eval-after-load 'crm
  (advice-add 'completing-read-multiple :around 'completing-read-advice))

(require 'completing-read-at-point)
(completing-read-at-point-mode)

#+end_src

#+RESULTS:

* Internal packages
** Always required
*** /repeat-mode/

#+begin_src elisp
(setq repeat-exit-timeout 3)
(repeat-mode)

(defvar inflection-repeat-map
  (let ((map (make-sparse-keymap)))
    (define-key map "u" 'string-inflection-all-cycle)
    (define-key map "+" 'rotate-text)
    (define-key map "-" 'rotate-text-backward)
    (define-key map ";" 'grugru)
    map))

(put 'string-inflection-all-cycle 'repeat-map 'inflection-repeat-map)
(put 'rotate-text 'repeat-map 'inflection-repeat-map)
(put 'rotate-text-backward 'repeat-map 'inflection-repeat-map)
(put 'grugru 'repeat-map 'inflection-repeat-map)
#+end_src

*** CANC /fido/
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
;; sudo apt install fd-find
;; sudo apt install ripgrep

(require 'icomplete)
;; (when (bug-check-function-bytecode
;;        'icomplete-force-complete-and-exit
;;        "wyDEIFaEFAAIhBAACYQUAAqDFwDFIIfGIIc=")
;;   (defun icomplete-force-complete-and-exit ()
;;     "Complete the minibuffer with the longest possible match and exit.
;; Use the first of the matches if there are any displayed, and use
;; the default otherwise."
;;     (interactive)
;;     ;; This function is tricky.  The mandate is to "force", meaning we
;;     ;; should take the first possible valid completion for the input.
;;     ;; However, if there is no input and we can prove that that
;;     ;; coincides with the default, it is much faster to just call
;;     ;; `minibuffer-complete-and-exit'.  Otherwise, we have to call
;;     ;; `minibuffer-force-complete-and-exit', which needs the full
;;     ;; completion set and is potentially slow and blocking.  Do the
;;     ;; latter if:
;;     (if (and (null completion-cycling)
;;              (or
;;               ;; there's some input, meaning the default in off the table by
;;               ;; definition; OR
;;               (> (icomplete--field-end) (icomplete--field-beg))
;;               ;; there's no input, but there's also no minibuffer default
;;               ;; (and the user really wants to see completions on no input,
;;               ;; meaning he expects a "force" to be at least attempted); OR
;;               (and (not minibuffer-default)
;;                    icomplete-show-matches-on-no-input)
;;               ;; there's no input but the full completion set has been
;;               ;; calculated, This causes the first cached completion to
;;               ;; be taken (i.e. the one that the user sees highlighted)
;;               completion-all-sorted-completions))
;;         (minibuffer-force-complete-and-exit)
;;       ;; Otherwise take the faster route...
;;       (minibuffer-complete-and-exit))))
;; (when (bug-check-function-bytecode
;;        'icomplete--sorted-completions
;;        "CIagAMMgxCDAAgIiCYMjAAk7gyMAxCDDIFWDIwDFxkSCNQAKhTUACT+FNQDHIMg9hTUAyUPKy8oDOoOVAANAsgMEysvKAzqDggADQTqDggADQUCyAwYGAyGDdwADiYlBQaG2AswGCwYLBQYMQiOyAcqJsgOCeADLg4IAA0GyBIJFALaDibICP4myA4OVAANBsgSCOAABg50ABIKeAIm2h4c=")
;;   (defun icomplete--sorted-completions ()
;;     (or completion-all-sorted-completions
;;         (cl-loop
;;          with beg = (icomplete--field-beg)
;;          with end = (icomplete--field-end)
;;          with all = (completion-all-sorted-completions beg end)
;;          for fn in (cond ((and minibuffer-default
;;                                (stringp minibuffer-default) ; bug#38992
;;                                (= (icomplete--field-end) (icomplete--field-beg)))
;;                           ;; When we have a non-nil string default and
;;                           ;; no input whatsoever: we want to make sure
;;                           ;; that default is bubbled to the top so that
;;                           ;; `icomplete-force-complete-and-exit' will
;;                           ;; select it (do that even if the match
;;                           ;; doesn't match the completion perfectly.
;;                           `(,(lambda (comp)
;;                                (equal minibuffer-default comp))))
;;                          ((and fido-mode
;;                                (not minibuffer-default)
;;                                (eq (icomplete--category) 'file))
;;                           ;; `fido-mode' has some extra file-sorting
;;                           ;; semantics even if there isn't a default,
;;                           ;; which is to bubble "./" to the top if it
;;                           ;; exists.  This makes M-x dired RET RET go to
;;                           ;; the directory of current file, which is
;;                           ;; what vanilla Emacs and `ido-mode' both do.
;;                           `(,(lambda (comp)
;;                                (string= "./" comp)))))
;;          thereis (cl-loop
;;                   for l on all
;;                   while (consp (cdr l))
;;                   for comp = (cadr l)
;;                   when (funcall fn comp)
;;                   do (setf (cdr l) (cddr l))
;;                   and return
;;                   (completion--cache-all-sorted-completions beg end (cons comp all)))
;;          finally return all))))
(eval-and-when-daemon frame
  (if (display-graphic-p frame)
      (set-face-attribute 'icomplete-first-match nil
                          :background 'unspecified
                          :foreground 'unspecified
                          :weight 'unspecified
                          :box '(:line-width -1 :color "steel blue" :style nil))
    (set-face-attribute 'icomplete-first-match nil
                        :background "#404000"
                        :foreground 'unspecified
                        :weight 'unspecified
                        :box 'unspecified)))
(with-eval-after-load 'simple
  (setq minor-mode-alist (assq-delete-all 'visual-line-mode minor-mode-alist))

  ;; slow performance
  ;; (global-visual-line-mode 1)
  (add-hook 'minibuffer-setup-hook 'visual-line-mode))

;; Another functions override this variables, then
;; set every time enter minibuffer
(setq
 ;; icomplete
 icomplete-prospects-height 4
 icomplete-separator (propertize " ◊ "
                                 'face '(:foreground "steel blue")))

(defun icomplete--fido-mode-setup ()
  "Setup `fido-mode''s minibuffer."
  (when (and icomplete-mode (icomplete-simple-completing-p))
    (use-local-map (make-composed-keymap icomplete-fido-mode-map
                                         (current-local-map)))
    (setq-local
     ;; fido
     icomplete-tidy-shadowed-file-names t
     icomplete-show-matches-on-no-input t
     icomplete-hide-common-prefix nil
     completion-styles '(orderless)
     completion-flex-nospace nil
     completion-category-defaults nil
     completion-ignore-case t
     read-buffer-completion-ignore-case t
     read-file-name-completion-ignore-case t)
    ;; [ fix bugs
    (when completion-cycling
      (funcall (prog1 completion-cycling (setq completion-cycling nil))))
    ;; ]
    ))

;; Keys
(define-key icomplete-minibuffer-map (kbd "C-k") 'icomplete-fido-kill)
(define-key icomplete-minibuffer-map (kbd "C-d") 'icomplete-fido-delete-char)
(define-key icomplete-minibuffer-map (kbd "RET") 'icomplete-fido-ret)
(define-key icomplete-fido-mode-map (kbd "C-m") nil)
(define-key icomplete-minibuffer-map (kbd "DEL") 'icomplete-fido-backward-updir)
(define-key icomplete-minibuffer-map (kbd "C-j") 'icomplete-fido-exit)
(define-key icomplete-fido-mode-map (kbd "C-j") 'icomplete-fido-exit)
(define-key icomplete-fido-mode-map (kbd "M-j") nil)
(define-key icomplete-minibuffer-map (kbd "C-s") 'icomplete-forward-completions)
(define-key icomplete-minibuffer-map (kbd "C-r") 'icomplete-backward-completions)
(define-key icomplete-minibuffer-map (kbd "C-|") 'icomplete-vertical-mode)
(define-key icomplete-fido-mode-map (kbd "C-|") 'icomplete-vertical-mode)
(global-set-key (kbd "M-g M-a") 'occur-project)
(global-set-key (kbd "M-g M-f") 'project-find-file)
(global-set-key (kbd "M-s O") 'multi-occur)
(global-set-key
 (kbd "<f12>")
 (lambda ()
   (interactive)
   (message "log: %s" (list completion-cycling minibuffer-default))))

(fido-mode)
#+end_src

#+RESULTS:
: t

*** Caps modes

#+begin_src elisp
;;;;;;;;;;;;;;;
;; Show caps ;;
;;;;;;;;;;;;;;;
(require 'dash)
(require 's)

(defun x-led-mask ()
  "Get the current status of the LED mask from X."
  (with-temp-buffer
    (call-process "xset" nil t nil "q")
    (let ((led-mask-string
           (->> (buffer-string)
                s-lines
                (--first (s-contains? "LED mask" it))
                s-split-words
                -last-item)))
      (string-to-number led-mask-string 16))))

(defun caps-lock-on (led-mask)
  "Return non-nil if LED-MASK means caps lock is on."
  (eq (logand led-mask 1) 1))

(define-minor-mode caps-lock-show-mode
  "Display whether caps lock is on."
  :global t
  :lighter (:propertize "⇪" font-lock-face
                        (:foreground "violet" :weight bold))
  (if caps-lock-show-mode
      (set-cursor-color "violet")
    (set-cursor-color "red")))

;;;;;;;;;;;;;;;;
;; Force caps ;;
;;;;;;;;;;;;;;;;
(defun caps-find-bind (key)
  ;; (message "active maps: %s" (mapcar 'keymap-symbol (current-active-maps t)))
  (cl-some (lambda (keymap)
             ;; (message "looking keymap: `%s'" (or (keymap-symbol keymap) keymap))
             (unless (eq keymap modal-mode-map)
               ;; (message "keymap accepted")
               (let ((binding (lookup-key keymap key)))
                 (if (commandp binding)
                     ;; (progn
                     ;;   (message "bind `%s' found in keymap: `%s'" binding (keymap-symbol keymap))
                     binding
                     ;;   )
                   ))))
           (current-active-maps)))

(defun caps-lock--upcase ()
  ;; (message "last-command-event: %s" last-command-event)
  (when (and (characterp last-command-event)
             (< last-command-event 123)
             (< 96 last-command-event))
    (setq last-command-event (upcase last-command-event))
    (unless isearch-mode
      (let ((binding (caps-find-bind (vector last-command-event))))
        (if binding
            (setq real-this-command binding
                  this-original-command binding
                  this-command binding))))))

(defvar caps--post-command-countdown nil)

(define-minor-mode caps-lock-mode
  "Make self-inserting keys invert the capitalization."
  :global t
  :lighter (:propertize "⇪" font-lock-face
                        (:foreground "red" :weight bold))
  (if caps-lock-mode
      (progn
        (when caps--post-command-countdown
          (remove-hook 'post-command-hook 'caps--enable-mode-and-remove-from-hook)
          (setq caps--post-command-countdown nil))
        (add-hook 'pre-command-hook 'caps-lock--upcase))
    (when caps--post-command-countdown
      (remove-hook 'post-command-hook 'caps--disable-mode-and-remove-from-hook)
      (setq caps--post-command-countdown nil))
    (remove-hook 'pre-command-hook 'caps-lock--upcase)))

(defun caps--enable-mode-and-remove-from-hook ()
  (if (< 0 caps--post-command-countdown)
      (cl-decf caps--post-command-countdown)
    (caps-lock-mode 1)))

(defun caps--disable-mode-and-remove-from-hook ()
  (if (< 0 caps--post-command-countdown)
      (cl-decf caps--post-command-countdown)
    (caps-lock-mode 0)))

(defun caps-lock-mode-post-command (times)
  (interactive "p")
  (if caps--post-command-countdown
      (setq caps--post-command-countdown (+ caps--post-command-countdown times 1))
    (when (and (numberp times)
               (< 0 times))
      (if caps-lock-mode
          (progn
            (caps-lock-mode 0)
            (add-hook 'post-command-hook 'caps--enable-mode-and-remove-from-hook))
        (caps-lock-mode 1)
        (add-hook 'post-command-hook 'caps--disable-mode-and-remove-from-hook))
      (setq caps--post-command-countdown times))))
#+end_src

*** /subword/

#+begin_src elisp
(require 'subword)
(setq minor-mode-alist (assq-delete-all 'subword-mode minor-mode-alist))

(face-spec-set 'region
               `((((class color) (min-colors 88) (supports :box t))
                  :box (:line-width ,(if (>= emacs-major-version 28) '(-1 . -1) -1) :color "CadetBlue" :style nil)
                  :extend nil)
                 (((class color) (min-colors 88) (background dark))
                  :extend nil)
                 (((class color) (min-colors 88) (background light) (type gtk))
                  :extend nil)
                 (((class color) (min-colors 88) (background light) (type ns))
                  :extend nil)
                 (((class color) (min-colors 88) (background light))
                  :extend nil)
                 (((class color) (min-colors 16) (background dark))
                  :extend nil)
                 (((class color) (min-colors 16) (background light))
                  :extend nil)
                 (((class color) (min-colors 8))
                  :extend nil)
                 (((type tty) (class mono))
                  :extend nil)
                 (t :extend nil)))
#+end_src

*** /bookmark/

#+begin_src elisp
(setq bookmark-default-file (expand-file-name "cache/bookmarks"
                                              user-emacs-directory))
#+end_src

*** /rect/

#+begin_src elisp
;; Thanks to: stackoverflow.com/questions/11130546/search-and-replace-inside-a-rectangle-in-emacs
(require 'rect)

(defun rectangle-search-replace
  (start end search-pattern replacement search-function literal)
  "Replace all instances of SEARCH-PATTERN (as found by SEARCH-FUNCTION)
with REPLACEMENT, in each line of the rectangle established by the START
and END buffer positions.

SEARCH-FUNCTION should take the same BOUND and NOERROR arguments as
`search-forward' and `re-search-forward'.

The LITERAL argument is passed to `replace-match' during replacement.

If `case-replace' is nil, do not alter case of replacement text."
  (apply-on-rectangle
   (lambda (start-col end-col search-function search-pattern replacement)
     (move-to-column start-col)
     (let ((bound (min (+ (point) (- end-col start-col))
                       (line-end-position)))
           (fixedcase (not case-replace)))
       (while (funcall search-function search-pattern bound t)
         (replace-match replacement fixedcase literal))))
   start end search-function search-pattern replacement))

(defun rectangle-replace-regexp-read-args (regexp-flag)
  "Interactively read arguments for `rectangle-replace-regexp'
or `rectangle-replace-string' (depending upon REGEXP-FLAG)."
  (let ((args (query-replace-read-args
               (concat "Replace"
                       (if current-prefix-arg " word" "")
                       (if regexp-flag " regexp" " string"))
               regexp-flag)))
    (list (region-beginning) (region-end)
          (nth 0 args) (nth 1 args) (nth 2 args))))

(defun rectangle-replace-regexp
  (start end regexp to-string &optional delimited)
  "Perform a regexp search and replace on each line of a rectangle
established by START and END (interactively, the marked region),
similar to `replace-regexp'.

Optional arg DELIMITED (prefix arg if interactive), if non-nil, means
replace only matches surrounded by word boundaries.

If `case-replace' is nil, do not alter case of replacement text."
  (interactive (rectangle-replace-regexp-read-args t))
  (when delimited
    (setq regexp (concat "\\b" regexp "\\b")))
  (rectangle-search-replace
   start end regexp to-string 're-search-forward nil))

(defun rectangle-replace-string
  (start end from-string to-string &optional delimited)
  "Perform a string search and replace on each line of a rectangle
established by START and END (interactively, the marked region),
similar to `replace-string'.

Optional arg DELIMITED (prefix arg if interactive), if non-nil, means
replace only matches surrounded by word boundaries.

If `case-replace' is nil, do not alter case of replacement text."
  (interactive (rectangle-replace-regexp-read-args nil))
  (let ((search-function 'search-forward))
    (when delimited
      (setq search-function 're-search-forward
            from-string (concat "\\b" (regexp-quote from-string) "\\b")))
    (rectangle-search-replace
     start end from-string to-string search-function t)))
#+end_src

*** /savehist/

See [[* Backup and Undo]]

#+begin_src elisp
(savehist-mode 1)
#+end_src

*** /eww/

#+begin_src elisp
;; Default eww key bindings
;; |-----------+----------------------------------------------------------------------|
;; | Key       | Function                                                             |
;; |-----------+----------------------------------------------------------------------|
;; | &         | Browse the current URL with an external browser.                     |
;; | -         | Begin a negative numeric argument for the next command.              |
;; | 0 .. 9    | Part of the numeric argument for the next command.                   |
;; | C         | Display a buffer listing the current URL cookies, if there are any.  |
;; | H         | List the eww-histories.                                              |
;; | F         | Toggle font between variable-width and fixed-width.                  |
;; | G         | Go to a URL                                                          |
;; | R         | Readable mode                                                        |
;; | S         | List eww buffers                                                     |
;; | d         | Download URL under point to `eww-download-directory'.                |
;; | g         | Reload the current page.                                             |
;; | q         | Quit WINDOW and bury its buffer.                                     |
;; | v         | `eww-view-source'                                                    |
;; | w         | `eww-copy-page-url'                                                  |
;; |-----------+----------------------------------------------------------------------|
;; | b         | Add the current page to the bookmarks.                               |
;; | B         | Display the bookmark list.                                           |
;; | M-n       | Visit the next bookmark                                              |
;; | M-p       | Visit the previous bookmark                                          |
;; |-----------+----------------------------------------------------------------------|
;; | t         | Go to the page marked `top'.                                         |
;; | u         | Go to the page marked `up'.                                          |
;; |-----------+----------------------------------------------------------------------|
;; | n         | Go to the page marked `next'.                                        |
;; | p         | Go to the page marked `previous'.                                    |
;; |-----------+----------------------------------------------------------------------|
;; | l         | Go to the previously displayed page.                                 |
;; | r         | Go to the next displayed page.                                       |
;; |-----------+----------------------------------------------------------------------|
;; | TAB       | Move point to next link on the page.                                 |
;; | S-TAB     | Move point to previous link on the page.                             |
;; |-----------+----------------------------------------------------------------------|
;; | SPC       | Scroll up                                                            |
;; | DEL/Bkspc | Scroll down                                                          |
;; | S-SPC     | Scroll down                                                          |
;; |-----------+----------------------------------------------------------------------|

(with-eval-after-load 'eww
  (cond ((file-exists-p "~/Downloads")
         (setq eww-download-directory "~/Downloads"))
        ((file-exists-p "~/Descargas")
         (setq eww-download-directory "~/Descargas")))
  (setq eww-search-prefix "https://www.google.com/search?q="
        browse-url-secondary-browser-function 'eww-browse-url)


  (defvar browse-url-qutebrowser-program "qutebrowser")
  (defvar browse-url-qutebrowser-arguments nil)
  (defun browse-url-qutebrowser (url &optional _new-window)
    "Ask the Chromium WWW browser to load URL.
Default to the URL around or before point.  The strings in
variable `browse-url-chromium-arguments' are also passed to
Chromium.
The optional argument NEW-WINDOW is not used."
    (interactive (browse-url-interactive-arg "URL: "))
    (setq url (browse-url-encode-url url))
    (let* ((process-environment (browse-url-process-environment)))
      (apply #'start-process
             (concat "qutebrowser " url) nil
             browse-url-qutebrowser-program
             (append
              browse-url-qutebrowser-arguments
              (list url)))))

  (defun browse-url-browser-function-selection (arg)
    (interactive "P")
    (let ((selection
           (intern
            (completing-read
             "Select function to open urls: "
             (let (browsers)
               (if (locate-library "w3") 'browse-url-w3)
               (if (executable-find browse-url-xterm-program) (push 'browse-url-text-xterm browsers))
               (if (executable-find browse-url-kde-program) (push 'browse-url-kde browsers))
               (if (executable-find browse-url-conkeror-program) (push 'browse-url-conkeror browsers))
               (if (executable-find browse-url-chrome-program) (push 'browse-url-chrome browsers))
               (if (executable-find browse-url-chromium-program) (push 'browse-url-chromium browsers))
               (if (executable-find browse-url-firefox-program) (push 'browse-url-firefox browsers))
               (if (executable-find browse-url-mozilla-program) (push 'browse-url-mozilla browsers))
               (if (executable-find browse-url-qutebrowser-program) (push 'browse-url-qutebrowser browsers))
               (push 'eww-browse-url browsers)
               (push 'browse-url-default-browser browsers)
               browsers)
             nil t nil nil browse-url-browser-function))))
      (if arg
          (message "browse-url-secondary-browser-function setted to `%s'"
                   (setq browse-url-secondary-browser-function selection))
        (message "browse-url-browser-function setted to `%s'"
                 (setq browse-url-browser-function selection)))))

  (global-set-key (kbd "C-x W") 'browse-url-browser-function-selection)
  ;; Make the binding for `revert-buffer' do `eww-reload' in eww-mode
  (define-key eww-mode-map (kbd "<backtab>") 'shr-previous-link)
  (define-key eww-mode-map (kbd ":") 'eww)
  (define-key eww-mode-map (kbd "h") 'eww-list-histories)
  (define-key eww-mode-map (kbd "w") 'modi/eww-copy-url-dwim)
  (define-key eww-mode-map (kbd "k") 'modi/eww-keep-lines)
  (define-key eww-mode-map [remap revert-buffer] 'eww-reload)
  (define-key eww-checkbox-map (kbd "<down-mouse-1>") 'eww-toggle-checkbox))
(global-set-key (kbd "C-x W")
                (lambda ()
                  (interactive)
                  (require 'eww)
                  (browse-url-browser-function-selection)))
#+end_src

*** CANC /prettify-symbols/
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
(defun prettify-symbols-emacs-lisp-mode-hook ()
  (if (display-graphic-p)
      (progn
        (cl-delete '("lambda" . 995) prettify-symbols-alist)
        (push '("lambda" . (?\s (Br . Bl) ?\s (Br . Bl) ?λ (Br . Bl) ?· (Br . Bl) ?\s (Br . Bl) ?\s)) prettify-symbols-alist)
        (push '("nil" . (?\s (Br . Bl) ?∅ (Br . Bl) ?\s)) prettify-symbols-alist))
    (push '("nil" . ?∅) prettify-symbols-alist)))

(defun prettify-symbols-c-mode-common-hook ()
  (push '("!"     . ?¬) prettify-symbols-alist)
  (push '("="     . ?≔) prettify-symbols-alist)
  (if (display-graphic-p)
      (progn
        (push '("true"  . (?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Bc . Bc) ?✓)) prettify-symbols-alist)
        (push '("false" . (?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Bc . Bc) ?✘)) prettify-symbols-alist)
        (push '("&&"    . (?\s (Br . Bl) ?\s (Bc . Bc) ?∧)) prettify-symbols-alist)
        (push '("||"    . (?\s (Br . Bl) ?\s (Bc . Bc) ?∨)) prettify-symbols-alist)
        (push '("->"    . (?\s (Br . Bl) ?\s (Bc . Bc) ?→)) prettify-symbols-alist)
        (push '("::"    . (?\s (Br . Bl) ?\s (Bc . Bc) ?⊃)) prettify-symbols-alist)
        (push '("::~"   . (?\s (Br . Bl) ?\s (Br . Bl) ?\s (Bc . Br) ?⊃ (Bc . Bl) ?~)) prettify-symbols-alist)
        (push '(">::"   . (?\s (Br . Bl) ?\s (Br . Bl) ?\s (Bl . Bl) ?> (Bc . Bl) ?⊃)) prettify-symbols-alist)
        (push '("->*"   . (?\s (Br . Bl) ?\s (Br . Bl) ?\s (Bc . Br) ?→ (Br . Br) ?*)) prettify-symbols-alist))
    (push '("true"  . ?✓) prettify-symbols-alist)
    (push '("false" . ?✘) prettify-symbols-alist)
    (push '("&&"    . ?∧) prettify-symbols-alist)
    (push '("||"    . ?∨) prettify-symbols-alist)
    (push '("->"    . ?→) prettify-symbols-alist)
    (push '("::"    . ?⊃) prettify-symbols-alist)))

(defun prettify-symbols-c-mode-hook ()
  (if (display-graphic-p)
      (progn
        (push '("!="    . (?\s (Br . Bl) ?\s (Bc . Bc) ?≠)) prettify-symbols-alist)
        (push '("<="    . (?\s (Br . Bl) ?\s (Bc . Bc) ?≤)) prettify-symbols-alist)
        (push '(">="    . (?\s (Br . Bl) ?\s (Bc . Bc) ?≥)) prettify-symbols-alist)
        (push '("=="    . (?\s (Br . Bl) ?\s (Bc . Bc) ?≡)) prettify-symbols-alist))
    (push '("!="    . ?≠) prettify-symbols-alist)
    (push '("<="    . ?≤) prettify-symbols-alist)
    (push '(">="    . ?≥) prettify-symbols-alist)
    (push '("=="    . ?≡) prettify-symbols-alist)))

(defun prettify-symbols-c++-mode-hook ()
  (if (display-graphic-p)
      (progn
        (push '("!="    . (?\s (Br . Bl) ?\s (Bc . Bc) ?≠)) prettify-symbols-alist)
        (push '("<="    . (?\s (Br . Bl) ?\s (Bc . Bc) ?≤)) prettify-symbols-alist)
        (push '(">="    . (?\s (Br . Bl) ?\s (Bc . Bc) ?≥)) prettify-symbols-alist)
        (push '("=="    . (?\s (Br . Bl) ?\s (Bc . Bc) ?≡)) prettify-symbols-alist))
    (push '("!="    . ?≠) prettify-symbols-alist)
    (push '("<="    . ?≤) prettify-symbols-alist)
    (push '(">="    . ?≥) prettify-symbols-alist)
    (push '("=="    . ?≡) prettify-symbols-alist)))

(defun prettify-symbols-php-mode-hook ()
  (if (display-graphic-p)
      (progn
        (push '("!=="   . (?\s (Br . Bl) ?≠ (Br . Bl) ?\s)) prettify-symbols-alist)
        (push '("<=="   . (?\s (Br . Bl) ?≤ (Br . Bl) ?\s)) prettify-symbols-alist)
        (push '(">=="   . (?\s (Br . Bl) ?≥ (Br . Bl) ?\s)) prettify-symbols-alist)
        (push '("==="   . (?\s (Br . Bl) ?≡ (Br . Bl) ?\s)) prettify-symbols-alist)
        (push '("!="    . (?\s (Br . Bl) ?\s (Bc . Bc) ?≉)) prettify-symbols-alist)
        (push '("<="    . (?\s (Br . Bl) ?\s (Bc . Bc) ?≲)) prettify-symbols-alist)
        (push '(">="    . (?\s (Br . Bl) ?\s (Bc . Bc) ?≳)) prettify-symbols-alist)
        (push '("=="    . (?\s (Br . Bl) ?\s (Bc . Bc) ?≈)) prettify-symbols-alist))
    (push '("!=="   . ?≠) prettify-symbols-alist)
    (push '("<=="   . ?≤) prettify-symbols-alist)
    (push '(">=="   . ?≥) prettify-symbols-alist)
    (push '("==="   . ?≡) prettify-symbols-alist)
    (push '("!="    . ?≉) prettify-symbols-alist)
    (push '("<="    . ?≲) prettify-symbols-alist)
    (push '(">="    . ?≳) prettify-symbols-alist)
    (push '("=="    . ?≈) prettify-symbols-alist)))

(defun prettify-symbols-js-mode-hook ()
  (if (display-graphic-p)
      (progn
        (push '("!=="   . (?\s (Br . Bl) ?≠ (Br . Bl) ?\s)) prettify-symbols-alist)
        (push '("<=="   . (?\s (Br . Bl) ?≤ (Br . Bl) ?\s)) prettify-symbols-alist)
        (push '(">=="   . (?\s (Br . Bl) ?≥ (Br . Bl) ?\s)) prettify-symbols-alist)
        (push '("==="   . (?\s (Br . Bl) ?≡ (Br . Bl) ?\s)) prettify-symbols-alist)
        (push '("!="    . (?\s (Br . Bl) ?\s (Bc . Bc) ?≉)) prettify-symbols-alist)
        (push '("<="    . (?\s (Br . Bl) ?\s (Bc . Bc) ?≲)) prettify-symbols-alist)
        (push '(">="    . (?\s (Br . Bl) ?\s (Bc . Bc) ?≳)) prettify-symbols-alist)
        (push '("=="    . (?\s (Br . Bl) ?\s (Bc . Bc) ?≈)) prettify-symbols-alist))
    (push '("!=="   . ?≠) prettify-symbols-alist)
    (push '("<=="   . ?≤) prettify-symbols-alist)
    (push '(">=="   . ?≥) prettify-symbols-alist)
    (push '("==="   . ?≡) prettify-symbols-alist)
    (push '("!="    . ?≉) prettify-symbols-alist)
    (push '("<="    . ?≲) prettify-symbols-alist)
    (push '(">="    . ?≳) prettify-symbols-alist)
    (push '("=="    . ?≈) prettify-symbols-alist)))

(defun prettify-symbols-python-mode-hook ()
  (push '("!"     . ?¬) prettify-symbols-alist)
  (push '("="     . ?≔) prettify-symbols-alist)
  (if (display-graphic-p)
      (progn
        (cl-delete '("lambda" . 995) prettify-symbols-alist)
        (push '("lambda" . (?\s (Br . Bl) ?\s (Br . Bl) ?λ (Br . Bl) ?· (Br . Bl) ?\s (Br . Bl) ?\s)) prettify-symbols-alist)
        (push '("True"   . (?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Bc . Bc) ?✓)) prettify-symbols-alist)
        (push '("False"  . (?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Bc . Bc) ?✘)) prettify-symbols-alist)
        (push '("None"   . (?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Bc . Bc) ?∅)) prettify-symbols-alist)
        (push '("and"    . (?\s (Br . Bl) ?\s (Br . Bl) ?\s (Bc . Bc) ?∧)) prettify-symbols-alist)
        (push '("or"     . (?\s (Br . Bl) ?\s (Bc . Bc) ?∨)) prettify-symbols-alist)
        (push '("!="     . (?\s (Br . Bl) ?\s (Bc . Bc) ?≠)) prettify-symbols-alist)
        (push '("<="     . (?\s (Br . Bl) ?\s (Bc . Bc) ?≤)) prettify-symbols-alist)
        (push '(">="     . (?\s (Br . Bl) ?\s (Bc . Bc) ?≥)) prettify-symbols-alist)
        (push '("=="     . (?\s (Br . Bl) ?\s (Bc . Bc) ?≡)) prettify-symbols-alist))
    (push '("True"  . ?✓) prettify-symbols-alist)
    (push '("False" . ?✘) prettify-symbols-alist)
    (push '("None"  . ?∅) prettify-symbols-alist)
    (push '("and"   . ?∧) prettify-symbols-alist)
    (push '("or"    . ?∨) prettify-symbols-alist)
    (push '("!="    . ?≠) prettify-symbols-alist)
    (push '("<="    . ?≤) prettify-symbols-alist)
    (push '(">="    . ?≥) prettify-symbols-alist)
    (push '("=="    . ?≡) prettify-symbols-alist)))

(defun prettify-symbols-hooks (&optional arg)
  (interactive "P")
  (if arg
      (progn
        (remove-hook 'emacs-lisp-mode-hook 'prettify-symbols-emacs-lisp-mode-hook)
        (remove-hook 'c-mode-common-hook 'prettify-symbols-c-mode-common-hook)
        (remove-hook 'c-mode-hook 'prettify-symbols-c-mode-hook)
        (remove-hook 'c++-mode-hook 'prettify-symbols-c++-mode-hook)
        (remove-hook 'php-mode-hook 'prettify-symbols-php-mode-hook)
        (remove-hook 'js-mode-hook 'prettify-symbols-js-mode-hook)
        (remove-hook 'python-mode-hook 'prettify-symbols-python-mode-hook))
    (setq prettify-symbols-unprettify-at-point 'right-edge)
    (add-hook 'emacs-lisp-mode-hook 'prettify-symbols-emacs-lisp-mode-hook)
    (add-hook 'c-mode-common-hook 'prettify-symbols-c-mode-common-hook)
    (add-hook 'c-mode-hook 'prettify-symbols-c-mode-hook)
    (add-hook 'c++-mode-hook 'prettify-symbols-c++-mode-hook)
    (add-hook 'php-mode-hook 'prettify-symbols-php-mode-hook)
    (add-hook 'js-mode-hook 'prettify-symbols-js-mode-hook)
    (add-hook 'python-mode-hook 'prettify-symbols-python-mode-hook)))

(global-set-key (kbd "M-s 7 p") #'prettify-symbols-mode)
(global-set-key (kbd "M-s 7 P") (lambda ()
                                  (interactive)
                                  (prettify-symbols-hooks global-prettify-symbols-mode)
                                  (global-prettify-symbols-mode)))
#+end_src

*** Move Thing

#+begin_src elisp
;;  #####
;; #     #  ####  #####  ######
;; #       #    # #    # #
;; #       #    # #    # #####
;; #       #    # #####  #
;; #     # #    # #   #  #
;;  #####   ####  #    # ######
;; (fset 'mt-bounds-of-thing-at-point
;;       (if (require 'thingatpt+ nil t)
;;           #'tap-bounds-of-thing-at-point
;;         #'bounds-of-thing-at-point))
(fset 'mt--bounds-of-thing-at-point
      #'bounds-of-thing-at-point)

(require 'rect)
(require 'ring)
(defvar mt-things
  '((word     . "'w")
    (symbol   . "'s")
    (sexp     . "'e")
    (list     . "'t")
    (defun    . "'d")
    (filename . "'f")
    (url      . "'u")
    (email    . "'m")
    (line     . "'l")))

;; Check list sorted
(defun sorted-p (list op)
  (let ((copy (cl-copy-list list)))
    (equal (sort copy op) list)))

;; [ to
(defvar mt--to-thing-ring nil)
(let ((to-things mt-things))
  (set 'mt--to-thing-ring (make-ring (length to-things)))
  (dolist (elem to-things) (ring-insert mt--to-thing-ring (car elem))))

(defvar mt--to-thing (ring-ref mt--to-thing-ring 0))

(defun mt--cycle-to-things ()
  "Cycle to-things in ring."
  (let ((to-thing (ring-ref mt--to-thing-ring -1)))
    (ring-insert mt--to-thing-ring to-thing)
    (set 'mt--to-thing to-thing)))
;; ]

;; [ from
(defvar mt--from-thing-ring nil)
(let ((from-things mt-things))
  (set 'mt--from-thing-ring (make-ring (length from-things)))
  (dolist (elem from-things) (ring-insert mt--from-thing-ring (car elem))))

(defvar mt--from-thing (ring-ref mt--from-thing-ring 0))

(defun mt--cycle-from-things ()
  "Cycle from-things in ring."
  (let ((from-thing (ring-ref mt--from-thing-ring -1)))
    (ring-insert mt--from-thing-ring from-thing)
    (setq mt--from-thing from-thing
          mt--to-thing from-thing)
    from-thing))
;; ]

(defun mt--bounds-of-thing-at-point-or-region (thing)
  (if (use-region-p)
      (let ((positions (sort (list (mark) (point)) '<)))
        (if rectangle-mark-mode
            (let ((columns (sort (list (progn (goto-char (car positions))
                                              (current-column))
                                       (progn (goto-char (car (cdr positions)))
                                              (current-column))) '<)))
              (cons 'rectangle
                    (cons (progn (goto-char (car positions))
                                 (move-to-column (car columns))
                                 (point))
                          (progn (goto-char (car (cdr positions)))
                                 (move-to-column (car (cdr columns)))
                                 (point)))))
          (cons 'region
                (cons (car positions) (car (cdr positions))))))
    (cons 'bounds
          (mt--bounds-of-thing-at-point thing))))

;;  #####                                               #     #
;; #     #  ####  #    # #    #   ##   #    # #####     #     #  ####   ####  #    #
;; #       #    # ##  ## ##  ##  #  #  ##   # #    #    #     # #    # #    # #   #
;; #       #    # # ## # # ## # #    # # #  # #    #    ####### #    # #    # ####
;; #       #    # #    # #    # ###### #  # # #    #    #     # #    # #    # #  #
;; #     # #    # #    # #    # #    # #   ## #    #    #     # #    # #    # #   #
;;  #####   ####  #    # #    # #    # #    # #####     #     #  ####   ####  #    #
(defvar mt-movement-commands
  #s(hash-table
     size 83
     test eq
     data (
           previous-line t
           next-line t
           right-char t
           right-word t
           forward-char t
           forward-word t
           left-char t
           left-word t
           backward-char t
           backward-word t
           forward-paragraph t
           backward-paragraph t
           forward-list t
           backward-list t
           end-of-buffer t
           end-of-defun t
           end-of-line t
           end-of-sexp t
           end-of-visual-line t
           exchange-point-and-mark t
           move-end-of-line t
           beginning-of-buffer t
           beginning-of-defun t
           beginning-of-line t
           beginning-of-sexp t
           beginning-of-visual-line t
           move-beginning-of-line t
           back-to-indentation t
           subword-forward t
           subword-backward t
           subword-mark t
           subword-kill t
           subword-backward-kill t
           subword-transpose t
           subword-capitalize t
           subword-upcase t
           subword-downcase t
           sp-forward-sexp t
           sp-backward-sexp t
           smart-forward t
           smart-backward t
           smart-up t
           smart-down t
           org-shifttab t
           org-shiftleft t
           org-shiftright t
           org-shiftup t
           org-shiftdown t
           org-shiftcontrolleft t
           org-shiftcontrolright t
           org-shiftcontrolup t
           org-shiftcontroldown t
           org-shiftmetaleft t
           org-shiftmetaright t
           org-shiftmetaup t
           org-shiftmetadown t
           avy-goto-char t
           avy-goto-char-2 t
           avy-goto-char-2-above t
           avy-goto-char-2-below t
           avy-goto-char-in-line t
           avy-goto-char-timer t
           avy-goto-end-of-line t
           avy-goto-line t
           avy-goto-line-above t
           avy-goto-line-below t
           avy-goto-subword-0 t
           avy-goto-subword-1 t
           avy-goto-symbol-1 t
           avy-goto-symbol-1-above t
           avy-goto-symbol-1-below t
           avy-goto-word-0 t
           avy-goto-word-0-above t
           avy-goto-word-0-below t
           avy-goto-word-0-regexp t
           avy-goto-word-1 t
           avy-goto-word-1-above t
           avy-goto-word-1-below t
           avy-goto-word-or-subword-1 t
           magit-previous-line t
           magit-next-line t
           magit-section-backward t
           magit-section-forward t
           magit-section-backward-sibling t
           magit-section-forward-sibling t
           ))
  "Default set of movement commands.")

(defvar mt-interchange-things nil)

(defvar mt--marker nil
  "Beginning of from region marker.")

(defun mt--post-command ()
  (when (and (gethash this-original-command mt-movement-commands)
             (marker-position mt--marker))
    (condition-case raised-error
        (let ((from-bounds (save-excursion
                             (switch-to-buffer (marker-buffer mt--marker))
                             (goto-char (marker-position mt--marker))
                             (mt--bounds-of-thing-at-point mt--from-thing))))
          ;; (message "From %s" from-bounds)
          (if from-bounds
              (if mt-interchange-things
                  (let ((to-bounds (mt--bounds-of-thing-at-point
                                    mt--to-thing)))
                    ;; (message "To %s" to-bounds)
                    (if to-bounds
                        (if (or (<= (cdr from-bounds) (car to-bounds))
                                (<= (cdr to-bounds) (car from-bounds)))
                            (let ((thing (mt--kill-bounds to-bounds)))
                              (save-excursion
                                (switch-to-buffer (marker-buffer mt--marker))
                                (goto-char (marker-position mt--marker))
                                (setq thing (prog1
                                                (mt--kill-bounds
                                                 (mt--bounds-of-thing-at-point mt--from-thing))
                                              (insert thing))))
                              (insert thing))
                          (message "From %s To %s intersect" from-bounds to-bounds))
                      (message "To %s not found" mt--to-thing)))
                (save-excursion
                  (switch-to-buffer (marker-buffer mt--marker))
                  (setq thing (mt--kill-bounds from-bounds)))
                (insert thing))
            (message "From %s not found" mt--from-thing)))
      (error (message "Moving thing: %s" (error-message-string raised-error))))
    (set-marker mt--marker nil)
    (setq mt--mode-line-face 'mt--unselected-face)
    (force-mode-line-update)))

;; #     #
;; ##   ##  ####  #####  ######
;; # # # # #    # #    # #
;; #  #  # #    # #    # #####
;; #     # #    # #    # #
;; #     # #    # #    # #
;; #     #  ####  #####  ######
(defface mt--selected-face
  '((((class color) (background dark))
     (:background "#AAAA33"))
    (((class color) (background light))
     (:background "#FFFFAA")))
  "Correct" :group 'mt-mode)
(defface mt--unselected-face
  '((t :foreground "white" :inherit (mode-line)))
  "Correct" :group 'mode-line)

(defvar mt--mode-line-face 'mt--unselected-face)


(defgroup move-thing ()
  "Move thing minor mode."
  :group 'editing
  :prefix "mt-")

(defcustom mt-mode-line
  '(:eval (propertize
           (concat (cdr (assoc mt--from-thing mt-things))
                   (if mt-interchange-things
                       (cdr (assoc mt--to-thing mt-things))))
           'face mt--mode-line-face))
  "Show current selected thing."
  :group 'move-thing
  :risky t
  :type 'sexp)

(defvar mt-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "M-j") 'mt-cycle-things)
    (define-key map (kbd "M-k") 'mt-cycle-to-things)
    (define-key map (kbd "M-h") 'mt-toggle-interchange-things)
    ;; (define-key map (kbd "C-p") 'mt-move-up)
    ;; (define-key map (kbd "C-n") 'mt-move-down)
    ;; (define-key map (kbd "C-b") 'mt-move-left)
    ;; (define-key map (kbd "C-f") 'mt-move-right)
    ;; (define-key map (kbd "<up>")     'mt-up)
    ;; (define-key map (kbd "<down>")   'mt-down)
    ;; (define-key map (kbd "<left>")   'mt-backward)
    ;; (define-key map (kbd "<right>")  'mt-forward)
    ;; (define-key map (kbd "<prior>")  'mt-shift-mc-left)
    ;; (define-key map (kbd "<next>")   'mt-shift-mc-right)
    map))

(define-minor-mode mt-mode
  "Toggle Move thing mode."
  :init-value nil
  :lighter mt-mode-line
  :group 'move-thing
  :keymap mt-mode-map
  :global t
  (if mt-mode
      (progn
        (add-hook 'post-command-hook 'mt--post-command)
        (setq mt--marker (make-marker)))
    (setq mt--marker nil)
    (remove-hook 'post-command-hook 'mt--post-command)))

;;              #
;; #####       #  #    #
;; #    #     #   #    #
;; #    #    #    #    #
;; #####    #     # ## #
;; #   #   #      ##  ##
;; #    # #       #    #
(defun mt-insert-rectangle (rectangle arg &optional col)
  (let ((lines (if (<= 0 arg) rectangle (nreverse rectangle)))
        (column (or col (current-column))))
    ;; (undo-boundary)  ; <undo>
    (insert (car lines))
    (setq lines (cdr lines))
    (while lines
      (forward-line arg)
      (or (bolp) (insert ?\n))
      (move-to-column column t)
      (insert (car lines))
      (setq lines (cdr lines)))))

(defun mt-kill-rectangle-or-bounds (arg)
  (unless (cdr arg)
    (error "%s not found, kill imposible" arg))
  (cl-case (car arg)
    (rectangle
     ;; (undo-boundary)  ; <undo>
     (delete-extract-rectangle (car (cdr arg)) (cdr (cdr arg))))
    ((region bounds)
     (prog1
         (list (buffer-substring-no-properties (car (cdr arg)) (cdr (cdr arg))))
       ;; (undo-boundary)  ; <undo>
       (delete-region (car (cdr arg)) (cdr (cdr arg)))))))

(defun mt--kill-bounds (bounds)
  (let ((beg (car bounds))
        (end (cdr bounds)))
    (prog1
        (buffer-substring-no-properties beg end)
      ;; (undo-boundary)  ; <undo>
      (unless buffer-read-only
        (delete-region beg end)))))

(defun mt-kill-bounds (arg)
  (unless arg
    (error "Thing not found, kill imposible"))
  (prog1
      (buffer-substring-no-properties (car arg) (cdr arg))
    ;; (undo-boundary)  ; <undo>
    (delete-region (car arg) (cdr arg))))

;; #     #
;; ##    #   ##   #    # #  ####    ##   ##### #  ####  #    #
;; # #   #  #  #  #    # # #    #  #  #    #   # #    # ##   #
;; #  #  # #    # #    # # #      #    #   #   # #    # # #  #
;; #   # # ###### #    # # #  ### ######   #   # #    # #  # #
;; #    ## #    #  #  #  # #    # #    #   #   # #    # #   ##
;; #     # #    #   ##   #  ####  #    #   #   #  ####  #    #
(defun mt-forward-line (arg &optional column)
  (unless (and (not column) (= 0 arg))
    (or column (setq column (current-column)))
    (unless (= 0 (forward-line arg))
      (error "Buffer limit reached"))
    (= column (move-to-column column))))

(defun mt-exists-thing-at-point (thing)
  (let ((bounds (mt--bounds-of-thing-at-point thing)))
    (and bounds
         (let ((str (buffer-substring-no-properties
                     (car bounds) (cdr bounds))))
           (not (string-equal str "\n"))))))

(defun mt-up-thing (arg &optional column thing)
  (setq arg (- (abs arg))
        thing (or thing mt--to-thing))
  (mt-forward-line arg column)
  (while (not (mt-exists-thing-at-point thing))
    (cl-decf arg)
    (mt-forward-line -1 column))
  (- arg))

(defun mt-down-thing (arg &optional column thing)
  (setq arg (abs arg)
        thing (or thing mt--to-thing))
  (mt-forward-line arg column)
  (while (not (mt-exists-thing-at-point thing))
    (cl-incf arg)
    (mt-forward-line 1 column))
  arg)

(defun mt-forward-thing (arg &optional thing delimiter len)
  (setq thing (or thing mt--to-thing)
        len (or len 1))
  (let (bounds
        pos
        (pos-ini (point)))
    (if delimiter
        (dotimes (i arg)
          (while (not (and
                       (set 'bounds (mt--bounds-of-thing-at-point thing))
                       (set 'pos (point))
                       (not (= pos (cdr bounds)))
                       (< pos-ini pos)
                       (string-match-p delimiter
                                       (buffer-substring-no-properties
                                        (car bounds)
                                        (+ len (car bounds))))))
            (forward-char 1))
          (goto-char (cdr bounds)))
      (dotimes (i arg)
        (while (not (and
                     (set 'bounds (mt--bounds-of-thing-at-point thing))
                     (set 'pos (point))
                     (not (= pos (cdr bounds)))
                     (< pos-ini pos)))
          (forward-char 1))
        (goto-char (cdr bounds))))
    bounds))

(defun mt-backward-thing (arg &optional thing delimiter len)
  (setq thing (or thing mt--to-thing)
        len (or len 1))
  (let (bounds
        pos
        (pos-ini (point)))
    (if delimiter
        (dotimes (i arg)
          (while (not (and
                       (set 'bounds (mt--bounds-of-thing-at-point thing))
                       (set 'pos (point))
                       (not (= pos (car bounds)))
                       (> pos-ini pos)
                       (string-match-p delimiter
                                       (buffer-substring-no-properties
                                        (car bounds)
                                        (+ len (car bounds))))))
            (backward-char 1))
          (goto-char (car bounds)))
      (dotimes (i arg)
        (while (not (and
                     (set 'bounds (mt--bounds-of-thing-at-point thing))
                     (not (= (point) (car bounds)))))
          (backward-char 1))
        (goto-char (car bounds))))
    bounds))


;; #     #
;; ##   ##  ####  #    # ###### #    # ###### #    # #####
;; # # # # #    # #    # #      ##  ## #      ##   #   #
;; #  #  # #    # #    # #####  # ## # #####  # #  #   #
;; #     # #    # #    # #      #    # #      #  # #   #
;; #     # #    #  #  #  #      #    # #      #   ##   #
;; #     #  ####    ##   ###### #    # ###### #    #   #
(defun mt-newline-ending (str)
  (char-equal ?\n (aref str (1- (length str)))))

(defun mt-push-mark (type)
  (cl-case type
    (rectangle
     (rectangle-mark-mode)
     (push-mark)
     (setq deactivate-mark nil))
    (region
     (push-mark)
     (setq deactivate-mark nil))))

(defun mt-push-mark-all (type)
  (cl-case type
    (rectangle
     (rectangle-mark-mode)
     (push-mark)
     (setq deactivate-mark nil))
    (region
     (push-mark)
     (setq deactivate-mark nil))
    (bounds
     (set-mark (point))
     (setq deactivate-mark nil))))

(defun mt-move-thing-up (arg)
  (mt-move-thing-down (- arg)))

(defun mt-move-thing-down (arg)
  (let* ((from-sbs (mt--bounds-of-thing-at-point-or-region mt--from-thing))
         (from (mt-kill-rectangle-or-bounds from-sbs))
         (column (current-column)))
    (goto-char (car (cdr from-sbs)))
    (forward-line arg)
    (move-to-column column t)
    (let ((pos (point)))
      (mt-insert-rectangle from 1 column)
      (mt-push-mark-all (car from-sbs))
      (goto-char pos))))

(defun mt-move-thing-backward (arg)
  (mt-move-thing-forward (- arg)))

(defun mt-move-thing-forward (arg)
  (let* ((from-sbs (mt--bounds-of-thing-at-point-or-region mt--from-thing))
         (from (mt-kill-rectangle-or-bounds from-sbs)))
    (goto-char (car (cdr from-sbs)))
    (forward-char arg)
    (let ((pos (point)))
      (mt-insert-rectangle from 1)
      (mt-push-mark-all (car from-sbs))
      (goto-char pos))))

(defun mt-interchange-thing-up (arg)
  (let* ((column (current-column))
         (from-sbs (mt--bounds-of-thing-at-point-or-region mt--from-thing))
         (from (mt-kill-rectangle-or-bounds from-sbs)))
    (goto-char (car (cdr from-sbs)))
    (mt-up-thing arg column mt--to-thing)
    (let* ((to-bs (mt--bounds-of-thing-at-point mt--to-thing))
           (to (mt-kill-bounds to-bs)))
      (goto-char (- (car (cdr from-sbs)) (length to)))
      ;; (undo-boundary)  ; <undo>
      (insert to)
      (goto-char (car to-bs))
      (mt-insert-rectangle from 1 column)
      (mt-push-mark (car from-sbs))
      (goto-char (car to-bs)))))
(advice-add 'mt-interchange-thing-up :around #'rollback-on-error-advice)

(defun mt-interchange-thing-down (arg)
  (let* ((column (current-column))
         (from-sbs (mt--bounds-of-thing-at-point-or-region mt--from-thing))
         (from (mt-kill-rectangle-or-bounds from-sbs)))
    (goto-char (car (cdr from-sbs)))
    (mt-forward-line (1- (length from)))
    (when (mt-newline-ending (car from))
      (cl-decf arg))
    (mt-down-thing arg column mt--to-thing)
    (let* ((to-bs (mt--bounds-of-thing-at-point mt--to-thing))
           (to (mt-kill-bounds to-bs)))
      (goto-char (car (cdr from-sbs)))
      ;; (undo-boundary)  ; <undo>
      (insert to)
      (let ((pos (+ (length to) (car to-bs))))
        (goto-char pos)
        (mt-insert-rectangle from 1 column)
        (mt-push-mark (car from-sbs))
        (goto-char pos)))))
(advice-add 'mt-interchange-thing-down :around #'rollback-on-error-advice)

(defun mt-interchange-thing-backward (arg)
  (let ((from-sbs (mt--bounds-of-thing-at-point-or-region mt--from-thing)))
    (goto-char (car (cdr from-sbs)))
    (mt-backward-thing arg mt--to-thing
                       (and (eq mt--to-thing 'sexp)
                            (let* ((pos (car (cdr from-sbs)))
                                   (delimiter (buffer-substring-no-properties
                                               pos (1+ pos))))
                              (if (member
                                   delimiter
                                   '("\"" "'" "(" "{" "["))
                                  delimiter
                                "[^\"'({[]"))))
    (let* ((to-bs (mt--bounds-of-thing-at-point mt--to-thing))
           (from (mt-kill-rectangle-or-bounds from-sbs))
           (to (mt-kill-bounds to-bs)))
      (goto-char (- (car (cdr from-sbs)) (length to)))
      ;; (undo-boundary)  ; <undo>
      (insert to)
      (goto-char (car to-bs))
      (mt-insert-rectangle from 1)
      (mt-push-mark (car from-sbs))
      (goto-char (car to-bs)))))
(advice-add 'mt-interchange-thing-backward :around #'rollback-on-error-advice)

(defun mt-interchange-thing-forward (arg)
  (let* ((from-sbs (mt--bounds-of-thing-at-point-or-region mt--from-thing))
         (from (mt-kill-rectangle-or-bounds from-sbs)))
    (goto-char (car (cdr from-sbs)))
    (goto-char (car (mt-forward-thing arg mt--to-thing
                                      (and (eq mt--to-thing 'sexp)
                                           (let ((delimiter (substring (car from) 0 1)))
                                             (if (member
                                                  delimiter
                                                  '("\"" "'" "(" "{" "["))
                                                 delimiter
                                               "[^\"'({[]"))))))
    (let* ((to-bs (mt--bounds-of-thing-at-point mt--to-thing))
           (to (mt-kill-bounds to-bs)))
      (goto-char (car (cdr from-sbs)))
      ;; (undo-boundary)  ; <undo>
      (insert to)
      (let ((pos (+ (length to) (car to-bs))))
        (goto-char pos)
        (mt-insert-rectangle from 1)
        (mt-push-mark (car from-sbs))
        (goto-char pos)))))
(advice-add 'mt-interchange-thing-forward :around #'rollback-on-error-advice)

(defun mt-shift-points-left (bounds)
  (let* ((strings (mapcar
                   (lambda (b)
                     (buffer-substring-no-properties (car b) (cdr b)))
                   bounds))
         (item (pop strings))
         (last-correction 0)
         (lengths (mapcar (lambda (b) (- (cdr b) (car b))) bounds))
         (paste-lengths (cons 0 (cdr lengths)))
         (cut-lengths (cons 0 lengths))
         (positions (cl-mapcar
                     (lambda (b c p)
                       (setq last-correction (+ last-correction
                                                (- p c)))
                       (+ (car b) last-correction))
                     bounds
                     cut-lengths
                     paste-lengths))
         (new-bounds (cl-mapcar
                      (lambda (p l)
                        (cons p (+ p l)))
                      positions
                      (nconc (cdr lengths) (list (car lengths))))))
    (setq strings (nreverse strings)
          bounds (nreverse bounds))
    (push item strings)
    (while strings
      (let ((bound (pop bounds)))
        (delete-region (car bound) (cdr bound))
        (goto-char (car bound))
        (insert (pop strings))))
    new-bounds))

(defun mt-shift-points-right (bounds)
  (let* ((strings (mapcar
                   (lambda (b)
                     (buffer-substring-no-properties (car b) (cdr b)))
                   bounds))
         (last-correnction 0)
         (lengths (mapcar (lambda (b) (- (cdr b) (car b))) bounds))
         (cut-lengths (cons 0 lengths))
         (final-lengths (cons (car (last lengths)) lengths))
         (paste-lengths (cons 0 final-lengths))
         (positions (cl-mapcar
                     (lambda (b c p)
                       (setq last-correnction (+ last-correnction
                                                 (- p c)))
                       (+ (car b) last-correnction))
                     bounds
                     cut-lengths
                     paste-lengths))
         (new-bounds (cl-mapcar
                      (lambda (p l)
                        (cons p (+ p l)))
                      positions
                      final-lengths)))
    (push (elt strings (1- (length strings))) strings)
    (setq strings (nreverse strings)
          bounds (nreverse bounds))
    (pop strings)
    (while strings
      (let ((bound (pop bounds)))
        (delete-region (car bound) (cdr bound))
        (goto-char (car bound))
        (insert (pop strings))))
    new-bounds))

(defun mt-shift-points (points arg)
  (let ((bounds
         (mapcar
          (lambda (pos)
            (goto-char pos)
            (mt--bounds-of-thing-at-point mt--from-thing))
          (sort points '<)))
        (neg (> 0 arg))
        listed-bounds)
    (mapc (lambda (x)
            (push (car x) listed-bounds)
            (push (cdr x) listed-bounds)) bounds)
    (if (not (sorted-p listed-bounds '>))
        (error "move-thing: %s's bounds overlap" mt--from-thing)
      (if neg
          (dotimes (i (- arg) bounds)
            (setq bounds (mt-shift-points-left bounds)))
        (dotimes (i arg bounds)
          (setq bounds (mt-shift-points-right bounds)))))))
(advice-add 'mt-shift-points :around #'rollback-on-error-advice)

;; ###
;;  #  #    # ##### ###### #####    ##    ####  ##### # #    # ######
;;  #  ##   #   #   #      #    #  #  #  #    #   #   # #    # #
;;  #  # #  #   #   #####  #    # #    # #        #   # #    # #####
;;  #  #  # #   #   #      #####  ###### #        #   # #    # #
;;  #  #   ##   #   #      #   #  #    # #    #   #   #  #  #  #
;; ### #    #   #   ###### #    # #    #  ####    #   #   ##   ######
(defun mt-cycle-things (arg)
  "Cycle things in ring."
  (interactive "P")
  (setq mt--mode-line-face 'mt--selected-face)
  (force-mode-line-update)
  (set-marker mt--marker (point))
  (if (or (eq last-command 'mt-cycle-things) arg)
      (if (not (eql mt--from-thing mt--to-thing))
          (while (not (eql mt--from-thing mt--to-thing))
            (mt--cycle-to-things))
        (let ((init-thing (ring-ref mt--from-thing-ring 0))
              current-thing found)
          (while (not (or found
                          (eql init-thing current-thing)))
            (setq found t
                  current-thing (mt--cycle-from-things))
            (condition-case nil
                (let ((bounds (mt--bounds-of-thing-at-point current-thing)))
                  (pulse-momentary-highlight-region (car bounds) (cdr bounds)))
              (error (set 'found nil))))))
    (condition-case nil
        (let ((bounds (mt--bounds-of-thing-at-point mt--from-thing)))
          (pulse-momentary-highlight-region (car bounds) (cdr bounds)))
      (error (mt-cycle-things t)))))

(defun mt-cycle-to-things ()
  (interactive)
  (mt--cycle-to-things)
  (force-mode-line-update))

(defun mt-toggle-interchange-things ()
  (interactive)
  (set-marker mt--marker nil)
  (setq mt--mode-line-face 'mt--unselected-face)
  (setq mt-interchange-things (not mt-interchange-things))
  (force-mode-line-update))

(defun mt-shift-mc-left (arg)
  (interactive "p")
  (mt-shift-mc-right (- arg)))

(defun mt-shift-mc-right (arg)
  (interactive "p")
  (let* ((bounds (mt-shift-points
                 (cons (point)
                       (mapcar
                        (lambda (x)
                          (overlay-get x 'point))
                        (mc/all-fake-cursors)))
                 arg))
         (bound (pop bounds)))
    (mc/remove-fake-cursors)
    (dolist (b bounds)
      (goto-char (car b))
      (mc/create-fake-cursor-at-point))
    (goto-char (car bound))))

(defun mt-move-down (arg)
  (interactive "p")
  (if mt-interchange-things
      (mt-interchange-thing-down arg)
    (mt-move-thing-down arg)))

(defun mt-move-up (arg)
  (interactive "p")
  (if mt-interchange-things
      (mt-interchange-thing-up arg)
    (mt-move-thing-up arg)))

(defun mt-move-right (arg)
  (interactive "p")
  (if mt-interchange-things
      (mt-interchange-thing-forward arg)
    (mt-move-thing-forward arg)))

(defun mt-move-left (arg)
  (interactive "p")
  (if mt-interchange-things
      (mt-interchange-thing-backward arg)
    (mt-move-thing-backward arg)))

(defun mt-up (arg)
  (interactive "p")
  (mt-up-thing arg))

(defun mt-down (arg)
  (interactive "p")
  (mt-down-thing arg))

(defun mt-backward (arg)
  (interactive "p")
  (mt-backward-thing arg))

(defun mt-forward (arg)
  (interactive "p")
  (mt-forward-thing arg))

;; (defun push-mark--pre-command ()
;;   (when (and (null mark-active)
;;              (gethash this-original-command mt-movement-commands)
;;              (not (gethash last-command mt-movement-commands)))
;;     (push-mark nil t)))
;; (add-hook 'pre-command-hook 'push-mark--pre-command)
#+end_src

*** Multiple windows

#+begin_src elisp
;; (defvar multiple-windows-mode-map
;;   (let (map (make-keymap))
;;     (set-char-table-range (nth 1 map) t #'multiple-windows--keypressed)
;;     (define-key map [escape] #'multiple-windows-mode)
;;     map))

(defvar multiple-windows--isearch-direction nil
  "Last isearch direction")

(defvar multiple-windows--default-cmds-prepare-alist
  '((isearch-forward . (setq multiple-windows--isearch-direction 'forward))
    (isearch-backward . (setq multiple-windows--isearch-direction 'backward))))

(defvar multiple-windows--default-cmds-remap-alist
  `((isearch-exit . ,(lambda ()
                       (interactive)
                       (isearch-repeat multiple-windows--isearch-direction))))
  "Default set of commands that should be mirrored by all cursors")

(defvar multiple-windows--default-cmds-to-run-for-all
  '(mc/keyboard-quit
    self-insert-command
    quoted-insert
    previous-line
    next-line
    newline
    newline-and-indent
    open-line
    delete-blank-lines
    transpose-chars
    transpose-lines
    transpose-paragraphs
    transpose-regions
    join-line
    right-char
    right-word
    forward-char
    forward-word
    left-char
    left-word
    backward-char
    backward-word
    forward-paragraph
    backward-paragraph
    upcase-word
    downcase-word
    capitalize-word
    forward-list
    backward-list
    hippie-expand
    hippie-expand-lines
    yank
    yank-pop
    append-next-kill
    kill-line
    kill-region
    kill-whole-line
    kill-word
    backward-kill-word
    backward-delete-char-untabify
    delete-char delete-forward-char
    delete-backward-char
    py-electric-backspace
    c-electric-backspace
    org-delete-backward-char
    cperl-electric-backspace
    python-indent-dedent-line-backspace
    paredit-backward-delete
    autopair-backspace
    just-one-space
    zap-to-char
    end-of-buffer
    end-of-defun
    end-of-line
    end-of-sexp
    set-mark-command
    exchange-point-and-mark
    cua-set-mark
    cua-replace-region
    cua-delete-region
    move-end-of-line
    beginning-of-buffer
    beginning-of-defun
    beginning-of-line
    beginning-of-sexp
    move-beginning-of-line
    kill-ring-save
    back-to-indentation
    subword-forward
    subword-backward
    subword-mark
    subword-kill
    subword-backward-kill
    subword-transpose
    subword-capitalize
    subword-upcase
    subword-downcase
    er/expand-region
    er/contract-region
    smart-forward
    smart-backward
    smart-up
    smart-down
    undo-tree-redo
    undo-tree-undo)
  "Default set of commands that should be mirrored by all cursors")

(defun multiple-windows--post-command ()
  (let ((prepare (alist-get this-original-command
                            multiple-windows--default-cmds-prepare-alist)))
    (if prepare (eval prepare)))
  (catch 'break
    (let ((cmd (or (alist-get this-original-command
                              multiple-windows--default-cmds-remap-alist)
                   (car (memq this-original-command
                              multiple-windows--default-cmds-to-run-for-all))
                   (throw 'break nil))))
      (save-selected-window
        (dolist (other-window (cdr (window-list (selected-frame) 0 (selected-window))))
          (select-window other-window)
          (condition-case-unless-debug raised-error
              (call-interactively cmd)
            (error (message "%s: %s %s"
                            cmd
                            (error-message-string raised-error)
                            other-window))))))))

(define-minor-mode multiple-windows-mode
  "Toggle Multiple Windows mode.
     With no argument, this command toggles the mode.
     Non-null prefix argument turns on the mode.
     Null prefix argument turns off the mode."
  :init-value nil
  :lighter "*"
  :group 'multiple-windows
  (if multiple-windows-mode
      (add-hook 'post-command-hook 'multiple-windows--post-command nil t)
    (remove-hook 'post-command-hook 'multiple-windows--post-command t)))
#+end_src

*** /smerge/

#+begin_src elisp
;; SMerge hydra menu
(with-eval-after-load 'hydra
  (eval-when-compile
    (require 'smerge-mode))
  (defhydra hydra-smerge
    (:foreign-keys run :hint nil :pre (smerge-mode 1))
    "
^Move^     ^Keep^     ^Diff^       ^Pair^
^^^^^^^^---------------------------------------------
_C-n_ext   _C-b_ase   _C-r_efine   _C-<_: base-upper
_C-p_rev   _C-u_pper  _C-e_diff    _C-=_: upper-lower
^   ^      _C-l_ower  _C-c_ombine  _C->_: base-lower
^   ^      _C-a_ll    _C-r_esolve
"
    ("C-RET" smerge-keep-current "current")
    ("C-c"   smerge-combine-with-next)
    ("C-e"   smerge-ediff)
    ("C-r"   smerge-refine)
    ("C-a"   smerge-keep-all)
    ("C-b"   smerge-keep-base)
    ("C-u"   smerge-keep-upper)
    ("C-n"   smerge-next)
    ("C-l"   smerge-keep-lower)
    ("C-p"   smerge-prev)
    ("C-r"   smerge-resolve)
    ("C-<"   smerge-diff-base-upper)
    ("C-="   smerge-diff-upper-lower)
    ("C->"   smerge-diff-base-lower)
    ("M-q" nil "quit"))

  (global-set-key (kbd "C-x v m") #'hydra-smerge/body))
#+end_src

*** /hi-lock/

#+begin_src elisp
(require 'hi-lock)
(setq minor-mode-alist (assq-delete-all 'hi-lock-mode minor-mode-alist))
(setcdr hi-lock-map nil)

(setq hi-lock-highlight-range 200000)
;;;;;;;;;;;
;; Faces ;;
;;;;;;;;;;;
(defface hi-yellow-b
  '((((min-colors 88)) (:weight bold :foreground "yellow1"))
    (t (:weight bold :foreground "yellow")))
  "Face for hi-lock mode."
  :group 'hi-lock-faces)

(defface hi-yellow-l
  '((((min-colors 88)) (:weight light :foreground "yellow1"))
    (t (:weight light :foreground "yellow")))
  "Face for hi-lock mode."
  :group 'hi-lock-faces)

(defface hi-magenta-b
  '((((min-colors 88)) (:weight bold :foreground "magenta1"))
    (t (:weight bold :foreground "magenta")))
  "Face for hi-lock mode."
  :group 'hi-lock-faces)

(defface hi-magenta-l
  '((((min-colors 88)) (:weight light :foreground "magenta1"))
    (t (:weight light :foreground "magenta")))
  "Face for hi-lock mode."
  :group 'hi-lock-faces)

(defface hi-blue-l
  '((((min-colors 88)) (:weight light :foreground "blue1"))
    (t (:weight light :foreground "blue")))
  "Face for hi-lock mode."
  :group 'hi-lock-faces)

(defface hi-green-l
  '((((min-colors 88)) (:weight light :foreground "green1"))
    (t (:weight light :foreground "green")))
  "Face for hi-lock mode."
  :group 'hi-lock-faces)

(defface hi-red-l
  '((((min-colors 88)) (:weight light :foreground "red1"))
    (t (:weight light :foreground "red")))
  "Face for hi-lock mode."
  :group 'hi-lock-faces)

;;;;;;;;;;;;;;;
;; Functions ;;
;;;;;;;;;;;;;;;
(require 'pulse)
(setq pulse-flag t)
(defun pulse-momentary-highlight-current-line (delay)
  (interactive (list 1.2))
  (let ((pulse-delay (/ delay pulse-iterations)))
    (pulse-momentary-highlight-one-line (point))))


(defun hl-smaller-5 ()
  "Highlight nunbers smaller than 5."
  (interactive)
  (highlight-regexp " [0-4]\\.[0-9]* " 'hi-red-b))

(defun unhl-smaller-5 ()
  "Unhighlight nunbers smaller than 5."
  (interactive)
  (unhighlight-regexp " [0-4]\\.[0-9]* "))

(defun hl-advices ()
  "Highlight advices."
  (interactive)
  (highlight-regexp "\\_<error\\_>" 'hi-red-b)
  (highlight-regexp "\\_<warn\\_>" 'hi-yellow-b)
  (highlight-regexp "\\_<warning\\_>" 'hi-yellow-b)
  (highlight-regexp "\\_<debug\\_>" 'hi-green-l)
  (highlight-regexp "\\_<info\\_>" 'hi-blue-l)
  (highlight-regexp "\\_<information\\_>" 'hi-blue-l)
  (highlight-regexp "\\_<assertion\\_>" 'hi-yellow)
  (highlight-regexp "\\_<ERROR\\_>" 'hi-red-b)
  (highlight-regexp "\\_<WARN\\_>" 'hi-yellow-b)
  (highlight-regexp "\\_<WARNING\\_>" 'hi-yellow-b)
  (highlight-regexp "\\_<DEBUG\\_>" 'hi-green-l)
  (highlight-regexp "\\_<INFO\\_>" 'hi-blue-l)
  (highlight-regexp "\\_<INFORMATION\\_>" 'hi-blue-l)
  (highlight-regexp "\\_<ASSERTION\\_>" 'hi-yellow))

(defun unhl-advices ()
  "Unhighlight advices."
  (interactive)
  (unhighlight-regexp "\\_<error\\_>")
  (unhighlight-regexp "\\_<warn\\_>")
  (unhighlight-regexp "\\_<warning\\_>")
  (unhighlight-regexp "\\_<debug\\_>")
  (unhighlight-regexp "\\_<info\\_>")
  (unhighlight-regexp "\\_<information\\_>")
  (unhighlight-regexp "\\_<assertion\\_>")
  (unhighlight-regexp "\\_<ERROR\\_>")
  (unhighlight-regexp "\\_<WARN\\_>")
  (unhighlight-regexp "\\_<WARNING\\_>")
  (unhighlight-regexp "\\_<DEBUG\\_>")
  (unhighlight-regexp "\\_<INFO\\_>")
  (unhighlight-regexp "\\_<INFORMATION\\_>")
  (unhighlight-regexp "\\_<ASSERTION\\_>"))

(defun hl-apirest ()
  (interactive)
  (highlight-regexp "\\_<GET\\_>" 'hi-green-b)
  (highlight-regexp "\\_<POST\\_>" 'hi-green-b)
  (highlight-regexp "\\_<PUT\\_>" 'hi-green-b)
  (highlight-regexp "\\_<PATCH\\_>" 'hi-green-b)
  (highlight-regexp "\\_<DELETE\\_>" 'hi-green-b))

(defun unhl-apirest ()
  (interactive)
  (unhighlight-regexp "\\_<GET\\_>")
  (unhighlight-regexp "\\_<POST\\_>")
  (unhighlight-regexp "\\_<PUT\\_>")
  (unhighlight-regexp "\\_<PATCH\\_>")
  (unhighlight-regexp "\\_<DELETE\\_>"))

(defun hl-ip ()
  (interactive)
  (highlight-regexp "[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}" 'hi-magenta-l))

(defun unhl-ip ()
  (interactive)
  (unhighlight-regexp "[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}"))

;; datetime
(defvar hl-datetime-today-last nil)
(make-variable-buffer-local 'hl-datetime-today-last)

(defun hl-datetime ()
  "Highlight today date."
  (interactive)
  (highlight-regexp "[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]" 'hi-yellow-l)
  (let ((date (format-time-string "%Y-%m-%d")))
    (if hl-datetime-today-last
        (unless (string-equal date hl-datetime-today-last)
          (unhighlight-regexp hl-datetime-today-last)
          (setq hl-datetime-today-last date))
      (setq hl-datetime-today-last date)))
  (highlight-regexp hl-datetime-today-last 'hi-yellow-b)
  (highlight-regexp "[0-9][0-9]:[0-9][0-9]:[0-9][0-9]" 'hi-yellow-l))

(defun unhl-datetime ()
  "Highlight today date."
  (interactive)
  (if hl-datetime-today-last
      (unhighlight-regexp hl-datetime-today-last))
  (unhighlight-regexp "[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]")
  (unhighlight-regexp "[0-9][0-9]:[0-9][0-9]:[0-9][0-9]"))

(defun hl-log ()
  (interactive)
  (hl-ip)
  (hl-advices)
  (hl-datetime)
  (hl-apirest))

(defun unhl-log ()
  (interactive)
  (unhl-ip)
  (unhl-advices)
  (unhl-datetime)
  (unhl-apirest))
#+end_src

*** CANC /hl-line+/
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
;; [ conflict with objed with (setq objed-use-hl nil)
(require 'hl-line+)
;; ]
(hl-line-when-idle-interval 0.3)
(toggle-hl-line-when-idle 1)
#+end_src

*** /hl-line/

#+begin_src elisp
(require 'hl-line)

;; (set-face-attribute 'hl-line nil
;;                     :foreground 'unspecified
;;                     :background "#000000"
;;                     :overline 'unspecified
;;                     :underline 'unspecified
;;                     :box 'unspecified
;;                     :inherit 'unspecified)

;; (face-spec-set 'hl-line
;;                '((((background light))
;;                   :inherit unspecified
;;                   :background "#ffffff")  ; looks OK on tty (becomes cyan)
;;                  (((background dark))
;;                   :inherit unspecified
;;                   :background "#000000")  ; looks OK on tty (becomes blue)
;;                  ))

(face-spec-set 'hl-line
               `((((supports :underline t))
                  :inherit unspecified
                  :underline t
                  :foreground "gray60"
                  :extend t)
                 (((supports :box t))
                  :inherit unspecified
                  :box (:line-width ,(if (>= emacs-major-version 28) '(-1 . -1) -1) :color "grey35")
                  :extend t)
                 (((supports :weight bold :slant italic))
                  :inherit unspecified
                  :weight bold :slant italic
                  :extend t)))

(setq global-hl-line-sticky-flag t
      hl-line-range-function
      (lambda ()
        (unless (and (eq major-mode 'vterm-mode)
                     (null vterm-copy-mode))
            (let ((pos (let* ((p (save-excursion (end-of-visual-line) (point)))
                              (ovs (delq global-hl-line-overlay
                                         (delq hl-line-overlay (overlays-at p)))))
                         (if ovs
                             (apply 'max (mapcar 'overlay-end ovs))
                           p))))
              (cons pos (1+ pos)))))
      ;; hl-line-face 'bold-italic
      )

(global-hl-line-mode 1)
#+end_src

*** /whitespace/

#+begin_src elisp
(defun whitespace-case-mode-configuration ()
  (interactive)
  (cond
   ;; ‘mode-name’
   ;; Usually a string, but can use any of the constructs for
   ;; ‘mode-line-format’, which see.
   ;; Format with ‘format-mode-line’ to produce a string value.
   ;; Don't use ‘string-equal’ to compare
   ((derived-mode-p 'c-mode)
    (set (make-local-variable 'whitespace-line-column) 100)
    (setq tab-width 4))
   ((derived-mode-p 'python-mode)
    (set (make-local-variable 'whitespace-line-column) 79)
    (setq tab-width 4))
   ((derived-mode-p 'emacs-lisp-mode)
    (set (make-local-variable 'whitespace-line-column) 100)
    (set (make-local-variable 'whitespace-display-mappings)
         '((newline-mark 10   [8629 10] [36 10])
           (tab-mark     9    [8676 32 32 32 32 32 8677 32] [92 9])))
    (setq tab-width 8))
   ((derived-mode-p 'json-mode)
    (setq tab-width 2))
   (t
    (setq tab-width 4)))
  (whitespace-mode))
(add-hook 'prog-mode-hook #'whitespace-case-mode-configuration)
(add-hook 'csv-mode-hook #'whitespace-mode)

(defun whitespace-toggle-lines-tail ()
  (interactive)
  (if (bound-and-true-p whitespace-mode)
      (call-interactively #'whitespace-mode))
  (if (memq 'lines-tail whitespace-style)
      (setq whitespace-style (delq 'lines-tail whitespace-style))
    (push 'lines-tail whitespace-style))
  (call-interactively #'whitespace-mode))


;; ·  183   MIDDLE DOT
;; ¶  182   PILCROW SIGN
;; ↵  8629  DOWNWARDS ARROW WITH CORNER LEFTWARDS
;; ↩  8617  LEFTWARDS ARROW WITH HOOK
;; ⏎  9166  RETURN SYMBOL
;; ▷  9655  WHITE RIGHT POINTING TRIANGLE
;; ▶  9654  BLACK RIGHT-POINTING TRIANGLE
;; →  8594  RIGHTWARDS ARROW
;; ↦  8614  RIGHTWARDS ARROW FROM BAR
;; ⇤  8676  LEFTWARDS ARROW TO BAR
;; ⇥  8677  RIGHTWARDS ARROW TO BAR
;; ⇨  8680  RIGHTWARDS WHITE ARROW
(eval-and-when-daemon frame
  (setq whitespace-style '(face
                           tab
                           newline
                           tab-mark
                           newline-mark
                           ;; spaces
                           )
        ;; whitespace-space-regexp "\\( \\{2,\\}\\)"
        ;; whitespace-hspace-regexp "\\(\xA0\\{2,\\}\\)"
        whitespace-display-mappings
        '(;; (space-mark   ?\    [?.])
          ;; (space-mark   ?\xA0 [?_])
          (newline-mark 10    [8629 10] [36 10])
          (tab-mark     9     [8676 32 8677 32] [92 9]))))
(with-eval-after-load 'whitespace
  (dolist (mode '(whitespace-mode
                  global-whitespace-mode
                  global-whitespace-newline-mode
                  whitespace-newline-mode))
    (setq minor-mode-alist (assq-delete-all mode minor-mode-alist)))
  (set-face-attribute 'whitespace-space nil
                      :foreground 'unspecified
                      :background "grey40")
  (set-face-attribute 'whitespace-hspace nil
                      :foreground 'unspecified
                      :background "grey50"))

(defun whitespace-toggle-marks ()
  (interactive)
  (if (bound-and-true-p whitespace-mode)
      (call-interactively #'whitespace-mode))
  (if (member '(newline-mark 10   [36 10]) whitespace-display-mappings)
      (setq whitespace-display-mappings
            '((newline-mark 10   [8629 10] [36 10])
              (tab-mark     9    [8676 32 8677 32] [92 9])))
    (setq whitespace-display-mappings
          '((newline-mark 10   [36 10])
            (tab-mark     9    [46 95 46 32]))))
  (call-interactively #'whitespace-mode))

(global-set-key (kbd "M-s 7 l") #'whitespace-toggle-lines-tail)
(global-set-key (kbd "M-s 7 SPC") #'whitespace-toggle-marks)
#+end_src

*** /display-line-numbers/

#+begin_src elisp
;; [ expensive
(add-hook 'prog-mode-hook #'display-line-numbers-mode)
;; ]
(with-eval-after-load 'display-line-numbers
  (setq line-number-display-limit large-file-warning-threshold
        line-number-display-limit-width 3000
        display-line-numbers-width-start t
        ;; t is expensive
        display-line-numbers-grow-only nil
        ;; 'visual is very expensive
        display-line-numbers-type 'relative)

  (defvar display-line-type-selected-last-buffer nil)
  (defun display-line-type-by-selected (_window-or-frame)
    (when (buffer-live-p display-line-type-selected-last-buffer)
      (with-current-buffer display-line-type-selected-last-buffer
        (setq display-line-numbers t))
      (setq display-line-type-selected-last-buffer nil))
    (when (and display-line-numbers-mode
               (derived-mode-p 'prog-mode))
      (unless (eq display-line-numbers display-line-numbers-type)
        (setq display-line-numbers display-line-numbers-type))
      (setq display-line-type-selected-last-buffer (current-buffer))))
  (add-hook 'window-selection-change-functions 'display-line-type-by-selected)

  (defun display-line-numbers-cycle ()
    (interactive)
    (cond ((null display-line-numbers)
           (display-line-numbers-mode 1)
           (message "Display line numbers absolute"))
          ((eq display-line-numbers t)
           (setq display-line-numbers 'relative)
           (message "Display line numbers relative"))
          ((eq display-line-numbers 'relative)
           (setq display-line-numbers 'visual)
           (message "Display line numbers visual"))
          ((eq display-line-numbers 'visual)
           (display-line-numbers-mode -1)
           (message "Display line numbers disabled"))))
  (global-set-key (kbd "C-c l") 'display-line-numbers-cycle))
#+end_src

*** /symon-mode/

#+begin_src elisp
(eval-and-compile
  (require 'symon))
;; (defun message-advice (orig-fun format-string &rest args)
;;   (if format-string
;;       (apply orig-fun format-string args)))
;; (advice-add #'message :around 'message-advice)

;; (defvar symon--minibuffer-window
;;   (minibuffer-window (car exwm-workspace--list)))
;; (defun symon-message-trick (format-string &rest args)
;;   (if (not (cdr exwm-workspace--list))
;;       (apply #'message format-string args)
;;     (if (null symon--minibuffer-window)
;;         (setq symon--minibuffer-window
;;               (minibuffer-window (car exwm-workspace--list))))
;;     (with-selected-window symon--minibuffer-window
;;       (delete-region (minibuffer-prompt-end) (point-max))
;;       (insert (apply #'format-message format-string args)))))

(defvar symon--datetime-monitor-pulse nil)
(defun symon-custom-datetime ()
  (if (setq symon--datetime-monitor-pulse
            (null symon--datetime-monitor-pulse))
      (concat
       (format-time-string "%e %b %H")
       (propertize ":"
                   'face '(:foreground "green"))
       (format-time-string "%M "))
    (format-time-string "%e %b %H:%M ")))

(defvar symon-custom-monitor-list
  '(symon-custom-datetime))
(define-symon-monitor symon-custom-monitor
  :interval 10
  :display (mapconcat 'funcall symon-custom-monitor-list " "))

(setcdr (last symon-monitors)
        `(,(cond ((memq system-type '(gnu/linux cygwin))
                  'symon-linux-battery-monitor)
                 ((memq system-type '(darwin))
                  'symon-darwin-battery-monitor)
                 ((memq system-type '(windows-nt))
                  'symon-windows-battery-monitor))))
(push 'symon-custom-monitor symon-monitors)

(with-eval-after-load 'org-clock
  (defun symon-custom-clock-in ()
    (if org-clock-mode-line-timer
        org-mode-line-string
      ""))
  (push 'symon-custom-clock-in symon-custom-monitor-list))

(with-eval-after-load 'virtualenvwrapper
  (defun symon-custom-virtualenv ()
    (if (and venv-current-name
             (not (string-empty-p venv-current-name)))
        (concat "["
                (propertize venv-current-name 'face 'mode-line-correct)
                "]")
      ""))
  (push 'symon-custom-virtualenv symon-custom-monitor-list))

(defun after-exwm-config:tmp ()
  (defun symon-custom-recording ()
    (if (and exwm-record-process
                      (eq 'run (process-status exwm-record-process)))
        exwm-record-recording
      ""))
  (push 'symon-custom-recording symon-custom-monitor-list))

(setq symon-refresh-rate 4
      symon-sparkline-type 'bounded
      symon-sparkline-thickness 1
      symon-history-size 24
      symon-sparkline-width 24
      symon-total-spark-width 13)

;;(add-hook last-startup-hook 'symon-mode 91)
#+end_src

*** Language tools

#+begin_src elisp
(defvar language-url-builder #'language-url-wordreference)
(defvar language-phonemic-script-regex ">/\\([^/]*\\)/<")
(defvar language-translation-regex-wordreference "class='ToWrd' >\\([^<]*\\)<")
(defvar language-items-number 6)

(defun decode-coding-string-to-current (string)
  "Decode STRING to buffer file codings system."
  (decode-coding-string string buffer-file-coding-system))

(defun language-url-wordreference (word &optional from to)
  "Build url request for WORD translation from language FROM to language TO."
  (if to
      (if (string-equal from "en")
          (format "http://www.wordreference.com/%s/translation.asp?tranword=%s" to word)
        (format "http://www.wordreference.com/%s/%s/translation.asp?tranword=%s" from to word))
    (cond
     ((string-equal from "es")
      (concat "http://www.wordreference.com/definicion/" word))
     (t
      (concat "http://www.wordreference.com/definition/" word)))))

(defun language-url-request-to-buffer (word &optional from to)
  "Synchronous request translation of WORD from language FROM to language TO."
  (url-retrieve-synchronously
       (funcall language-url-builder word from to)))

(defun language-get-phonemic-script (word &optional from)
  "Get phonemic script of WORD in language FROM."
  (with-current-buffer
      (language-url-request-to-buffer word from)
    (goto-char (point-min))
    (if (re-search-forward language-phonemic-script-regex nil t)
        (match-string 1)
      (error "Phonemic script not found"))))

(defun language-get-translation (word from to &optional items)
  "Get items posible translations of WORD from FROM to TO.
If no ITEMS `language-items-number'."
  (with-current-buffer
      (language-url-request-to-buffer word from to)
    (goto-char (point-min))
    (let ((matches ())
          (items-number (or items language-items-number)))
      (while (and (re-search-forward language-translation-regex-wordreference nil t)
                  (< 0 items-number))
        (let ((item (string-trim (match-string 1))))
          (unless (member item matches)
            (cl-decf items-number)
            (push item matches))))
      (if matches
          (nreverse matches)
        (error "Translation not found")))))

;; (require 'subr-x)
;; (defun language-get-phonemic-script-and-translation (word from to &optional items)
;;   "Get ITEMS posible translations of WORD from FROM to TO, with phonemic script."
;;   (with-current-buffer
;;       (language-url-request-to-buffer word from to)
;;     (goto-char (point-min))
;;     (if (re-search-forward language-phonemic-script-regex nil t)
;;         (let ((matches ())
;;               (items-number (or items language-items-number))
;;               (phonemic-script (decode-coding-string (match-string 1) 'utf-8)))
;;           (while (and (re-search-forward language-translation-regex-wordreference nil t)
;;                       (< 0 items-number))
;;             (let ((item (string-trim (match-string 1))))
;;               (unless (member item matches)
;;                 (cl-decf items-number)
;;                 (push item matches))))
;;           (cons phonemic-script (nreverse matches)))
;;       (error "Phonemic script not found"))))

(defun language-goto-insertion-point ()
  "Goto proper insertion point."
  (let ((curr-char (char-after (point))))
    (condition-case-unless-debug nil
        (when (and curr-char
                   (memq (get-char-code-property curr-char 'general-category)
                         '(Ll Lu Lo Lt Lm Mn Mc Me Nl)))
          (right-word 1))
      (error nil))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Interactive functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;
(require 'thingatpt)
;;(mapconcat 'identity matches ", ")

(defun language-en-es-translation-at-point (&optional items)
  "Get ITEMS translations of the word at point.
By default insert it, with prefix display a message with it."
  (interactive "P")
  (cond
   ((or (equal items '(4))
        buffer-read-only)
    (let ((translation
           (language-get-translation
            (thing-at-point 'word 'no-properties) "en" "es" 3)))
      (message (mapconcat 'decode-coding-string-to-current
                          translation ", "))))
   (t
    (let ((translation
           (language-get-translation
            (thing-at-point 'word 'no-properties) "en" "es" items)))
      (language-goto-insertion-point)
      (insert
       (concat " "
               (mapconcat 'decode-coding-string-to-current
                          translation ", ")))))))

(defun language-en-es-phonemic-script-and-translation-at-point (&optional items)
  "Get the phonemic script and ITEMS translations of the word at point.
By default insert it, with prefix display a message with it."
  (interactive "P")
  (cond
   ((or (equal items '(4))
        buffer-read-only)
    (let ((translation
           `(,(language-get-phonemic-script (thing-at-point 'word 'no-properties)) .
             ,(language-get-translation
               (thing-at-point 'word 'no-properties) "en" "es" 3))))
      (message
       (concat "/"
               (decode-coding-string-to-current (car translation))
               "/ "
               (mapconcat 'decode-coding-string-to-current
                          (cdr translation) ", ")))))
   (t
    (let ((translation
           `(,(language-get-phonemic-script (thing-at-point 'word 'no-properties)) .
             ,(language-get-translation
               (thing-at-point 'word 'no-properties) "en" "es" items))))
      (language-goto-insertion-point)
      (insert
       (concat " /"
               (decode-coding-string-to-current (car translation))
               "/ "
               (mapconcat 'decode-coding-string-to-current
                          (cdr translation) ", ")))))))

(defun language-phonemic-script-at-point (&optional paren)
  "Get the phonemic script of the word at point.
By default insert it, with prefix display a message with it."
  (interactive "P")
  (cond
   ((or (equal paren '(4))
        buffer-read-only)
    (message
     (concat "/"
             (decode-coding-string-to-current
              (language-get-phonemic-script (thing-at-point 'word 'no-properties)))
             "/")))
   (t
    (let ((parenthesis (or paren "/")))
      (language-goto-insertion-point)
      (insert
       (concat " "
               parenthesis
               (decode-coding-string-to-current
                (language-get-phonemic-script (thing-at-point 'word 'no-properties)))
               parenthesis))))))

(defvar language-text-to-speak-process nil)
#+end_src

*** Transfer file

#+begin_src elisp
(defun vi-transfer-file (filepath &optional nokill)
  (interactive (list (buffer-file-name) current-prefix-arg))
  (if (and (stringp filepath)
           (file-exists-p filepath))
      (let ((terminal (or (executable-find "alacritty")
                          (executable-find "urxvt")
                          (executable-find "xterm"))))
        (if (null terminal)
            (message
             "Terminal not found, install `alacritty', `urxvt' or `xterm'")
          (start-process
           (concat "*vi " filepath "*") nil terminal "-e"
           "vi"
           (concat
            "+call cursor(" (number-to-string (line-number-at-pos))
            "," (number-to-string (1+ (current-column))) ")")
           filepath)
          (unless nokill
            (when-let ((buffer (find-buffer-visiting filepath)))
              (kill-buffer buffer)
              (when (< 1 (length (window-list)))
                (delete-window))))))
    (message "File not found: %s" filepath)))

(defun kak-transfer-file (filepath &optional nokill)
  (interactive (list (buffer-file-name) current-prefix-arg))
  (if (and (stringp filepath)
           (file-exists-p filepath))
      (let ((terminal (or (executable-find "alacritty")
                          (executable-find "urxvt")
                          (executable-find "xterm"))))
        (if (null terminal)
            (message
             "Terminal not found, install `alacritty', `urxvt' or `xterm'")
          (start-process
           (concat "*kak " filepath "*") nil terminal "-e"
           "kak"
           filepath
           (concat
            "+" (number-to-string (line-number-at-pos))
            ":" (number-to-string (1+ (current-column)))))
          (unless nokill
            (when-let ((buffer (find-buffer-visiting filepath)))
              (kill-buffer buffer)
              (when (< 1 (length (window-list)))
                (delete-window))))))
    (message "File not found: %s" filepath)))

(global-set-key (kbd "C-x C-RET") 'kak-transfer-file)
#+end_src

** Not always required
*** /tramp/

#+begin_src elisp
(with-eval-after-load 'tramp
  (setq password-cache t
        password-cache-expiry 3600
        auth-sources '((:source (expand-file-name "authinfo.gpg"
                                                  user-emacs-directory)))
        tramp-default-method "ssh"
        auth-source-save-behavior nil))
#+end_src

*** /recentf-mode/

#+begin_src elisp
(with-eval-after-load 'recentf
  (remove-hook 'find-file-hook 'recentf-startup:tmp)
  (fmakunbound 'recentf-startup:tmp)
  (add-hook 'delete-frame-functions
            (defun recentf-save-list-if-change (&rest _args)
              (interactive)
              (let ((list-hash
                     (secure-hash 'md5 (mapconcat 'identity recentf-list ""))))
                (unless (string-equal list-hash recentf-list-hash)
                  (recentf-save-list)
                  (setq recentf-list-hash list-hash)))))
  ;; (with-eval-after-load 'machine-config
  ;;   (cl-letf (((symbol-function 'sit-for)
  ;;              (lambda (secs))))
  ;;     (let ((tramp-message-show-message nil))
  ;;       (recentf-mode 1))))
  (defun recentf-remove-sudo-tramp-prefix (path)
    "Remove sudo from path.  Argument PATH is path."
    (if (null (string-match-p "\\`/[^/:]+:[^/:]*:" path)) ;; (tramp-tramp-file-p path)
        path
      (require 'tramp)
      (let ((tx (tramp-dissect-file-name path)))
        (pcase (tramp-file-name-method tx)
          ("sudo" (tramp-file-name-localname tx))
          ("docker" (if (featurep 'docker) path
                      (tramp-file-name-localname path)))
          (_ path)))))

  (defun local-file-exists-p (filename)
    (file-exists-p (recentf-remove-sudo-tramp-prefix filename)))

  (defun recentf-file-truename (filename)
    (let* ((local-file-name (recentf-remove-sudo-tramp-prefix filename))
           (local-file-truename (file-truename local-file-name)))
      (concat (substring filename 0 (- (length local-file-name))) local-file-truename)))

  (setq recentf-list-hash
        (secure-hash 'md5 (mapconcat 'identity recentf-list ""))
        recentf-max-saved-items 500
        recentf-max-menu-items 30
        recentf-exclude '("\\.emacs\\.d/elpa/.*\\.el\\'" "\\.el\\.gz\\'")
        recentf-filename-handlers '(recentf-file-truename
                                    abbreviate-file-name)
        recentf-keep '(local-file-exists-p)
        tool-bar-max-label-size 12
        recentf-auto-cleanup 'never
        tool-bar-style 'image)
  (recentf-mode)
  (recentf-cleanup))

(defvar recentf-history nil)
(defun completing-recentf-find-file (arg)
  "Show a list of recent files."
  (interactive "P")
  (require 'recentf)
  (--> recentf-list
    (mapcar #'substring-no-properties it)
    (mapcar #'abbreviate-file-name it)
    (cl-remove-duplicates it :test #'string-equal)
    (let ((minibuffer-completing-file-name t))
      (completing-read
       "Recent Files: "
       (lambda (string pred action)
         (if (eq action 'metadata)
             '(metadata (category . file))
           (complete-with-action action it string pred)))
       nil t nil 'recentf-history))
    (if arg (find-file-other-window it) (find-file it))))

(defun recentf-startup:tmp ()
  (require 'recentf)
  (recentf-track-opened-file))
(add-hook 'find-file-hook 'recentf-startup:tmp)


(global-set-key "\C-x\ \C-r" 'completing-recentf-find-file)
(global-set-key (kbd "C-x R") 'recentf-open-files)
#+end_src

*** /zone/

#+begin_src elisp
(with-eval-after-load 'zone
  (setq zone-programs [
                       zone-pgm-five-oclock-swan-dive
                       ]))
#+end_src

*** /dired/

#+begin_src elisp
(with-eval-after-load 'dired
  (defface dired-python
    '((((type w32 pc)) :inherit default)
      (t (:foreground "green")))
    "Python file face."
    :group 'dired-faces
    :version "22.1")

  (defface dired-php
    '((((type w32 pc)) :inherit default)
      (t (:foreground "blue")))
    "PHP file face."
    :group 'dired-faces
    :version "22.1")

  (defface dired-javascript
    '((((type w32 pc)) :inherit default)
      (t (:foreground "yellow")))
    "PHP file face."
    :group 'dired-faces
    :version "22.1")

  (dolist (face-type '((dired-python     . (".py" ".pyc" ".pyd" ".pyo"))
                       (dired-php        . (".php" ".phps" ".php5" ".phtml"))
                       (dired-javascipt  . (".json" ".js" ".jsx" ".ts" ".tsx"))))
    (setcdr
     (last dired-font-lock-keywords)
     (list
      `(eval .
             ;; It is quicker to first find just an extension, then go back to the
             ;; start of that file name.  So we do this complex MATCH-ANCHORED form.
             (list
              ,(concat "\\(" (regexp-opt (cdr face-type)) "\\|#\\)[*=|]?$")
              '(".+" (dired-move-to-filename) nil (0 (quote ,(car face-type))))))))))
#+end_src

*** /nxml/

#+begin_src elisp
(with-eval-after-load 'nxml-mode
  (defun xml-format (start end)
    "Format xml START END region or entire buffer."
    (interactive
     (if (use-region-p)
         (list (region-beginning) (region-end))
       (list (point-min) (point-max))))
    (if (executable-find "xmllint")
        (shell-command-on-region start end
                                 "xmllint --format -" t t)
      (error "Cannot find xmllint command")))

  (define-key nxml-mode-map (kbd "C-c x f") #'xml-format))
#+end_src

*** /ediff/

#+begin_src elisp
(with-eval-after-load 'ediff
  (add-hook 'ediff-after-quit-hook-internal 'winner-undo)

  (face-spec-set 'diff-refine-changed
                 '((((class color) (min-colors 88) (background light))
                    :background "#888833")
                   (((class color) (min-colors 88) (background dark))
                    :background "#555511")
                   (t :inverse-video t)))
  (face-spec-set 'ediff-odd-diff-A '((t (:background "dark slate gray"))))
  (face-spec-set 'ediff-odd-diff-B '((t (:background "dark slate gray"))))
  (face-spec-set 'ediff-odd-diff-C '((t (:background "dark slate gray"))))
  (face-spec-set 'ediff-even-diff-A '((t (:background "dim gray"))))
  (face-spec-set 'ediff-even-diff-B '((t (:background "dim gray"))))
  (face-spec-set 'ediff-even-diff-C '((t (:background "dim gray"))))
  (face-spec-set 'ediff-fine-diff-A '((t (:background "brown"))))
  (face-spec-set 'ediff-fine-diff-B '((t (:background "brown"))))
  (face-spec-set 'ediff-fine-diff-C '((t (:background "brown"))))
  (face-spec-set 'ediff-current-diff-A '((t (:foreground "White" :background "dark green"))))
  (face-spec-set 'ediff-current-diff-B '((t (:foreground "White" :background "dark green"))))
  (face-spec-set 'ediff-current-diff-C '((t (:foreground "White" :background "dark green"))))

  (setq-default ediff-forward-word-function 'forward-char)

  (setq ediff-window-setup-function 'ediff-setup-windows-plain
        ediff-split-window-function 'split-window-horizontally
        ediff-diff-ok-lines-regexp
        (eval-when-compile
          (concat
           "^\\("
           "[0-9,]+[acd][0-9,]+\C-m?$"
           "\\|[<>] "
           "\\|---"
           "\\|.*Warning *:"
           "\\|.*No +newline"
           "\\|.*missing +newline"
           "\\|^\C-m?$"
           "\\|.*No +hay +ning..?n +car..?cter +de +nueva +l..?nea +al +final +del"
           "\\)")))

  (require 'vdiff)
  (defun diff-revert-buffer-with-file (&optional arg)
    "Compare the current modified buffer with the saved version.
ARG - `C-u' differ with prompted file.
    - `C-u' `C-u' force revert."
    (interactive "P")
    (cond
     ((equal arg '(16))
      (revert-buffer))
     ((equal arg '(4))
      (let ((diff-switches "-u")) ;; unified diff
        (diff-buffer-with-file (current-buffer))))
     (t
      (vdiff-current-file))))

  (defun vdiff-hydra-or-diff (&optional arg)
    (interactive "P")
    (condition-case-unless-debug nil
        (call-interactively 'vdiff-hydra/body)
      (error
       (cond
        ((equal arg '(64))
         (call-interactively 'vdiff-files3))
        ((equal arg '(16))
         (call-interactively 'vdiff-buffers3))
        ((equal arg '(4))
         (call-interactively 'vdiff-files))
        (t
         (call-interactively 'vdiff-buffers)))
       (call-interactively 'vdiff-hydra/body)))))

(global-set-key (kbd "C-c d R") 'diff-revert-buffer-with-file)
(global-set-key (kbd "C-c d 3 f") 'vdiff-files3)
(global-set-key (kbd "C-c d m") 'vdiff-hydra-or-diff)
(global-set-key (kbd "C-c d f") 'vdiff-files)
(global-set-key (kbd "C-c d 3 b") 'vdiff-buffers3)
(global-set-key (kbd "C-c d b") 'vdiff-buffers)
#+end_src

*** /term/

#+begin_src elisp
(with-eval-after-load 'term
  (setq term-prompt-regexp "^"))
#+end_src

*** /shell/

#+begin_src elisp
(with-eval-after-load 'shell
  (message "Importing shell config")
  (setq shell-file-name "bash")
;;;;;;;;;;;;
;; Colors ;;
;;;;;;;;;;;;
  (setq comint-output-filter-functions
        (remove 'ansi-color-process-output comint-output-filter-functions))

  (add-hook 'shell-mode-hook
            (lambda ()
              (add-hook 'comint-preoutput-filter-functions 'xterm-color-filter
                        nil t)))
  (setenv "TERM" "xterm-256color")
;;;;;;;;;;;;;
;; Filters ;;
;;;;;;;;;;;;;
  ;; Make URLs clickable
  (add-hook 'shell-mode-hook (lambda () (goto-address-mode 1)))
  ;; Make file paths clickable
  (add-hook 'shell-mode-hook 'compilation-shell-minor-mode)
  ;; Update 'default-directory' parsing prompt
  (add-hook 'shell-mode-hook #'dirtrack-mode)

;;;;;;;;;;;;;
;; Options ;;
;;;;;;;;;;;;;
  (setq-default dirtrack-list '("\033\\[00;34m\\([^\033]+\\)" 1 nil))
  (require 'comint)
  (setq comint-scroll-to-bottom-on-input nil  ; always insert at the bottom
        comint-scroll-to-bottom-on-output nil ; always add output at the bottom
        comint-scroll-show-maximum-output nil ; scroll to show max possible output
        comint-completion-autolist t          ; show completion list when ambiguous
        comint-input-ignoredups t             ; no duplicates in command history
        comint-completion-addsuffix t         ; insert space/slash after file completion
        )
  (add-hook 'shell-mode-hook #'ansi-color-for-comint-mode-on)
  (add-to-list 'comint-output-filter-functions 'ansi-color-process-output)
  (set-face-attribute 'comint-highlight-prompt nil
                      :inherit nil)

;;;;;;;;;;;;;;;;;;;;;
;; Bash Completion ;;
;;;;;;;;;;;;;;;;;;;;;
  ;; Conflict with helm
  ;; (require 'bash-completion)
  ;; (bash-completion-setup)

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Variables de entorno ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Locales
  (setenv "LANG" "es_ES.UTF-8")
  (setenv "LC_ALL" "")
  (setenv "PROMPT_COMMAND" "")

;;;;;;;;;;;;;
;; execute ;;
;;;;;;;;;;;;;
  ;; (defun execute (dir)
  ;;   (interactive
  ;;    (list
  ;;     (let ((dir (and (bound-and-true-p execute-directory)
  ;;                     (eval execute-directory))))
  ;;      (if (or (not dir) current-prefix-arg)
  ;;          (read-string "Execute directory: " dir)
  ;;        dir))))
  ;;   (let ((default-directory dir))
  ;;     (compilation-start (read-string "Execute command: "
  ;;                                     (and (bound-and-true-p execute-command)
  ;;                                          (eval execute-command))))))
  (defvar execute-list '(compile execute test check config convert copy move next previous extern generate clean recompile build rebuild))

  (defun execute (&optional arg)
    (interactive "P")
    (let* ((pair-list (cl-remove-if-not
                       #'boundp
                       execute-list))
           (pair (eval (intern (completing-read "Execute: " pair-list nil t))))
           (default-directory (if current-prefix-arg
                                  (read-string "Execute directory: " (eval (cdr pair)))
                                (eval (cdr pair)))))
      (save-some-buffers arg)
      (compilation-start (read-string "Execute command: " (eval (car pair))))))

  (defvar insert-from-function-alist '(("git branches" . vc-git-branches)
                                       ("text to rotate" . rotate-text-symbols)))

  (defun insert-from-function (arg)
    (interactive "P")
    (let* ((choices (mapcar 'car insert-from-function-alist))
           (result (cdr (assoc (completing-read "Choose: "
                                                choices nil t)
                               insert-from-function-alist))))
      (while (not (stringp result))
        ;; (message "not string %s" result)
        (cond
         ((json-alist-p result)
          ;; (message "alist %s" result)
          (cond
           ((cl-every (lambda (x) (consp (cdr x))) result)
            ;; (message "list list %s" result)
            (setq choices (mapcar 'car result)
                  result (assoc (completing-read "Choose list: " choices nil t) result)))
           ((cl-every (lambda (x) (functionp (cdr x))) result)
            ;; (message "alist function %s" result)
            (setq choices (mapcar 'car result)
                  result (funcall (cdr (assoc (completing-read "Choose function: " choices nil t) result)))))
           (t
            ;; (message "alist ¿? %s" result)
            (setq choices (mapcar 'car result)
                  result (cdr (assoc (completing-read "Choose: " choices nil t) result))))))
         ((consp result)
          (cond
           ((cl-every #'stringp result)
            ;; (message "list strings %s" result)
            (setq result (completing-read "Text to insert: " result)))
           ((cl-every #'functionp result)
            ;; (message "list function %s" result)
            (setq result (completing-read "Choose function: " result nil t)))
           (t
            (error "Unknown type in list"))))
         ((functionp result)
          ;; (message "function %s" result)
          (setq result (funcall result)))
         ((symbolp result)
          ;; (message "symbol %s" result)
          (setq result (eval result)))
         (t
          (error "Unknown type"))))
      (if arg
          (kill-new result)
        (insert result))))

;;;;;;;;;;;;;;;
;; Funciones ;;
;;;;;;;;;;;;;;;
  ;; Sustituye:
  ;; '$p' por el nombre del buffer con su ruta.
  ;; '$n' por el nombre del buffer.
  ;; '$b' por el nombre del buffer sin extensión.
  (defun shell-execute (command &optional output-buffer error-buffer)
    (interactive
     (list
      (read-shell-command "Shell command: " nil nil
                          (let ((filename
                                 (cond
                                  (buffer-file-name)
                                  ((eq major-mode 'dired-mode)
                                   (dired-get-filename nil t)))))
                            (and filename (file-relative-name filename))))
      current-prefix-arg
      shell-command-default-error-buffer))
    (let ((command-replaced command)
          (replacements
           (append (list (cons "%n" (concat "\"" (buffer-name) "\"")))
                   (if buffer-file-name
                       (list (cons "%p" (concat "\"" buffer-file-name "\""))
                             (cons "%b" (concat "\"" (file-name-nondirectory buffer-file-name) "\""))))))
          (case-fold-search nil))
      (dolist (replacement replacements)
        (set 'command-replaced (replace-regexp-in-string
                                (regexp-quote (car replacement)) (cdr replacement)
                                command-replaced
                                t t)))
      (funcall 'shell-command command-replaced output-buffer error-buffer)))

  ;; fish-mode
  (add-hook 'fish-mode-hook (lambda ()
                              (add-hook 'before-save-hook 'fish_indent-before-save)))
  ;; fish-completion-mode
  (when (and (executable-find "fish")
             (require 'fish-completion nil t))
    (global-fish-completion-mode))

  (global-set-key (kbd "C-M-!") #'insert-from-function)
  (global-set-key (kbd "M-!") #'shell-execute)
  (global-set-key (kbd "M-s RET") #'shell-execute)
  (global-set-key (kbd "C-!") #'execute)

  (with-eval-after-load 'shell
    (require 'term)
    (define-key shell-mode-map (kbd "C-c C-k") #'term-char-mode)
    (define-key shell-mode-map (kbd "C-c C-j") #'term-line-mode))
  (define-key shell-mode-map (kbd "C-c C-l") 'helm-comint-input-ring)

  ;; (global-set-key (kbd "M-!") 'shell-execute)
  ;; (global-set-key (kbd "M-s RET") 'shell-execute)

  ;; ansi-term con utf-8
  ;; (defadvice ansi-term (after advise-ansi-term-coding-system)
  ;;     (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))
  ;; (ad-activate 'ansi-term)
  ;; another option
  ;; (add-hook 'term-exec-hook
  ;;           (function
  ;;            (lambda ()
  ;;              (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))))

  ;; Habilita colores en la terminal
  ;; (require 'ansi-color)
  ;; (defadvice display-message-or-buffer (before ansi-color activate)
  ;;   "Process ANSI color codes in shell output."
  ;;   (let ((buf (ad-get-arg 0)))
  ;;     (and (bufferp buf)
  ;;          (string= (buffer-name buf) "*Compilation Output*")
  ;;          (with-current-buffer buf
  ;;            (ansi-color-apply-on-region (point-min) (point-max))))))
  ;; (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
  ;; (add-to-list 'comint-output-filter-functions 'ansi-color-process-output)
  )
#+end_src

*** /eshell/

#+begin_src elisp
(defun eshell-vi-transfer-file (filepath &optional nokill)
  (interactive (list (buffer-file-name) current-prefix-arg))
  (cond ((and (stringp filepath)
              (file-exists-p filepath))
         (require 'em-term)
         (eshell-exec-visual
          "vi" (concat
                "+call cursor(" (number-to-string (line-number-at-pos))
                "," (number-to-string (1+ (current-column))) ")")
          filepath)
         (unless nokill
           (when-let ((buffer (find-buffer-visiting filepath)))
             (kill-buffer buffer))))
        (t
         (message "File not found: %s" filepath))))

(eval-when-compile (require 'pcomplete))
(with-eval-after-load 'esh-mode
  (message "Importing eshell config")

  (require 'pcomplete)
  (with-eval-after-load 'esh-module
    (add-to-list 'eshell-modules-list 'eshell-tramp))

;;;;;;;;;;;;
;; Colors ;;
;;;;;;;;;;;;
  (require 'em-prompt)
  (set-face-attribute 'eshell-prompt nil
                      :foreground "SeaGreen"
                      :background 'unspecified
                      :weight 'bold)

  (add-to-list 'eshell-preoutput-filter-functions 'xterm-color-filter)
  (setq eshell-output-filter-functions (remove 'eshell-handle-ansi-color eshell-output-filter-functions))
  (setenv "TERM" "xterm-256color")
;;;;;;;;;;;;;;;;;
;; Emacs Shell ;;
;;;;;;;;;;;;;;;;;
  (with-eval-after-load 'em-term
    (add-to-list 'eshell-visual-commands "apt")
    (add-to-list 'eshell-visual-commands "htop")
    (add-to-list 'eshell-visual-commands "atop")
    (add-to-list 'eshell-visual-commands "top")
    (add-to-list 'eshell-visual-commands "vim")
    (add-to-list 'eshell-visual-commands "nvim")
    (add-to-list 'eshell-visual-commands "nano")
    (add-to-list 'eshell-visual-commands "unison")
    (add-to-list 'eshell-visual-commands "hx")
    (add-to-list 'eshell-visual-commands "kak")
    (add-to-list 'eshell-visual-options '("git" "--help" "--paginate"))
    (add-to-list 'eshell-visual-subcommands '("git" "help" "log" "diff" "show" "reflog")))
  (setq eshell-prefer-lisp-functions nil
        eshell-prefer-lisp-variables nil
        eshell-destroy-buffer-when-process-dies nil
        eshell-cmpl-cycle-completions nil)

  (with-eval-after-load 'esh-var
    (setcdr (assoc "COLUMNS" eshell-variable-aliases-list)
            '((lambda (indices) (window-width-without-margin)) t)))

;;;;;;;;;;;;;;;;;;;;;;
;; Custom functions ;;
;;;;;;;;;;;;;;;;;;;;;;
  (defun eshell-send-chars-interactive-process ()
    (interactive)
    (let ((process (eshell-interactive-process)))
      (if process
          (let ((char (read-key "Char (C-c exits): ")))
            (while (and (not (char-equal ?\C-c char))
                        (setq process (eshell-interactive-process)))
              (process-send-string process (char-to-string char))
              (setq char (read-key "Char (C-c exits): "))))
        (message "Current buffer has no process"))))

  (defun start-process-stderr (name buffer program &rest program-args)
    "Start PROGRAM with PROGRAM-ARGS process NAME sending stdout to BUFFER.

This command send stderr to *stderr* buffer, not BUFFER."
    (unless (fboundp 'make-process)
      (error "Emacs was compiled without subprocess support"))
    (apply #'make-process
           (nconc (list :name name :buffer buffer :stderr (get-buffer-create "*stderr*"))
                  (if program
                      (list :command (cons program program-args))))))

  (defun start-file-process-stderr (name buffer program &rest program-args)
    "Start a program in a subprocess.  Return the process object for it.

NAME, BUFFER, PROGRAM, PROGRAM-ARGS same as `start-file-process'.

Only stdout sent to BUFFER, stderr sent to *stderr* buffer."
    (let ((fh (find-file-name-handler default-directory 'start-file-process-stderr)))
      (if fh (apply fh 'start-file-process-stderr name buffer program program-args)
        (apply 'start-process-stderr name buffer program program-args))))

  (defun eshell-gather-process-output-stderr (command args)
    "Gather the output from COMMAND + ARGS.

Only stdout sent to eshell buffer, stderr sent to *stderr* buffer."
    (require 'esh-var)
    (declare-function eshell-environment-variables "esh-var" ())
    (unless (and (file-executable-p command)
                 (file-regular-p (file-truename command)))
      (error "%s: not an executable file" command))
    (let* ((delete-exited-processes
            (if eshell-current-subjob-p
                eshell-delete-exited-processes
              delete-exited-processes))
           (process-environment (eshell-environment-variables))
           proc decoding encoding changed)
      (cond
       ((fboundp 'start-file-process-stderr)
        (setq proc
              (let ((process-connection-type
                     (unless (eshell-needs-pipe-p command)
                       process-connection-type))
                    (command (file-local-name (expand-file-name command))))
                (apply #'start-file-process-stderr
                       (file-name-nondirectory command) nil command args)))
        (eshell-record-process-object proc)
        (set-process-buffer proc (current-buffer))
        (set-process-filter proc (if (eshell-interactive-output-p)
                                     #'eshell-output-filter
                                   #'eshell-insertion-filter))
        (set-process-sentinel proc #'eshell-sentinel)
        (run-hook-with-args 'eshell-exec-hook proc)
        (when (fboundp 'process-coding-system)
          (let ((coding-systems (process-coding-system proc)))
            (setq decoding (car coding-systems)
                  encoding (cdr coding-systems)))
          ;; If start-process decided to use some coding system for
          ;; decoding data sent from the process and the coding system
          ;; doesn't specify EOL conversion, we had better convert CRLF
          ;; to LF.
          (if (vectorp (coding-system-eol-type decoding))
              (setq decoding (coding-system-change-eol-conversion decoding 'dos)
                    changed t))
          ;; Even if start-process left the coding system for encoding
          ;; data sent from the process undecided, we had better use the
          ;; same one as what we use for decoding.  But, we should
          ;; suppress EOL conversion.
          (if (and decoding (not encoding))
              (setq encoding (coding-system-change-eol-conversion decoding 'unix)
                    changed t))
          (if changed
              (set-process-coding-system proc decoding encoding))))
       (t
        ;; No async subprocesses...
        (let ((oldbuf (current-buffer))
              (interact-p (eshell-interactive-output-p))
              lbeg lend line proc-buf exit-status)
          (and (not (markerp eshell-last-sync-output-start))
               (setq eshell-last-sync-output-start (point-marker)))
          (setq proc-buf
                (set-buffer (get-buffer-create eshell-scratch-buffer)))
          (erase-buffer)
          (set-buffer oldbuf)
          (run-hook-with-args 'eshell-exec-hook command)
          (setq exit-status
                (apply #'call-process-region
                       (append (list eshell-last-sync-output-start (point)
                                     command t
                                     eshell-scratch-buffer nil)
                               args)))
          ;; When in a pipeline, record the place where the output of
          ;; this process will begin.
          (and (bound-and-true-p eshell-in-pipeline-p)
               (set-marker eshell-last-sync-output-start (point)))
          ;; Simulate the effect of the process filter.
          (when (numberp exit-status)
            (set-buffer proc-buf)
            (goto-char (point-min))
            (setq lbeg (point))
            (while (eq 0 (forward-line 1))
              (setq lend (point)
                    line (buffer-substring-no-properties lbeg lend))
              (set-buffer oldbuf)
              (if interact-p
                  (eshell-output-filter nil line)
                (eshell-output-object line))
              (setq lbeg lend)
              (set-buffer proc-buf))
            (set-buffer oldbuf))
          (require 'esh-mode)
          (declare-function eshell-update-markers "esh-mode" (pmark))
          (defvar eshell-last-output-end)         ;Defined in esh-mode.el.
          (eshell-update-markers eshell-last-output-end)
          ;; Simulate the effect of eshell-sentinel.
          (eshell-close-handles (if (numberp exit-status) exit-status -1))
          (eshell-kill-process-function command exit-status)
          (or (bound-and-true-p eshell-in-pipeline-p)
              (setq eshell-last-sync-output-start nil))
          (if (not (numberp exit-status))
              (error "%s: external command failed: %s" command exit-status))
          (setq proc t))))
      proc))

  (defun eshell-key-up (arg)
    (interactive "p")
    (if (eq (point)
            (point-max))
        (progn
          (if (not (memq last-command '(eshell-key-up
                                        eshell-key-down
                                        eshell-key-alt-previous
                                        eshell-key-alt-next)))
              ;; Starting a new search
              (setq eshell-matching-input-from-input-string
                    (buffer-substring (save-excursion (eshell-bol) (point))
                                      (point))
                    eshell-history-index nil))
          (eshell-previous-matching-input
           (concat "^" (regexp-quote eshell-matching-input-from-input-string))
           arg))
      (line-move-1 (- arg))))

  (defun eshell-key-down (arg)
    (interactive "p")
    (eshell-key-up (- arg)))

  (defun eshell-key-alt-previous (arg)
    (interactive "p")
    (if (eq (point)
            (point-max))
        (progn
          (if (not (memq last-command '(eshell-key-up
                                        eshell-key-down
                                        eshell-key-alt-previous
                                        eshell-key-alt-next)))
              ;; Starting a new search
              (setq eshell-matching-input-from-input-string
                    (buffer-substring (save-excursion (eshell-bol) (point))
                                      (point))
                    eshell-history-index nil))
          (eshell-previous-matching-input
           (concat "^" (regexp-quote eshell-matching-input-from-input-string))
           arg))
      (forward-paragraph (- arg))))

  (defun eshell-key-alt-next (arg)
    (interactive "p")
    (eshell-key-alt-previous (- arg)))

  (with-eval-after-load 'em-hist
    ;;;; OVERRIDDEN
    (defun eshell-put-history (input &optional ring at-beginning)
      "Put a new input line into the history ring."
      (unless ring (setq ring eshell-history-ring))
      (if at-beginning
          (if (or (ring-empty-p ring)
                  (not (string-equal input (ring-ref eshell-history-ring -1))))
              (ring-insert-at-beginning ring input))
        (if (or (ring-empty-p ring)
                (not (string-equal input (ring-ref eshell-history-ring 0))))
            (ring-insert ring input))))

    ;; eshell-next-input call this
    ;;;; OVERRIDDEN
    (defun eshell-previous-input (arg)
      "Cycle backwards through input history."
      (interactive "*p")
      (if (eq (point)
              (point-max))
          (eshell-previous-matching-input "." arg)
        (line-move-1 (- arg)))))

;;;;;;;;;;;;;;;
;; Functions ;;
;;;;;;;;;;;;;;;
  (defun eshell-send-input-rename ()
    (interactive)
    (end-of-buffer)
    (call-interactively 'eshell-send-input)
    (let ((proc-running (eshell-interactive-process)))
      (when proc-running
        (rename-buffer (format "*esh:%s>%s*"
                               (file-name-nondirectory (eshell/pwd))
                               (process-name proc-running)) t))))

  (defun eshell-send-input-rename-stderr ()
    "`eshell-send-input' but sending stderr to *stderr* buffer."
    (interactive)
    (cl-letf (((symbol-function 'eshell-gather-process-output)
               'eshell-gather-process-output-stderr))
      (call-interactively 'eshell-send-input))
    (let ((proc-running (eshell-interactive-process)))
      (when proc-running
        (rename-buffer (format "*esh:%s>%s*"
                               (file-name-nondirectory (eshell/pwd))
                               (process-name proc-running)) t))))
;;;;;;;;
;; ag ;;
;;;;;;;;
  (when (require 'ag nil 'noerror)
    (defun eshell/ag (&rest args)
      "Use Emacs grep facility instead of calling external grep."
      (ag/search (mapconcat #'shell-quote-argument args " ") default-directory)))
;;;;;;;;;;;;;
;; Filters ;;
;;;;;;;;;;;;;
  ;; Make URLs clickable & ag

  ;; Colorize advices
  ;; brute force...
  ;; (add-hook 'eshell-post-command-hook (lambda () (unhl-advices) (hl-advices)))

;;;;;;;;;;;;
;; Prompt ;;
;;;;;;;;;;;;
  (require 'dash)
  (require 's)
  (require 'vc-git)


  ;; pyvenv package
  (defvar pyvenv-virtual-env-name nil)
  ;; virtualenvwrapper package
  (defvar venv-current-name nil)

  (defvar eshell-current-command-start-time nil)
  ;; Below I implement a "prompt number" section
  (defvar esh-prompt-num 0)
  (add-hook 'eshell-mode-hook
            (lambda ()
              (set-default (make-local-variable 'esh-prompt-num) 0)
              (make-local-variable 'eshell-current-command-start-time)))

  (defun esh-prompt-func ()
    "Build `eshell-prompt-function'."
    (setq esh-prompt-num (cl-incf esh-prompt-num))
    (let ((prev-string? t))
      (-reduce-from (lambda (acc x)
                      (if (functionp x)
                          (--if-let (funcall x)
                              (if (null prev-string?)
                                  (concat acc esh-sep it)
                                (setq prev-string? nil)
                                (concat acc it))
                            acc)
                        (if (null prev-string?)
                            (setq prev-string? t))
                        (concat acc x)))
                    esh-header eshell-funcs)))

  (eval-when-compile
    (defmacro esh-section (NAME ICON FORM FACE)
      "Build eshell section NAME with ICON prepended to evaled FORM with PROPS."
      `(setq ,NAME
             (lambda ()
               (when ,FORM
                 (let ((text (concat ,ICON esh-section-delim ,FORM)))
                   (add-text-properties
                    0 (length text)
                    '(read-only t
                                font-lock-face ,FACE
                                front-sticky (font-lock-face read-only)
                                rear-nonsticky (font-lock-face read-only))
                    text)
                   text))))))

  (defface esh-dir
    '((t (:foreground "gold" :weight ultra-bold :underline t)))
    "EShell directory prompt face")
  (esh-section esh-dir
               (if (display-graphic-p) "📂" "δ")  ;  (faicon folder)
               (let ((name (eshell/pwd)))
                 (rename-buffer (format "*esh:%s*" (file-name-nondirectory name)) t)
                 (abbreviate-file-name name))
               esh-dir)

  (defface esh-git
    '((t (:foreground "pink")))
    "EShell git prompt face")
  (esh-section esh-git
               (if (display-graphic-p) "⎇" "β")  ;  (git icon)
               ;; (magit-get-current-branch)
               (car (vc-git-branches))
               esh-git)

  (defface esh-python
    '((t (:foreground "white")))
    "EShell python prompt face")
  (esh-section esh-python
               (if (display-graphic-p) "⛶" "π")  ;  (python icon)
               (or pyvenv-virtual-env-name venv-current-name)
               esh-python)

  (defface esh-clock
    '((t (:foreground "forest green")))
    "EShell clock prompt face")
  (esh-section esh-clock
               (if (display-graphic-p) "⏳" "τ")  ;  (clock icon)
               (format-time-string "%H:%M" (current-time))
               esh-clock)

  (defface esh-user
    '((t (:foreground "deep sky blue")))
    "EShell user prompt face")
  (esh-section esh-user
               (if (display-graphic-p) "👤" "υ")
               (eshell-user-name)
               esh-user)

  (defface esh-sysname
    '((t (:foreground "firebrick")))
    "EShell sysname prompt face")
  (esh-section esh-sysname
               (if (display-graphic-p) "💻" "σ")
               (system-name)
               esh-sysname)

  (defface esh-num
    '((t (:foreground "brown")))
    "EShell number prompt face")
  (esh-section esh-num
               (if (display-graphic-p) "☰" "n")  ;  (list icon)
               (number-to-string esh-prompt-num)
               esh-num)


  (setq
   eshell-highlight-prompt nil
   ;; Separator between esh-sections
   esh-sep "  "  ; or " | "

   ;; Separator between an esh-section icon and form
   esh-section-delim " "

   ;; Eshell prompt header
   esh-header "\n"  ; or "\n┌─"

   ;; Eshell prompt regexp and string. Unless you are varying the prompt by eg.
   ;; your login, these can be the same.
   eshell-prompt-string (let ((last-prompt "⊳ "))
                          (add-text-properties
                           0 (length last-prompt)
                           '(read-only t
                                       font-lock-face eshell-prompt
                                       front-sticky (font-lock-face read-only)
                                       rear-nonsticky (font-lock-face read-only))
                           last-prompt)
                          last-prompt)  ; or "└─> " or "└─» "
   eshell-prompt-regexp
   (concat "^" (regexp-quote eshell-prompt-string) ;;"\\|^[a-z]*>\\{1,4\\} \\|^[^#$
;;]* [#$] "
           )  ; or "└─> "
   ;; Choose which eshell-funcs to enable
   eshell-funcs (list esh-python esh-git esh-user esh-sysname esh-clock esh-num
                      "\n" esh-dir
                      "\n" eshell-prompt-string)
   ;; Enable the new eshell prompt
   eshell-prompt-function 'esh-prompt-func
   eshell-banner-message (format
                          "%s\nEmacs version %s on %s. Compilation %s  %s\n"
                          system-configuration-features
                          emacs-version system-type system-configuration
                          system-configuration-options))

  ;; ;;;;;;;;;;; ;;
  ;; Post prompt ;;
  ;; ;;;;;;;;;;; ;;
  (defvar eshell-play-sound-time-threshold 20)

  (defun eshell-current-command-start ()
    (setq eshell-current-command-start-time (float-time)))

  (defun eshell-current-command-stop ()
    (when eshell-current-command-start-time
      (let ((seconds (- (float-time) eshell-current-command-start-time)))
        (setq eshell-current-command-start-time nil)
        (eshell-interactive-print
         (propertize
          (format
           "\n<Exit code: %i  Elapsed time: %s>"
           eshell-last-command-status
           (concat (format-seconds "%h:%.2m:%.2s" seconds)
                   (let ((decimals (mod seconds 1)))
                     (when (< 0 decimals)
                       (substring (number-to-string decimals) 1)))))
          'font-lock-face '(:foreground "goldenrod1")))
        (when (and eshell-play-sound-time-threshold
                   (<= eshell-play-sound-time-threshold seconds))
          (if (numberp eshell-last-command-status)
              (cond
               ((= 0 eshell-last-command-status)
                (let ((filename (expand-file-name
                                 "cache/sounds/success-bells-major.wav"
                                 user-emacs-directory)))
                  (if (file-exists-p filename)
                      (start-process "*aplay*" nil "aplay" filename)
                    (beep))))
               ((< 0 eshell-last-command-status)
                (let ((filename (expand-file-name
                                 "cache/sounds/negative-beep.wav"
                                 user-emacs-directory)))
                  (if (file-exists-p filename)
                      (start-process "*aplay*" nil "aplay" filename)
                    (beep))))
               (t
                (let ((filename (expand-file-name
                                 "cache/sounds/sonar.wav"
                                 user-emacs-directory)))
                  (if (file-exists-p filename)
                      (start-process "*aplay*" nil "aplay" filename)
                    (beep)))))
            (let ((filename (expand-file-name
                             "cache/sounds/startup.wav"
                             user-emacs-directory)))
                  (if (file-exists-p filename)
                      (start-process "*aplay*" nil "aplay" filename)
                    (beep))))))))

  (defun eshell-current-command-time-track ()
    (add-hook 'eshell-pre-command-hook #'eshell-current-command-start nil t)
    (add-hook 'eshell-post-command-hook #'eshell-current-command-stop nil t))
  (add-hook 'eshell-mode-hook #'eshell-current-command-time-track)

  ;; To uninstall
  ;; (remove-hook 'eshell-mode-hook #'eshell-current-command-time-track)

;;;;;;;;;;;;;;;;
;; Completion ;;
;;;;;;;;;;;;;;;;
  ;; [ <python completion>
  (when (executable-find "python")

    (defun pcmpl-python-commands ()
      (with-temp-buffer
        (call-process-shell-command "LC_ALL=C python --help" nil (current-buffer))
        (goto-char 0)
        (let (commands)
          (while (re-search-forward "^-\\([[:word:]-.]+\\)" nil t)
            (push (match-string 1) commands))
          (mapconcat 'identity commands ""))))

    (defconst pcmpl-python-commands (pcmpl-python-commands)
      "List of `python' commands.")

    (defun pcmpl-python-packages ()
      (with-temp-buffer
        (call-process-shell-command "LC_ALL=C python -m pip freeze" nil (current-buffer))
        (goto-char 0)
        (let (packages)
          (while (re-search-forward "^\\([[:word:]-.]+\\)=" nil t)
            (push (match-string 1) packages))
          (sort packages 'string<))))

    (defun pcomplete/python ()
      "Completion for `python'."
      ;; Completion for the command argument.
      (pcomplete-opt pcmpl-python-commands)
      (cond
       ((pcomplete-match "-m" 1)
        (pcomplete-here (pcmpl-python-packages)))
       (t
        (while (pcomplete-here (pcomplete-entries)))))))
  ;; ] <python completion>
  ;; [ <python3 completion>
  (when (executable-find "python3")

    (defun pcmpl-python3-commands ()
      (with-temp-buffer
        (call-process-shell-command "LC_ALL=C python3 --help" nil (current-buffer))
        (goto-char 0)
        (let (commands)
          (while (re-search-forward "^-\\([[:word:]-.]+\\)" nil t)
            (push (match-string 1) commands))
          (mapconcat 'identity commands ""))))

    (defconst pcmpl-python3-commands (pcmpl-python3-commands)
      "List of `python3' commands.")

    (defun pcmpl-python3-packages ()
      (with-temp-buffer
        (call-process-shell-command "LC_ALL=C python3 -m pip freeze" nil (current-buffer))
        (goto-char 0)
        (let (packages)
          (while (re-search-forward "^\\([[:word:]-.]+\\)=" nil t)
            (push (match-string 1) packages))
          (sort packages 'string<))))

    (defun pcomplete/python3 ()
      "Completion for `python3'."
      ;; Completion for the command argument.
      (pcomplete-opt pcmpl-python3-commands)
      (cond
       ((pcomplete-match "-m" 1)
        (pcomplete-here (pcmpl-python3-packages)))
       (t
        (while (pcomplete-here (pcomplete-entries)))))))
  ;; ] <python3 completion>
  ;; [ <Git Completion>
  (when (executable-find "git")

    (defun pcmpl-git-commands ()
      "Return the most common git commands by parsing the git output."
      (with-temp-buffer
        (call-process-shell-command "LC_ALL=C git --no-pager help --all" nil (current-buffer))
        (goto-char 0)
        (cond
         ((search-forward "available git commands in " nil t)
          (let (commands)
            (while (and (re-search-forward
                         "[[:blank:]]+\\([[:word:]-]+\\)"
                         nil t)
                        (not (string-equal (match-string 1) "commands")))
              (push (match-string 1) commands))
            (sort commands #'string<)))
         ((search-forward "Main Porcelain Commands" nil t)
          (let (commands)
            (while (re-search-forward
                    "^[[:blank:]]+\\([[:word:]-]+\\)"
                    nil t)
              (push (match-string 1) commands))
            (sort commands #'string<)))
         (t
          (message "Git command's help changed.")))))

    (defconst pcmpl-git-commands (pcmpl-git-commands)
      "List of `git' commands.")

    (defvar pcmpl-git-ref-list-cmd "git for-each-ref refs/ --format='%(refname)'"
      "The `git' command to run to get a list of refs.")

    (defun pcmpl-git-get-refs (type)
      "Return a list of `git' refs filtered by TYPE."
      (with-temp-buffer
        (insert (shell-command-to-string pcmpl-git-ref-list-cmd))
        (goto-char (point-min))
        (let (refs)
          (while (re-search-forward (concat "^refs/" type "/\\(.+\\)$") nil t)
            (push (match-string 1) refs))
          (nreverse refs))))

    (defun pcmpl-git-remotes ()
      "Return a list of remote repositories."
      (split-string (shell-command-to-string "git remote")))

    (defun pcomplete/git ()
      "Completion for `git'."
      ;; Completion for the command argument.
      (pcomplete-here* pcmpl-git-commands)
      (cond
       ((pcomplete-match "help" 1)
        (pcomplete-here* pcmpl-git-commands))
       ((pcomplete-match (regexp-opt '("pull" "push")) 1)
        (pcomplete-here (pcmpl-git-remotes)))
       ;; provide branch completion for the command `checkout'.
       ((pcomplete-match "checkout" 1)
        (pcomplete-here* (append (pcmpl-git-get-refs "heads")
                                 (pcmpl-git-get-refs "tags"))))
       (t
        (while (pcomplete-here (pcomplete-entries))))))

    (when (executable-find "ggit")

      (defun pcmpl-ggit-commands ()
        "Return the most common git commands by parsing the git output."
        (with-temp-buffer
          (call-process-shell-command "LC_ALL=C ggit --help" nil (current-buffer))
          (goto-char 0)
          (let (commands)
            (while (re-search-forward
                    "^[[:blank:]]+\\(--[[:word:]-]+\\)"
                    nil t)
              (push (match-string 1) commands))
            (sort commands #'string<))))

      (defconst pcmpl-ggit-commands (append (pcmpl-ggit-commands)
                                            pcmpl-git-commands)
        "List of `ggit' commands.")

      (defun pcomplete/ggit ()
        "Completion for `git'."
        ;; Completion for the command argument.
        (pcomplete-here* pcmpl-ggit-commands)
        (cond
         ((pcomplete-match "help" -1)
          (pcomplete-here* pcmpl-git-commands))
         ((pcomplete-match (regexp-opt '("pull" "push")) -1)
          (pcomplete-here (pcmpl-git-remotes)))
         ;; provide branch completion for the command `checkout'.
         ((pcomplete-match "checkout" -1)
          (pcomplete-here* (append (pcmpl-git-get-refs "heads")
                                   (pcmpl-git-get-refs "tags"))))
         (t
          (while (pcomplete-here (pcomplete-entries))))))))
  ;; ] <Git Completion>
  ;; [ <Bzr Completion>
  (when (executable-find "bzr")

    (defun pcmpl-bzr-commands ()
      "Return the most common bzr commands by parsing the bzr output."
      (with-temp-buffer
        (call-process-shell-command "LC_ALL=C bzr help commands" nil (current-buffer))
        (goto-char 0)
        (let (commands)
          (while (re-search-forward "^\\([[:word:]-]+\\)[[:blank:]]+" nil t)
            (push (match-string 1) commands))
          (sort commands #'string<))))

    (defconst pcmpl-bzr-commands (pcmpl-bzr-commands)
      "List of `bzr' commands.")

    (defun pcomplete/bzr ()
      "Completion for `bzr'."
      ;; Completion for the command argument.
      (pcomplete-here* pcmpl-bzr-commands)
      (cond
       ((pcomplete-match "help" 1)
        (pcomplete-here* pcmpl-bzr-commands))
       (t
        (while (pcomplete-here (pcomplete-entries)))))))
  ;; ] <Bzr Completion>
  ;; [ <Mercurial (hg) Completion>
  (when (executable-find "hg")

    (defun pcmpl-hg-commands ()
      "Return the most common hg commands by parsing the hg output."
      (with-temp-buffer
        (call-process-shell-command "LC_ALL=C hg -v help" nil (current-buffer))
        (goto-char 0)
        (search-forward "list of commands:")
        (let (commands
              (bound (save-excursion
                       (re-search-forward "^[[:alpha:]]")
                       (forward-line 0)
                       (point))))
          (while (re-search-forward
                  "^[[:blank:]]\\([[:word:]]+\\(?:, [[:word:]]+\\)*\\)" bound t)
            (let ((match (match-string 1)))
              (if (not (string-match "," match))
                  (push (match-string 1) commands)
                (dolist (c (split-string match ", ?"))
                  (push c commands)))))
          (sort commands #'string<))))

    (defconst pcmpl-hg-commands (pcmpl-hg-commands)
      "List of `hg' commands.")

    (defun pcomplete/hg ()
      "Completion for `hg'."
      ;; Completion for the command argument.
      (pcomplete-here* pcmpl-hg-commands)
      (cond
       ((pcomplete-match "help" 1)
        (pcomplete-here* pcmpl-hg-commands))
       (t
        (while (pcomplete-here (pcomplete-entries)))))))
  ;; ] <Mercurial (hg) Completion>
  ;; [ <sudo completion>
  (defun pcomplete/sudo ()
    "Completion rules for the `sudo' command."
    (let ((pcomplete-ignore-case t))
      (pcomplete-here (funcall pcomplete-command-completion-function))
      (while (pcomplete-here (pcomplete-entries)))))
  ;; ] <sudo completion>
  ;; [ <systemctl completion>
  (defcustom pcomplete-systemctl-commands
    '("disable" "enable" "status" "start" "restart" "stop" "reenable"
      "list-units" "list-unit-files")
    "p-completion candidates for `systemctl' main commands"
    :type '(repeat (string :tag "systemctl command"))
    :group 'pcomplete)

  (defvar pcomplete-systemd-units
    (split-string
     (shell-command-to-string
      "(systemctl list-units --all --full --no-legend;systemctl list-unit-files --full --no-legend)|while read -r a b; do echo \" $a\";done;"))
    "p-completion candidates for all `systemd' units")

  (defvar pcomplete-systemd-user-units
    (split-string
     (shell-command-to-string
      "(systemctl list-units --user --all --full --no-legend;systemctl list-unit-files --user --full --no-legend)|while read -r a b;do echo \" $a\";done;"))
    "p-completion candidates for all `systemd' user units")

  (defun pcomplete/systemctl ()
    "Completion rules for the `systemctl' command."
    (pcomplete-here (append pcomplete-systemctl-commands '("--user")))
    (cond ((pcomplete-test "--user")
           (pcomplete-here pcomplete-systemctl-commands)
           (pcomplete-here pcomplete-systemd-user-units))
          (t (pcomplete-here pcomplete-systemd-units))))
  ;; ] <systemctl completion>
  ;; [ <man completion>
  (defvar pcomplete-man-user-commands
    (split-string
     (shell-command-to-string
      "apropos -s 1 .|while read -r a b; do echo \" $a\";done;"))
    "p-completion candidates for `man' command")

  (defun pcomplete/man ()
    "Completion rules for the `man' command."
    (pcomplete-here pcomplete-man-user-commands))
  ;; ] <man completion>

;;;;;;;;;;
;; Keys ;;
;;;;;;;;;;

  (defun eshell-cmpl-initialize-advice (&rest _args)
    (define-key eshell-mode-map "\r" 'eshell-send-input-rename)
    (when (featurep 'helm)
      (define-key eshell-mode-map [tab] #'helm-esh-pcomplete))
    (define-key eshell-mode-map (kbd "<S-return>") 'eshell-send-input-rename-stderr))
  (advice-add 'eshell-cmpl-initialize :after 'eshell-cmpl-initialize-advice)

  (defun eshell-hist-initialize-advice (&rest _args)
    (when (featurep 'helm)
      (define-key eshell-command-map [(control ?l)] #'helm-eshell-history)))
  (advice-add 'eshell-hist-initialize :after 'eshell-hist-initialize-advice)

  (add-hook
   'eshell-mode-hook
   (lambda ()
     (goto-address-mode 1)
     (define-key eshell-mode-map (kbd "<up>") 'eshell-key-up)
     (define-key eshell-mode-map (kbd "<down>") 'eshell-key-down)
     (define-key eshell-mode-map (kbd "M-p") 'eshell-key-alt-previous)
     (define-key eshell-mode-map (kbd "M-n") 'eshell-key-alt-next)
     (define-key eshell-mode-map (kbd "C-c C-k") 'eshell-send-chars-interactive-process)
     ;; Make file paths clickable
     (define-key eshell-mode-map (kbd "C-c c")
       (lambda (arg)
         (interactive "P")
         (if arg
             (compilation-shell-minor-mode -1)
           (if (null compilation-shell-minor-mode)
               (compilation-shell-minor-mode 1)
             (compilation-shell-minor-mode -1)
             (compilation-shell-minor-mode 1)))))
     (add-to-list 'eshell-complex-commands "ag"))))
#+end_src

*** /ispell/

#+begin_src elisp
(with-eval-after-load 'ispell
  (defun importing-ispell-config-advice (&rest _args)
    (message "Importing ispell config")

    (let ((executable (file-name-nondirectory ispell-program-name)))
      (cond
       ((string-equal executable "aspell")
        (setq ispell-personal-dictionary
              (file-truename (expand-file-name
                              "cache/aspell.spanish.pws"
                              user-emacs-directory)))
        (add-to-list 'ispell-extra-args "--sug-mode=ultra"))
       ((string-equal executable "hunspell")
        (setenv "DICPATH" (file-truename (expand-file-name
                                          "cache/hunspell/"
                                          user-emacs-directory)))
        (add-to-list 'ispell-local-dictionary-alist `("es_ES"
                                                      "[a-zA-ZáéíóúÁÉÍÓÚÑüÜ]"
                                                      "[^a-zA-ZáéíóúÁÉÍÓÚÑüÜ]"
                                                      "[']"
                                                      t
                                                      ("-d" "es_ES")
                                                      nil
                                                      utf-8))
        (setq ispell-really-hunspell t
              ispell-personal-dictionary
              (file-truename (expand-file-name
                              "cache/hunspell.spanish.pws"
                              user-emacs-directory))
              ispell-current-dictionary "es_ES"
              ispell-local-dictionary "es_ES"
              ispell-dictionary "es_ES")
        ;; Internal use
        ;; (add-to-list 'ispell-hunspell-dict-paths-alist `("spanish" ,(file-truename "~/.emacs.d/cache/hunspell/es_ES.aff")))
        )))
    ;; [ Cycle languages
    (require 'ring)
    (defvar spell-lang-ring nil)
    (let ((langs '("english" "spanish")))
      (setq spell-lang-ring (make-ring (length langs)))
      (dolist (elem langs) (ring-insert spell-lang-ring elem)))

    (defun spell-change-dictionary (dictionary)
      "Change dictionary file inserting DICTIONARY."
      (setq ispell-personal-dictionary
            (cond
             ((string-equal ispell-program-name "aspell")
              (expand-file-name (concat "cache/aspell." dictionary ".pws")
                                user-emacs-directory))
             ((string-equal ispell-program-name "hunspell")
              (expand-file-name (concat "cache/hunspell." dictionary ".pws")
                                user-emacs-directory))))
      (ispell-change-dictionary dictionary))

                                        ;(ispell-change-dictionary)
    (defun cycle-ispell-languages ()
      "Cycle languages in ring."
      (interactive)
      (let ((lang (ring-ref spell-lang-ring -1))
            (dict ispell-current-dictionary))
        (ring-insert spell-lang-ring lang)
        (if (equal dict lang)
            (let ((next-lang (ring-ref spell-lang-ring -1)))
              (ring-insert spell-lang-ring next-lang)
              (spell-change-dictionary next-lang))
          (spell-change-dictionary lang))))
    ;; ]

    ;; Selecciona una opción incluso cuando picas fuera del popup
    ;; (defun spell-emacs-popup-textual (event poss word)
    ;;       "A textual spell popup menu."
    ;;       (require 'popup)
    ;;       (let* ((corrects (if spell-sort-corrections
    ;;                            (sort (car (cdr (cdr poss))) 'string<)
    ;;                          (car (cdr (cdr poss)))))
    ;;              (cor-menu (if (consp corrects)
    ;;                            (mapcar (lambda (correct)
    ;;                                      (list correct correct))
    ;;                                    corrects)
    ;;                          '()))
    ;;              (affix (car (cdr (cdr (cdr poss)))))
    ;;              show-affix-info
    ;;              (base-menu  (let ((save (if (and (consp affix) show-affix-info)
    ;;                                          (list
    ;;                                           (list (concat "Save affix: " (car affix))
    ;;                                                 'save)
    ;;                                           '("Accept (session)" session)
    ;;                                           '("Accept (buffer)" buffer))
    ;;                                        '(("Save word" save)
    ;;                                          ("Accept (session)" session)
    ;;                                          ("Accept (buffer)" buffer)))))
    ;;                            (if (consp cor-menu)
    ;;                                (append cor-menu (cons "" save))
    ;;                              save)))
    ;;              (menu (mapcar
    ;;                     (lambda (arg) (if (consp arg) (car arg) arg))
    ;;                     base-menu)))
    ;;         (cadr (assoc (popup-menu* menu :scroll-bar t) base-menu))))
    (defun spanish-dictionary ()
      "Stablish spanish dictionary."
      (interactive)
      (spell-change-dictionary "spanish"))
    (defun english-dictionary ()
      "Stablish english dictionary."
      (interactive)
      (spell-change-dictionary "english"))
    (advice-remove 'ispell-init-process 'importing-ispell-config-advice))
  (advice-add 'ispell-init-process :before 'importing-ispell-config-advice))
#+end_src

*** /hideshow/

#+begin_src elisp
(add-hook 'prog-mode-hook #'hs-minor-mode)
(with-eval-after-load 'hideshow
  (message "Importing hideshow-config")

  (setq minor-mode-alist (assq-delete-all 'hs-minor-mode minor-mode-alist)
        hs-set-up-overlay
        (lambda (ov)
          (when (eq 'code (overlay-get ov 'hs))
            (overlay-put
             ov 'display
             (propertize
              (format "… %d lines"
                      (count-lines (overlay-start ov)
                                   (overlay-end ov)))
              'face
              `(:foreground "purple"
                :box (:line-width ,(if (>= emacs-major-version 28) '(-1 . -1) -1))))))))

  (with-eval-after-load 'tex-mode
    (add-hook 'latex-mode-hook #'hs-minor-mode)
    (add-hook 'tex-mode-hook #'hs-minor-mode))
  (with-eval-after-load 'latex
    (add-hook 'LaTeX-mode-hook #'hs-minor-mode))
  (with-eval-after-load 'tex
    (add-hook 'TeX-mode-hook #'hs-minor-mode))

  (define-key hs-minor-mode-map (kbd "<C-tab>") #'hs-toggle-hiding))
#+end_src

*** /compilation-mode/

#+begin_src elisp
(with-eval-after-load 'compile
  ;; process's default filter `comint-output-filter'
  (setq comint-scroll-to-bottom-on-output nil
        ;; compile-command "cbuild -g "
        compilation-scroll-output 'first-error)

  (push '("\\_<\\([A-Za-z]*[Ww]arnings?\\|WARNINGS?\\|[Ww]arn\\|WARN\\|[Dd]eprecated\\|DEPRECATED\\)\\_>"
          1 compilation-warning-face)
        compilation-mode-font-lock-keywords)
  (push '("\\_<\\([A-Za-z]*[Ee]rrors?\\|ERRORS?\\|[A-Za-z]*[Ee]xceptions?\\|EXCEPTIONS?\\|\\(std\\)?[Ee]rr\\(no\\)?\\|\\(STD\\)?ERR\\(NO\\)?\\|[Nn]ot?\\|NOT?\\|[Ff]ailed\\|FAILED\\|[Ff]ailures?\\|FAILURES?\\|[Ff]ails?\\|FAILS?\\)\\_>"
          1 compilation-error-face)
        compilation-mode-font-lock-keywords)
  (push '("\\_<\\(GET\\|HEAD\\|POST\\|PUT\\|DELETE\\|CONNECT\\|OPTIONS\\|TRACE\\|PATCH\\)\\_> [^ \t\r\n]*"
          0 compilation-info-face)
        compilation-mode-font-lock-keywords)

  ;; (defun compilation-conditional-scroll-output ()
  ;;   (let ((name (buffer-name)))
  ;;     (if (and name
  ;;              (string-match-p "log" name))
  ;;         (set (make-local-variable 'compilation-scroll-output) nil))))
  ;; (add-hook 'compilation-mode-hook 'compilation-conditional-scroll-output)
  )
#+end_src

*** /etags/

#+begin_src elisp
(with-eval-after-load 'prog-mode
  ;; Generate tags file:
  ;; # cd <project root path>
  ;; # rm ETAGS
  ;; # find <root code path> -type f -name "<source files pattern>" -print 2>/dev/null | xargs etags -o ETAGS --append
  (require 'etags)

  (defvar tags-default-file-name "ETAGS")

  (defun visit-tags-table-advice (orig-fun &optional file &rest args)
    (if file
        (apply orig-fun file args)
      (let ((tags-directory (locate-dominating-file default-directory tags-default-file-name)))
        (if tags-directory
            (let ((tags-path (expand-file-name tags-default-file-name tags-directory)))
              (message "%s file path: %s" tags-default-file-name tags-path)
              ;; (advice-remove 'visit-tags-table 'visit-tags-table-advice)
              (apply orig-fun tags-path args))
          (message "%s file not found." tags-default-file-name)))))
  (advice-add 'visit-tags-table :around 'visit-tags-table-advice)

  (defun visit-tags-table-buffer-advice (orig-fun &rest args)
    (advice-remove 'visit-tags-table-buffer 'visit-tags-table-buffer-advice)
    (visit-tags-table)
    (apply orig-fun args))
  (advice-add 'visit-tags-table-buffer :around 'visit-tags-table-buffer-advice)

  (defun tags-update-etags-file (extension)
    (interactive (list (read-string "File extension ."
                                    nil nil
                                    (file-name-extension (buffer-file-name)))))
    (if (stringp extension)
        (let ((tags-directory (locate-dominating-file default-directory
                                                      tags-default-file-name)))
          (if tags-directory
              (let ((default-directory tags-directory))
                (if (= 0
                       (shell-command
                        (concat
                         "rm " tags-default-file-name
                         " && find . ! -readable -prune -o -type f -name \"*."
                         extension
                         "\" -print -exec etags -o "
                         tags-default-file-name
                         " --append {} \\;")))
                    (message "%s file created with .%s files."
                             (expand-file-name tags-default-file-name tags-directory)
                             extension)
                  (message "%s file creation failed."
                           (expand-file-name tags-default-file-name tags-directory))))
            (message "%s file not found." tags-default-file-name)))
      (message "%s is not a valid extension." extension)))

  (defun tags-create-etags-file (directory)
    (interactive "DCreate etags file in path: ")
    (let ((tags-path (expand-file-name tags-default-file-name directory)))
      (if (file-exists-p tags-path)
          (message "%s file already exists in %s." tags-default-file-name directory)
        (let ((default-directory directory)
              (extension (file-name-extension (buffer-file-name))))
          (if (= 0
                 (shell-command (concat "find . ! -readable -prune -o -type f -name \"*."
                                        extension
                                        "\" -print -exec etags --append {} \\;")))
              (message "%s file created with .%s files." tags-path extension)
            (message "%s file creation failed." tags-path))))))

  (defun etags-xref-find-advice (orig-fun &rest args)
    (condition-case nil
        (apply orig-fun args)
      (error
       (message "Current xref backends failed, trying `etags'")
       (let ((xref-backend-functions '(etags--xref-backend)))
         (call-interactively orig-fun)))))

  (advice-add 'xref-find-apropos :around 'etags-xref-find-advice)
  (advice-add 'xref-find-references :around 'etags-xref-find-advice)

  (advice-add 'xref-find-definitions :around 'etags-xref-find-advice)
  (advice-add 'xref-find-definitions-other-frame :around 'etags-xref-find-advice)
  (advice-add 'xref-find-definitions-other-window :around 'etags-xref-find-advice)



  ;; ;;;; ;;
  ;; Keys ;;
  ;; ;;;; ;;
  (with-eval-after-load 'hydra
    (defhydra hydra-xref (:foreign-keys run :hint nil)
      ("M-," #'xref-pop-marker-stack "pop")
      ("M-'" #'xref-find-references "ref")
      ("M-a" #'xref-find-apropos "apropos")
      ("M-." #'xref-find-definitions "def")
      ("M-W" #'xref-find-definitions-other-window "def win")
      ("M-F" #'xref-find-definitions-other-frame "def frame")
      ("M-s" #'tags-search "search")
      ("M-t" #'xref-query-replace-in-results "repl results")
      ("M-r" #'tags-query-replace "repl")
      ("M-c" #'fileloop-continue "cont")
      ("M-p" #'pop-tag-mark "pop tag")
      ("M-l" #'list-tags "list")
      ("M-q" nil "quit"))

    (global-set-key (kbd "M-Ç") 'hydra-xref/body)))
#+end_src

*** /ede/

#+begin_src elisp
(with-eval-after-load 'ede
  (message "Importing ede-config")
  ;; ede is difficult for management
  ;; (require 'cedet)
  ;; (require 'ede/source)
  ;; (require 'ede/base)
  ;; (require 'ede/auto)
  ;; (require 'ede/proj)
  ;; (require 'ede/proj-archive)
  ;; (require 'ede/proj-aux)
  ;; (require 'ede/proj-comp)
  ;; (require 'ede/proj-elisp)
  ;; (require 'ede/proj-info)
  ;; (require 'ede/proj-misc)
  ;; (require 'ede/proj-obj)
  ;; (require 'ede/proj-prog)
  ;; (require 'ede/proj-scheme)
  ;; (require 'ede/proj-shared)

  ;; [ unstable
  ;; ;; advice 'projectile' functions to work with 'ede'
  ;; (defun ede-add-to-projectile-project-root (orig-fun &rest args)
  ;;   (condition-case nil
  ;;       (file-name-directory (oref (ede-current-project) file))
  ;;     (error (apply orig-fun args))))
  ;; (advice-add 'projectile-project-root :around
  ;;             #'ede-add-to-projectile-project-root)

  ;; (defun ede-add-to-projectile-project-name (orig-fun &rest args)
  ;;   (condition-case nil
  ;;       (oref (ede-current-project) name)
  ;;     (error (apply orig-fun args))))
  ;; (advice-add 'projectile-project-name :around
  ;;             #'ede-add-to-projectile-project-name)
  ;; ]

  ;;(global-ede-mode 1)
  ;; Unknown error
  ;; (ede-enable-generic-projects)
  (eval-after-config 'after-ede-config))
#+end_src

*** /eldoc/

#+begin_src elisp
(with-eval-after-load 'eldoc
  (defun display-buffer-eldoc-condition (buffer-name action)
    (eq eldoc--doc-buffer (get-buffer buffer-name)))

  (defun eldoc-doc-buffer-toggle ()
    (interactive)
    (unless global-eldoc-mode
      (global-eldoc-mode))
    (if eldoc--doc-buffer
        (let ((windows (get-buffer-window-list eldoc--doc-buffer)))
          (if windows
              (mapc 'delete-window windows)
            (let ((display-buffer-alist
                   '(((lambda (&rest _args) t)
                      display-buffer-at-bottom
                      (inhibit-same-window . t)
                      (window-height . fit-window-to-buffer)))))
              (eldoc-doc-buffer))))
      (message "Eldoc not ready. Wait or call `eldoc'.")))

  (with-eval-after-load 'flymake
    (defun flymake-avoid-at-overlay-advice (orig-fun &rest args)
      (unless (and flymake-mode
                   (flymake--overlays :beg (point)))
        (apply orig-fun args)))
    (advice-add 'eldoc-minibuffer-message :around 'flymake-avoid-at-overlay-advice))

  (setq eldoc-idle-delay 0.5
        eldoc-minor-mode-string ""
        eldoc-echo-area-prefer-doc-buffer t
        eldoc-echo-area-use-multiline-p 3
        eldoc-echo-area-display-truncation-message nil)
  ;; (global-eldoc-mode -1)
  (global-set-key (kbd "C-h ,") 'eldoc-print-current-symbol-info)
  (global-set-key (kbd "C-h :") 'eldoc-doc-buffer-toggle))
(global-set-key (kbd "C-h .") 'eldoc-mode)
#+end_src

*** /which-function-mode/

#+begin_src elisp
(with-eval-after-load 'which-func
  (set-face-attribute 'which-func nil
                      :foreground
                      (face-attribute 'font-lock-function-name-face
                                      :foreground))
;;   (setq which-func-unknown "∅"
;;         mode-line-misc-info
;;         ;; We remove Which Function Mode from the mode line, because it's mostly
;;         ;; invisible here anyway.
;;         (assq-delete-all 'which-function-mode mode-line-misc-info)
;;         which-func-format
;;         `("["
;;           (:propertize (:eval (string-replace
;;                                "%" "%%"
;;                                (or (gethash (selected-window) which-func-table)
;;                                    which-func-unknown)))
;;                        local-map ,which-func-keymap
;;                        face which-func
;;                        mouse-face mode-line-highlight
;;                        help-echo "mouse-1: go to beginning\n\
;; mouse-2: toggle rest visibility\n\
;; mouse-3: go to end")
;;           "]"))

;;   (defun org-which-function ()
;;     (when (eq major-mode 'org-mode)
;;       (ignore-errors
;;         (mapconcat 'identity (org-get-outline-path t t)
;;                    " · "))))
;;   (push 'org-which-function which-func-functions)

;;   (defun which-func-header-line ()
;;     (when (memq major-mode which-func-modes)
;;       (add-to-list 'header-line-format
;;                    '(which-function-mode which-func-format))))

;;   (defun which-func-header-lines ()
;;     (if which-function-mode
;;         (progn
;;           (add-hook 'find-file-hook 'which-func-header-line)
;;           (dolist (buffer (buffers-from-file))
;;             (with-current-buffer buffer
;;               (which-func-header-line))))
;;       (remove-hook 'find-file-hook 'which-func-header-line)
;;       (dolist (buffer (buffers-from-file))
;;         (with-current-buffer buffer
;;           (when (memq major-mode which-func-modes)
;;             (setq header-line-format
;;                   (assq-delete-all 'which-function-mode
;;                                    header-line-format)))))))
;;   (add-hook 'which-function-mode-hook 'which-func-header-lines)
  )
(global-set-key (kbd "C-c f") 'which-function-mode)
#+end_src

*** /semantic/

#+begin_src elisp
;; first loaded
(add-hook 'emacs-lisp-mode-hook #'semantic-mode -91)
(add-hook 'lisp-mode-hook #'semantic-mode -91)
(with-eval-after-load 'semantic/symref/grep
  (push '(php-mode "*.php" "*.php[s345678]" "*.phtml")
        semantic-symref-filepattern-alist))
(with-eval-after-load 'semantic
  (message "Importing semantic-config")
  ;; [ Included by default
  ;; (add-to-list 'semantic-default-submodes 'global-semantic-idle-scheduler-mode)
  ;; (add-to-list 'semantic-default-submodes 'global-semanticdb-minor-mode)
  ;; ]
  (require 'semantic)
  ;;(setq-default semantic-symref-tool "grep")
  (setq semantic-default-submodes '(semantic-tag-folding-mode
                                    semantic-mru-bookmark-mode
                                    semantic-stickyfunc-mode
                                    semantic-idle-scheduler-mode
                                    semanticdb-minor-mode)
        semantic-stickyfunc-sticky-classes '(function type)
        ;; semantic-symref-tool "grep"
        ;; semantic-decoration-styles
        ;; '(("semantic-decoration-on-includes" . t)
        ;;   ("semantic-decoration-on-protected-members" . t)
        ;;   ("semantic-decoration-on-private-members" . t)
        ;;   ("semantic-tag-boundary" . t))
        semantic-idle-scheduler-idle-time 3)

  ;; Disabled, completions by company
  ;; (add-to-list 'semantic-default-submodes 'global-semantic-idle-completions-mode)
  ;; First line show current function
  ;;(add-to-list 'semantic-default-submodes 'global-semantic-stickyfunc-mode)
  ;; Most Recently Used tags
  ;;(add-to-list 'semantic-default-submodes 'global-semantic-mru-bookmark-mode)
  ;; Highlight symbol under cursor in page
  ;; (add-to-list 'semantic-default-submodes 'global-semantic-idle-local-symbol-highlight-mode)
  ;;(add-to-list 'semantic-default-submodes 'global-semantic-tag-folding-mode)
  ;; (add-to-list 'semantic-default-submodes 'global-semantic-decoration-mode)
  ;; Smart autocomplete
  (require 'semantic/ia)
  ;; SpeedBar
  (require 'semantic/sb)
  ;; (require 'semantic/wisent)
  ;; (require 'semantic/symref)
  ;; Include semantic-symref-results-mode-map and related
  (require 'semantic/symref/list)
  ;; [ Autocomplete with gcc headers
  ;; inside company-extensions-config.el
  ;; (require 'semantic/bovine/gcc)
  ;; ]
  ;; Not found
  ;;(require 'semantic/bovine/clang)
  ;; After 'require' and after update 'semantic-default-submodes' list
  ;;(semantic-mode 1)

  ;; Autocompletado usando los .h incluidos de librerías personales
  ;; [ Extremadamente lento para proyectos grandes
  ;; (semantic-add-system-include "~/Prog/c/lib" 'c++-mode)
  ;; ]
  ;; Java autocomplete
  ;;(require 'semantic/db-javap)
  ;;(require 'semantic-bug)

;;;;;;;;;;;;;;;;;;;;;;;;
;; Semantic parse dir ;;
;;;;;;;;;;;;;;;;;;;;;;;;
  (defvar semantic-parse-c-files-regex "\\.\\(c\\|cc\\|cpp\\|cxx\\|h\\|hpp\\|hxx\\)$"
    "A regular expression to match any c/c++ related files under a directory.")

  (defvar semantic-parse-exclude-files-regex "/\\.\\(hg\\|git\\)/")

  (defun semantic-parse-dir-regex (root regex &optional exclude)
    "Parse dirs in ROOT that match REGEX and exclude EXCLUDE."
    (dolist (file (cl-remove-if
                   (lambda (arg) (string-match-p
                                  (or exclude semantic-parse-exclude-files-regex)
                                  arg))
                   (directory-files-recursively
                    root
                    regex)))
      (semanticdb-file-table-object file)))

  (defun semantic-parse-dir (root)
    "Make Semantic parse all source files in directory ROOT, recursively."
    (interactive (list (read-directory-name "Root directory: "
                                            default-directory)))
    (semantic-parse-dir-regex root semantic-parse-c-files-regex))

  ;; (defun semantic-parse-dir (root regex)
  ;;   "This function is an attempt of mine to force semantic to
  ;;    parse all source files under a root directory. Arguments:
  ;;    -- root: The full path to the root directory
  ;;    -- regex: A regular expression against which to match all files in the directory"
  ;;   (let (
  ;;         ;;make sure that root has a trailing slash and is a dir
  ;;         (root (file-name-as-directory root))
  ;;         (files (directory-files root t ))
  ;;        )
  ;;     ;; remove current dir and parent dir from list
  ;;     (setq files (delete (format "%s." root) files))
  ;;     (setq files (delete (format "%s.." root) files))
  ;;     ;; remove any known version control directories
  ;;     (setq files (delete (format "%s.git" root) files))
  ;;     (setq files (delete (format "%s.hg" root) files))
  ;;     (while files
  ;;       (setq file (pop files))
  ;;       (if (not(file-accessible-directory-p file))
  ;;           ;;if it's a file that matches the regex we seek
  ;;           (progn (when (string-match-p regex file)
  ;;                    (save-excursion
  ;;                      (semanticdb-file-table-object file))
  ;;            ))
  ;;           ;;else if it's a directory
  ;;           (semantic-parse-dir file regex)
  ;;       )
  ;;      )
  ;;   )
  ;; )

  ;; (defun semantic-parse-current-dir (regex)
  ;;   "Parses all files under the current directory matching regex"
  ;;   (semantic-parse-dir (file-name-directory buffer-file-name) regex)
  ;; )
  
  ;; (defun semantic-parse-curdir-c ()
  ;;   "Parses all the c/c++ related files under the current directory
  ;;    and inputs their data into semantic"
  ;;   (interactive)
  ;;   (semantic-parse-current-dir semantic-parse-c-files-regex)
  ;; )
  
  ;; (defun semantic-parse-dir-c (dir)
  ;;   "Prompts the user for a directory and parses all c/c++ related files
  ;;    under the directory"
  ;;   (interactive (list (read-directory-name "Provide the directory to search in:")))
  ;;   (semantic-parse-dir (expand-file-name dir) semantic-parse-c-files-regex)
  ;; )

;;;;;;;;;;;;;;;
;; Functions ;;
;;;;;;;;;;;;;;;
  (defun semantic-complete-jump-at-point (point)
    "Find definition/declaration of symbol at POINT.
Improve default ia jump at point."
    (interactive "d")
    (let* ((ctxt (semantic-analyze-current-context point))
           (pf (and ctxt (reverse (oref ctxt prefix))))
           (first-tag (car pf)))
      (if (semantic-tag-p first-tag)
          (semantic-ia--fast-jump-helper first-tag)
        (progn
          (semantic-error-if-unparsed)
          (let* ((tag (semantic-complete-read-tag-project "Jump to symbol: " first-tag first-tag)))
            (when (semantic-tag-p tag)
              (push-mark nil t)
              (semantic-go-to-tag tag)
              (switch-to-buffer (current-buffer))
              (semantic-momentary-highlight-tag tag)
              (message "%S: %s "
                       (semantic-tag-class tag)
                       (semantic-tag-name  tag))))))))

;;;;;;;;;;
;; Keys ;;
;;;;;;;;;;
  ;; (bind-keys :map semantic-mode-map
  ;;            ([(control return)] . semantic-ia-complete-symbol)
  ;;            ("C-c , a" . semantic-complete-analyze-inline)
  ;;            ("C-c , s" . semantic-ia-show-summary)
  ;;            ("C-c , d" . semantic-ia-show-doc)
  ;;            ("C-c , c" . semantic-ia-describe-class)
  ;;            ("M-," . semantic-analyze-proto-impl-toggle) ; "C-c , p"
  ;;            ("M-." . ido-semantic-complete-jump) ; "C-c , j"
  ;;            ("M--" . semantic-analyze-possible-completions)
  ;;            ("M-Ç" . semantic-symref)
  ;;            ("M-ç" . semantic-symref-symbol)
  ;;            ;; senator
  ;;            ("C-c , +" . senator-fold-tag)
  ;;            ("C-c , -" . senator-unfold-tag)
  ;;            ("C-c , ." . senator-fold-tag-toggle))
  (define-key semantic-symref-results-mode-map "e" #'semantic-symref-list-expand-all)
  (define-key semantic-symref-results-mode-map "c" #'semantic-symref-list-contract-all)

  ;;(semantic-mode 1)

  (require 'srecode)
  ;;(global-srecode-minor-mode 1)

  ;; stickfunc improved
  (require 'stickyfunc-enhance))
#+end_src

*** /gud/

#+begin_src elisp
(with-eval-after-load 'semantic

  (autoload 'pdb-dir "gud" nil t)
  (autoload 'pdb-test-at-point "gud" nil t)
  (with-eval-after-load 'gud
    (message "Importing gud config")
    ;; ;; (setq gud-gdb-command-name "gdb --annotate=3 --fullname")

    ;; ;; [ <color> Add color to the current GUD line (by google)
    ;; ;; (defvar gud-overlay
    ;; ;;   (let* ((ov (make-overlay (point-min) (point-min))))
    ;; ;;     (overlay-put ov 'face 'secondary-selection)
    ;; ;;     ov)
    ;; ;;   "Overlay variable for GUD highlighting.")

    ;; ;; (defadvice gud-display-line (after my-gud-highlight act)
    ;; ;;            "Highlight current line."
    ;; ;;            (let* ((ov gud-overlay)
    ;; ;;                   (bf (gud-find-file true-file)))
    ;; ;;              (save-excursion
    ;; ;;                  (set-buffer bf)
    ;; ;;                    (move-overlay ov (line-beginning-position) (line-end-position)
    ;; ;;                                    (current-buffer)))))

    ;; ;; (defun gud-kill-buffer ()
    ;; ;;   (if (eq major-mode 'gud-mode)
    ;; ;;     (delete-overlay gud-overlay)))

    ;; ;; (add-hook 'kill-buffer-hook 'gud-kill-buffer)
    ;; ;; ] <color>


    ;; =================================
    ;; PDB configuration
    ;; =================================
    (defun pdb-dir (&optional dir)
      (interactive)
      ;; don't change default directory
      (let ((gud-chdir-before-run nil)
            (default-directory
              (or dir
                  (read-directory-name "Default directory: " nil nil t))))
        (call-interactively 'pdb)))

    (require 'which-func)
    (defun pdb-test-at-point (arg)
      (interactive "P")
      (let* ((default-directory (project-root-directory))
             (path (concat
                    (replace-regexp-in-string
                     (concat
                      "^"
                      (regexp-quote (expand-file-name default-directory)))
                     "" (buffer-file-name) t)
                    "::"
                    (mapconcat 'identity (split-string (which-function) "\\.") "::"))))
        (if arg
            (kill-new path)
          (let ((gud-chdir-before-run nil))
            (pdb (concat
                  "pytest --pdb "
                  path))))))

    (setq gud-pdb-command-name "python -m pdb"))
  ;; =================================
  ;; GDB configuration
  ;; =================================
  (with-eval-after-load 'gdb-mi

    ;; Dedicated windows except source window
    (defun gdb-dedicated-windows ()
      (dolist (window (window-list))
        (when
            (and
             (eq
              0
              (string-match
               "*gud\\|*stack\\|*locals\\|*registers\\|*input/output\\|*breakpoints"
               (buffer-name (window-buffer window))))
             (not (buffer-file-name (window-buffer window))))
          (set-window-dedicated-p window t))))
    (advice-add  'gdb-setup-windows :after #'gdb-dedicated-windows)

    ;; Window options
    (setq gdb-many-windows t
          gdb-use-separate-io-buffer t)

    (add-hook 'gdb-mode-hook 'gud-tooltip-mode)
    ;;(add-hook 'gdb-mode-hook (lambda () (require 'gdb-highlight)))


    ;; [ <history> cycle command history
    ;; (add-hook 'gud-mode-hook
    ;;           (lambda ()
    ;;             (local-set-key [home]        ; move to beginning of line, after prompt
    ;;              'comint-bol)
    ;;             (local-set-key [up]          ; cycle backward through command history
    ;;              (lambda () (interactive)
    ;;                (if (comint-after-pmark-p)
    ;;                    (comint-previous-input 1)
    ;;                    (previous-line 1))))
    ;;             (local-set-key [down]        ; cycle forward through command history
    ;;              (lambda () (interactive)
    ;;                (if (comint-after-pmark-p)
    ;;                    (comint-next-input 1)
    ;;                  (forward-line 1))))))
    ;; ] <history>

;;;;;;;;;;;;;;;;;;
    ;; New commands ;;
;;;;;;;;;;;;;;;;;;

    (defun gdb-new-commands (command-line)
      (gud-def gud-args "info args" "a" "Show args variables.")
      (gud-def gud-kill "kill" "k" "Kill running process.")
      (gud-def gud-quit "quit" "q" "Quit gdb."))
    (advice-add 'gdb :after #'gdb-new-commands)

;;;;;;;;;;
    ;; Keys ;;
;;;;;;;;;;

    (defhydra hydra-gud (:foreign-keys run);(gud-minor-mode-map "C-x C-a" :foreign-keys run)
      "GUD"
      ("<" gud-up "up")
      (">" gud-down "down")
      ("C-b" gud-break "break")
      ("C-d" gud-remove "remove")
      ("C-f" gud-finish "finish")
      ("C-j" gud-jump "jump")
      ("C-l" gud-refresh "refresh")
      ("C-n" gud-next "next")
      ("C-p" gud-print "print")
      ("C-c" gud-cont "continue")
      ("C-r" gud-run "run")
      ("C-s" gud-step "step")
      ;;("C-t" gud-tbreak "tbreak")
      ("C-u" gud-until "until")
      ("C-w" gud-watch "watch")
      ("C-a" gud-args "args")
      ("C-t" gud-tooltip-mode "tooltip")
      ("C-k" gud-kill "kill")
      ("C-q" gud-quit "quit" :color blue) ; blue color exec and quit hydra
      ("M-q" nil ""))
    (define-key gud-minor-mode-map (kbd "C-x C-a m") #'hydra-gud/body)
    (define-key gud-minor-mode-map (kbd "C-c C-t") #'gud-tooltip-mode)))
#+end_src

*** CANC /speedbar/
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
(with-eval-after-load 'semantic
  (message "Importing speedbar-config")
  (require 'speedbar)

  ;; (require 'eieio)
  ;; (require 'eieio-speedbar)
  ;; (require 'eieio-opt)
  ;; (require 'eieio-base)
  ;; (setq speedbar-frame-parameters
  ;;       '((minibuffer)
  ;;         (width . 40)
  ;;         (border-width . 0)
  ;;         (menu-bar-lines . 0)
  ;;         (tool-bar-lines . 0)
  ;;         (unsplittable . t)
  ;;         (left-fringe . 0)))
  ;; (setq speedbar-hide-button-brackets-flag t)
  ;; (setq speedbar-show-unknown-files t)
  ;; (setq speedbar-smart-directory-expand-flag t)
  (eval-and-when-daemon frame
    (when (display-graphic-p frame)
      (setq ezimage-use-images t
            speedbar-use-images t)))

  (speedbar-enable-update))
#+end_src

*** CANC /lisp-mode/
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
(with-eval-after-load 'lisp-mode
  (define-key lisp-data-mode-map "`" #'insert-pair))
#+end_src

*** /cc-mode/                                                      :programming:

#+begin_src elisp
(add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))

(with-eval-after-load 'cc-mode
  (define-key c-mode-base-map "#" nil)
  (define-key c-mode-base-map "{" #'insert-pair)
  (define-key c-mode-base-map "}" nil)
  (define-key c-mode-base-map "/" nil)
  (define-key c-mode-base-map "*" nil)
  (define-key c-mode-base-map ";" nil)
  (define-key c-mode-base-map "," nil)
  (define-key c-mode-base-map ":" nil)
  (define-key c-mode-base-map "(" #'insert-pair)
  (define-key c-mode-base-map ")" nil)
  (define-key c-mode-base-map (kbd "C-c C-f") #'rotate-text)
  (define-key c-mode-base-map (kbd "C-c C-b") #'rotate-text-backward)
  (define-key c-mode-base-map (kbd "C-c C-u") #'string-inflection-all-cycle)
  (define-key c-mode-base-map "'" #'insert-pair)
  (define-key c-mode-base-map (kbd "C-c m c") 'compile-cmake-make))

(defun c-c++-config ()
  ;; run only once
  (remove-hook 'c-mode-hook 'c-c++-config)
  (remove-hook 'c++-mode-hook 'c-c++-config)
  (message "Importing c-c++-config")

  (defvar c-c++-include-paths nil)
  (defvar c-c++-default-mode-for-headers 'c++-mode)
  (defvar c-c++-enable-clang-support t)

  (require 'faces)
  (require 'find-file)
  ;; Directorios para busqueda del archivo dual
  (dolist (path c-c++-include-paths)
    (add-to-list 'cc-search-directories path))

  ;; ;;;;;;;; ;;
  ;; C macros ;;
  ;; ;;;;;;;; ;;
  ;; Create Header Guards
  (defun c-c++-header-guards ()
    "Prevent read more than one time a c or c++ header file."
    (interactive)
    (if buffer-file-name
        (let*
            ((name (file-name-nondirectory
                    (file-name-sans-extension buffer-file-name)))
             (proj-name (condition-case nil
                            (replace-regexp-in-string
                             (regexp-quote (file-name-directory (oref (ede-current-project) file))) ""
                             (file-name-sans-extension buffer-file-name) nil t)
                          (error name)))
             (ext   (file-name-extension buffer-file-name))
             (label (concat "__" (upcase
                                  (replace-regexp-in-string "[^a-zA-Z0-9_]" "_" proj-name t t))
                            "_" (upcase ext) "__")))
          (save-excursion
            (when (< (buffer-size) 5)
              (insert "\nclass " (upcase-initials name) "\n{\n\npublic:\n\n};\n"))
            (goto-char (point-min))
            (insert "#ifndef " label "\n#define " label "\n\n")
            (goto-char (point-max))
            (insert "\n\n#endif" " // " label)))
      (message (concat "Buffer " (buffer-name) " must have a filename"))))

  ;; supply by package
  ;; (defun toggle-camelcase-underscores ()
  ;;   "Toggle between camelcase and underscore notation for the symbol at point."
  ;;   (interactive)
  ;;   (save-excursion
  ;;     (let* ((bounds (bounds-of-thing-at-point 'symbol))
  ;;            (start (car bounds))
  ;;            (end (cdr bounds))
  ;;            (currently-using-underscores-p (progn (goto-char start)
  ;;                                                  (re-search-forward "_" end t))))
  ;;       (if currently-using-underscores-p
  ;;           (progn
  ;;             (upcase-initials-region start end)
  ;;             (replace-string "_" "" nil start end)
  ;;             (downcase-region start (1+ start)))
  ;;         (replace-regexp "\\([A-Z]\\)" "_\\1" nil (1+ start) end)
  ;;         (downcase-region start (cdr (bounds-of-thing-at-point 'symbol)))))))

  ;; ;;; ;;
  ;; C++ ;;
  ;; ;;; ;;
  (defun avoid-shared-ptr-by-ref (arg)
    (interactive "P")
    (goto-char (point-min))
    (let ((counts 0))
      (while (search-forward-regexp "> *&[^&]" nil t)
        (let ((pos-end (- (point) 2)))
          (goto-char (match-beginning 0))
          (let ((angles 1))
            (while (< 0 angles)
              (backward-char 1)
              (if (char-equal (char-after (point)) ?<)
                  (cl-decf angles)
                (if (char-equal (char-after (point)) ?>)
                    (cl-incf angles))))
            (search-backward-regexp "[^_a-zA-Z0-9: \t\n]" nil t)
            (if (or (char-equal (char-after (point)) ?,)
                    (char-equal (char-after (point)) ?\())
                (let ((pos-beg (point)))
                  (when (and
                         (cl-search
                          "shared_ptr"
                          (buffer-substring-no-properties pos-beg pos-end))
                         (or arg
                             (progn
                               (goto-char pos-end)
                               (pulse-momentary-highlight-region (1+ pos-beg)
                                                                 (1+ pos-end) 'region)
                               (y-or-n-p "Delete match? "))))
                    (delete-region pos-end (1+ pos-end))
                    (save-restriction
                      (narrow-to-region pos-beg pos-end)
                      (goto-char (point-min))
                      (if (search-forward-regexp "[^a-zA-Z_]\\(const +\\)[a-zA-Z_:]" nil t)
                          (delete-region (match-beginning 1) (match-end 1))))
                    (cl-incf counts)))))
          (goto-char pos-end)))
      (message "Found %i pointers by ref" counts)))

  ;; ;;;; ;;
  ;; Keys ;;
  ;; ;;;; ;;
  (global-set-key (kbd "C-x O") 'ff-find-other-file)

  (dolist (mode-map (list c-mode-map c++-mode-map))
    (define-key mode-map [C-M-tab] 'clang-format-region)
    (define-key mode-map [(shift return)] 'c-context-line-break)
    (define-key mode-map (kbd "C-c c h") 'c-c++-header-guards))
  ;; (define-key c-mode-map (kbd "C-c c h") 'c-c++-header-guards)
  ;; (define-key c++-mode-map (kbd "C-c c h") 'c-c++-header-guards)
  ;; (define-key c-mode-map [(shift return)] 'c-context-line-break)
  ;; (define-key c++-mode-map [(shift return)] 'c-context-line-break)

  ;; After semantic
  ;; After ede-projects-config

  ;; ;;;;;;;;;;;;;;;;;;;; ;;
  ;; cmake and make utils ;;
  ;; ;;;;;;;;;;;;;;;;;;;; ;;
  (message "Importing cmake-make-config")
  ;; cmake-make begin
  (require 's)
  (require 'cmake-mode)

  ;; ;;;;;;;;;;;;;;;;; ;;
  ;; Smart compilation ;;
  ;; ;;;;;;;;;;;;;;;;; ;;
  (require 'ede)
  (defun make-targets (&optional file)
    "Get the targets of the Makefile FILE."
    (butlast (split-string (shell-command-to-string (if file (concat "targets " file) "targets")) "\n")))

  (defun compilation-execute (&optional prefix)
    "Execute compilation command replacing $p $n $b.  PREFIX ignored."
    (interactive)
    (let ((bufferpathname (or buffer-file-name ""))
          (buffername (or (buffer-name) ""))
          (bufferbasename (or (file-name-base) ""))
          (command (read-shell-command "Shell command: " prefix nil nil)))
      (compilation-start (concat "LC_ALL=C " (replace-regexp-in-string "\$p" (concat "\"" bufferpathname "\"")
                                                                       (replace-regexp-in-string "\$n" (concat "\"" buffername "\"")
                                                                                                 (replace-regexp-in-string "\$b" (concat "\"" bufferbasename "\"")
                                                                                                                           command t t) t t) t t)))))

  (defun recursive-find-to-root (file-list directory)
    "Search FILE-LIST in paths from DIRECTORY to root."
    (let ((dir directory))
      (cl-block nested-while
        (while (not (string-equal dir "/"))
          (progn
            (dolist (element file-list)
              (let ((path-file (concat dir element)))
                (message path-file)
                (when (file-exists-p path-file)
                  (cl-return-from nested-while path-file))))
            (setq dir (concat (expand-file-name (concat dir "..")) "/"))))
        (error "Project file not found"))))

  (defun cmake-make-path-file (&optional directory)
    "Find Makefile or CMakelists.txt path starting in DIRECTORY."
    (cond
     (directory
      (recursive-find-to-root '("CMakeLists.txt" "Makefile" "makefile") directory))
     ((ede-current-project)
      (oref (ede-current-project) file))
     ;; ((projectile-project-root)
     ;;  (let ((project-root (projectile-project-root)))
     ;;    (dolist (element '("CMakeLists.txt" "Makefile" "makefile"))
     ;;      (let ((path-file (concat project-root element)))
     ;;        (when (file-exists-p path-file)
     ;;          (return path-file))))))
     (t
      (recursive-find-to-root '("CMakeLists.txt" "Makefile" "makefile") default-directory))))
  
  (defun cmake-make-conf ()
    "Get current compilation mode.  Examples: debug, release..."
    (cond
     ((ede-current-project)
      (oref (ede-current-project) configuration-default))
     (t "debug")))

  (defun make-completing-read (file last)
    "Read target with completion.  Targets for completing are in FILE.  LAST is last selection."
    (let ((selection (completing-read-multiple "Select target: " (make-targets file) nil nil (s-replace " " "," last))))
      (if (listp selection)
          (mapconcat 'identity selection " ")
        selection)))

  (defvar make-target-last "")
  (defun compile-cmake-make (&optional directory)
    "Compile with cmake or make inside DIRECTORY."
    (interactive
     (cond
      ((equal current-prefix-arg '(4))
       (list
        (read-directory-name "Initial directory: ")))))
    (let* ((path-file (cmake-make-path-file directory))
           (path (file-name-directory path-file))
           (file (file-name-nondirectory path-file))
           (conf (cmake-make-conf)))
      (cond
       ((string-equal file "CMakeLists.txt")
        (let ((dir (concat path conf "/")))
          (unless (file-exists-p dir)
            (make-directory dir))
          (let ((default-directory dir))
            (when (file-newer-than-file-p "../CMakeLists.txt" "CMakeCache.txt")
              (progn
                (when (file-exists-p "CMakeCache.txt") (delete-file "CMakeCache.txt"))
                (when (file-exists-p "Makefile") (delete-file "Makefile"))
                (when (file-exists-p "cmake_install.cmake") (delete-file "cmake_install.cmake"))
                (when (file-exists-p "CTestTestfile.cmake") (delete-file "CTestTestfile.cmake"))
                (when (file-exists-p "DartConfiguration.tcl") (delete-file "DartConfiguration.tcl"))
                (when (file-exists-p "CMakeFiles") (delete-directory "CMakeFiles" t))
                (when (file-exists-p "Testing") (delete-directory "Testing" t))))
            (unless (file-exists-p "CMakeCache.txt")
              (cond ((string-equal (downcase conf) "debug")
                     (compilation-execute "cmake -DCMAKE_BUILD_TYPE=Debug .."))
                    ((string-equal (downcase conf) "release")
                     (compilation-execute "cmake -DCMAKE_BUILD_TYPE=Release .."))
                    (t (compilation-execute "cmake .."))))
            (set 'make-target-last (make-completing-read file make-target-last))
            (compilation-execute (concat "make -k " make-target-last " ")))))
       ((string-equal (downcase (substring file 0 8)) "makefile")
        (let ((default-directory path))
          (set 'make-target-last (make-completing-read file make-target-last))
          (compilation-execute (concat "make -k -f " file " " make-target-last " "))))))))

(add-hook 'c-mode-hook   'c-c++-config)
(add-hook 'c++-mode-hook 'c-c++-config)
(add-hook 'c-mode-hook   'eglot-ensure)
(add-hook 'c++-mode-hook 'eglot-ensure)
#+end_src

*** /python-mode/                                                  :programming:

#+begin_src elisp
(add-hook 'python-mode-hook 'eglot-ensure)
(add-hook 'python-mode-hook (lambda ()
                              (setq forward-sexp-function nil)))
(setq python-shell-interpreter (or (executable-find "~/bin/python-emacs")
                                   (executable-find "pypy3")
                                   (executable-find "pypy")
                                   (executable-find "/usr/local/bin/python3")
                                   (executable-find "/usr/bin/python3")
                                   (executable-find "/usr/local/bin/python")
                                   (executable-find "/usr/bin/python")))
(with-eval-after-load 'python
  ;;  (require 'semantic/wisent/python)
  (message "Importing python-config")
  (require 'python) ;; inferior-python-mode-map

  ;; ;;;;;;; ;;
  ;; Helpers ;;
  ;; ;;;;;;; ;;
  (defun ipython-to-python-ring-save (&optional arg)
    (interactive "P")
    (if (use-region-p)
        (let* ((ipython-str (filter-buffer-substring (region-beginning) (region-end)))
               (python-str (ipython-to-python-text ipython-str)))
          (kill-new python-str)
          (setq deactivate-mark t))))

  (defun pypy-to-python-ring-save (&optional arg)
    (interactive "P")
    (if (use-region-p)
        (let* ((pypy-str (filter-buffer-substring (region-beginning) (region-end)))
               (python-str (pypy-to-python-text pypy-str)))
          (kill-new python-str)
          (setq deactivate-mark t))))

  (defun set-python-interpreter-args ()
    (cond
     ((string-match-p "ipython" python-shell-interpreter)
      ;; ipython or ipython3
      (define-key inferior-python-mode-map (kbd "M-w") #'ipython-to-python-ring-save)
      (setq python-shell-interpreter-args "-i --simple-prompt"))
     ((string-match-p "pypy" python-shell-interpreter)
      (define-key inferior-python-mode-map (kbd "M-w") #'pypy-to-python-ring-save)
      (setq python-shell-interpreter-args "-i -S"))
     (t
      ;; python or python3
      (define-key inferior-python-mode-map (kbd "M-w") nil)
      (setq python-shell-interpreter-args "-i"))))

  ;; ;;;;;;;;;;;;; ;;
  ;; Configuration ;;
  ;; ;;;;;;;;;;;;; ;;
  (setq python-shell-extra-pythonpaths (let ((python-paths (getenv "PYTHONPATH")))
                                         (and
                                          python-paths
                                          (mapcar 'expand-file-name
                                                  (split-string python-paths ":"))))
        python-indent-guess-indent-offset nil)

  ;; ;;;;;;;;; ;;
  ;; Functions ;;
  ;; ;;;;;;;;; ;;
  (defun python-doctest-to-message (&optional msg)
    (interactive "p")
    (let ((process (python-shell-get-process-or-error msg))
          (string (python-shell-buffer-substring (point-min) (point-max) t)))
      (message (python-shell-send-string-no-output (concat string "

if __name__ == \"__main__\":
    import doctest
    print(doctest.testmod())
")))))

  (defun python-timeit-to-message (&optional msg)
    (interactive "p")
    (let ((process (python-shell-get-process-or-error msg))
          (string (python-shell-buffer-substring (point-min) (point-max) t)))
      (message (python-shell-send-string-no-output (concat string "

if __name__ == \"__main__\":
    import timeit
    for k, v in dict(locals()).items():
        if k[:4] == '_ti_' and callable(v):
            print(v, timeit.timeit(v))
")))))


  (defun python-insert-start-debuger (arg)
    (interactive "P")
    (if arg
        (save-excursion
          (goto-char (point-min))
          (while (re-search-forward "[^\n][ \t]*import +pdb *; *pdb.set_trace *() *#?[^\n]*" nil t)
            (replace-match "" t t)))
      (insert "import pdb; pdb.set_trace()")))

  (defun run-python-in-directory ()
    (interactive)
    (let ((default-directory (read-directory-name "working folder: ")))
      (run-python)))

  (defun python-change-working-directory ()
    (interactive)
    (let ((default-directory (read-directory-name "working folder: ")))
      (python-shell-send-string (concat "import os;os.chdir('" default-directory "')"))))

  (defun ipython-to-python-text (string)
    (let ((case-fold-search nil))
      (replace-regexp-in-string
       "-*\n.*Traceback (most recent call last)" "Traceback (most recent call last):"
       (replace-regexp-in-string
        "^In \\[[0-9]+\\]: " ">>> "
        (replace-regexp-in-string
         "^Out\\[[0-9]+\\]: " ""
         (replace-regexp-in-string
          "^  +\\.\\.\\.: " "... " string t t) t t) t t) t t)))

  (defun pypy-to-python-text (string)
    (replace-regexp-in-string
     "^>>>> " ">>> "
     (replace-regexp-in-string
      "^\\.\\.\\.\\. " "... " string t t) t t))

  (defun python-import-to-multiline ()
    (interactive)
    (let* ((beg (progn (beginning-of-line) (point)))
           (end (progn (end-of-line) (point)))
           (import-string (buffer-substring-no-properties beg end)))
      (when (string-match "from +\\([^ ]+\\) +import +\\([^,]+\\), *\\(.*\\)" import-string)
        (let ((common-string (match-string 1 import-string))
              (first-string (match-string 2 import-string))
              (import-list (match-string 3 import-string)))
          (delete-and-extract-region beg end)
          (insert (concat "from " common-string " import " first-string))
          (dolist (item (split-string import-list ", *"))
            (newline)
            (insert (concat "from " common-string " import " item)))))))

  (defun python-import-to-oneline ()
    (interactive)
    (let* ((beg (progn (beginning-of-line) (point)))
           (end (progn (end-of-line) (point)))
           (import-string (buffer-substring-no-properties beg end)))
      (when (string-match "from +\\([^ ]+\\) +import +.*" import-string)
        (let* ((common-string (match-string 1 import-string))
               (pattern (concat "from +" common-string " +import +\\(.*\\)
"))
               (import-list ""))
          (goto-char (point-min))
          (re-search-forward pattern nil t)
          (setq end (1- (match-end 0)))
          (while (re-search-forward pattern nil t)
            (setq import-list (concat import-list ", " (match-string-no-properties 1)))
            (replace-match "" t t))
          (goto-char end)
          (insert import-list)))))

  (defun python-find-test (text &optional arg)
    (interactive
     (list
      (save-excursion
        (re-search-backward "^_\\{10,\\} [_A-Z][_a-zA-Z0-9\\., ]* _\\{10,\\}$")
        (re-search-forward "[A-Z]")
        (let ((def (buffer-substring-no-properties-thing "symbol")))
          (read-string
           (if def
               (concat "Test (" def "): ")
             "Test <class>.<fun>: ") nil nil
           def)))
      (prefix-numeric-value current-prefix-arg)))
    (let ((strings (split-string text "\\." t)))
      (set-process-filter
       (start-process "*python-find-test*" nil
                      "rg" "--no-heading" "--color=never" "-lUH0"
                      "--multiline-dotall"
                      (mapconcat 'identity strings ".*?"))
       `(lambda (proc line)
          (,(cl-case arg
              ((2 4) 'find-file-other-window)
              ((3 5 16) 'find-file-other-frame)
              (otherwise 'find-file))
           (substring line 0 -1))
          (goto-char (point-min))
          (dolist (string (quote ,strings))
            (search-forward string))))))

  ;; ;;;;;; ;;
  ;; Sphinx ;;
  ;; ;;;;;; ;;
  (with-eval-after-load 'sphinx-doc
    (require 'sphinx-frontend-config))

  ;; ;;;; ;;
  ;; Keys ;;
  ;; ;;;; ;;
  (define-key python-mode-map [(control backspace)] nil)
  (define-key python-mode-map "\177" nil)
  ;; (define-key python-mode-map (kbd "C-c t d")
  ;;   #'python-doctest-to-message)
  ;; (define-key python-mode-map (kbd "C-c t t")
  ;;   #'python-timeit-to-message)
  ;; (define-key python-mode-map (kbd "C-c d h")
  ;;   #'sphinx-build-html)

  (define-key python-mode-map "'" #'insert-pair)
  (define-key python-mode-map (kbd "C-c p t d") #'python-doctest-to-message)
  (define-key python-mode-map (kbd "C-c p t t") #'python-timeit-to-message)
  (define-key python-mode-map (kbd "C-c p d h") #'sphinx-build-html)
  (define-key python-mode-map (kbd "C-c p a") #'python-nav-beginning-of-statement)
  (define-key python-mode-map (kbd "C-c p e") #'python-nav-end-of-statement)
  (define-key python-mode-map (kbd "M-s 7 v") #'toggle-python-version)
  ;;  (add-hook 'python-mode-hook #'detect-python-project-version)
  (with-eval-after-load 'dap-mode
    (require 'dap-python)))
#+end_src

*** WAIT /python-integrated/
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
;; TODO: implementar la función python-integrated-mode dentro de python-integrated.el
;(autoload 'python-integrated-mode "python-integrated" "Python everywhere" t)
;(add-to-list 'auto-mode-alist '("\\.py\\." . python-integrated-mode))
;(require 'python-integrated)
#+end_src

*** /flymake/

#+begin_src elisp
;; flymake
(add-hook 'emacs-lisp-mode-hook #'flymake-mode)
(with-eval-after-load 'flymake
  (message "Importing flymake-config")

  ;; If nil, never start checking buffer automatically like this.
  (setq flymake-no-changes-timeout 2.0)

  ;; thanks to: stackoverflow.com/questions/6110691/is-there-a-way-to-make-flymake-to-compile-only-when-i-save
  ;; (defun flymake-after-change-function (start stop len)
  ;;   "Start syntax check for current buffer if it isn't already running.
  ;; START and STOP and LEN are as in `after-change-functions'."
  ;;     ;; Do nothing, don't want to run checks until I save.
  ;;   )

  (when (require 'flymake-diagnostic-at-point nil 'noerror)
    (add-hook 'flymake-mode-hook #'flymake-diagnostic-at-point-mode)
    (setq flymake-diagnostic-at-point-timer-delay flymake-no-changes-timeout))

  (define-key flymake-mode-map (kbd "M-g n") #'flymake-goto-next-error)
  (define-key flymake-mode-map (kbd "M-g M-n") #'flymake-goto-next-error)
  (define-key flymake-mode-map (kbd "M-g p") #'flymake-goto-prev-error)
  (define-key flymake-mode-map (kbd "M-g M-p") #'flymake-goto-prev-error)
  (define-key flymake-mode-map (kbd "C-c ! l") #'flymake-show-diagnostics-buffer)
  (define-key flymake-mode-map (kbd "C-c ! c") #'flymake-start))
#+end_src

*** /flyspell/

#+begin_src elisp
;; Disabled because annoying cursor movement
;; (require 'flyspell-lazy)

;; [ better call `flyspell-buffer' C-c i c
;; (dolist (hook '(text-mode-hook))
;;   (add-hook hook (lambda () (flyspell-mode 1))))
;; (dolist (hook '(change-log-mode-hook log-edit-mode-hook))
;;   (add-hook hook (lambda () (flyspell-mode -1))))

;; (dolist (hook '(prog-mode-hook))
;; ;;  (add-hook hook #'flyspell-lazy-mode)
;;   (add-hook hook 'flyspell-prog-mode))
;; ]

(with-eval-after-load 'flyspell
  (defun importing-flyspell-config-advice (&rest _args)
    (message "Importing flyspell config")

    (setq flyspell-use-meta-tab nil
          flyspell-mode-line-string ""
          flyspell-use-mouse-3-for-menu t)
    ;; ;;;;; ;;
    ;; Faces ;;
    ;; ;;;;; ;;
    (set-face-attribute 'flyspell-incorrect nil
                        :underline "red1")
    (set-face-attribute 'flyspell-duplicate nil
                        :underline "magenta")

    ;; ;;;;;;;;; ;;
    ;; Functions ;;
    ;; ;;;;;;;;; ;;

    ;; move point to previous error
    ;; based on code by hatschipuh at
    ;; http://emacs.stackexchange.com/a/14912/2017
    (defun flyspell-goto-previous-error (arg)
      "Go to ARG previous spelling error."
      (interactive "p")
      (while (not (= 0 arg))
        (let ((pos (point))
              (min (point-min)))
          (if (and (eq (current-buffer) flyspell-old-buffer-error)
                   (eq pos flyspell-old-pos-error))
              (progn
                (if (= flyspell-old-pos-error min)
                    ;; goto beginning of buffer
                    (progn
                      (message "Restarting from end of buffer")
                      (goto-char (point-max)))
                  (backward-word 1))
                (setq pos (point))))
          ;; seek the next error
          (while (and (> pos min)
                      (let ((ovs (overlays-at pos))
                            (r '()))
                        (while (and (not r) (consp ovs))
                          (if (flyspell-overlay-p (car ovs))
                              (setq r t)
                            (setq ovs (cdr ovs))))
                        (not r)))
            (backward-word 1)
            (setq pos (point)))
          ;; save the current location for next invocation
          (setq arg (1- arg))
          (setq flyspell-old-pos-error pos)
          (setq flyspell-old-buffer-error (current-buffer))
          (goto-char pos)
          (if (= pos min)
              (progn
                (message "No more miss-spelled word!")
                (setq arg 0))))))

    ;; ;;;; ;;
    ;; Keys ;;
    ;; ;;;; ;;
    (define-key flyspell-mouse-map (kbd "<C-down-mouse-2>") #'flyspell-correct-word)
    (define-key flyspell-mouse-map (kbd "<C-mouse-2>") #'undefined)
    (define-key flyspell-mouse-map [down-mouse-2] nil)
    (define-key flyspell-mouse-map [mouse-2] nil)
    (define-key flyspell-mode-map [?\C-c ?$] nil)
    (define-key flyspell-mode-map flyspell-auto-correct-binding nil)
    (define-key flyspell-mode-map [(control ?\,)] nil)
    (define-key flyspell-mode-map [(control ?\.)] nil)
    (define-key flyspell-mode-map (kbd "C-M-i") nil)
    (define-key flyspell-mode-map (kbd "C-c i c") #'flyspell-buffer)
    (define-key flyspell-mode-map (kbd "C-c i n") #'flyspell-goto-next-error)
    (define-key flyspell-mode-map (kbd "C-c i p") #'flyspell-goto-previous-error)
    (define-key flyspell-mode-map (kbd "C-c i a") #'flyspell-auto-correct-word)
    (define-key flyspell-mode-map (kbd "C-c i A") #'flyspell-auto-correct-previous-word)
    (if (load "helm-flyspell" t)
        (progn
          (define-key flyspell-mode-map (kbd "C-c i .") #'helm-flyspell-correct)
          (define-key flyspell-mode-map (kbd "C-c i ,") #'helm-flyspell-correct))
      (define-key flyspell-mode-map (kbd "C-c i .") #'flyspell-correct-at-point)
      (define-key flyspell-mode-map (kbd "C-c i ,") #'flyspell-correct-word-before-point))

    ;;(fset 'flyspell-emacs-popup 'flyspell-emacs-popup-textual)
    (defhydra hydra-spell (:foreign-keys warn)
      "SPELL"
      ("C-b" flyspell-buffer "buffer")
      ("C-n" flyspell-goto-next-error "next")
      ("C-p" flyspell-goto-previous-error "previous")
      ("C-c" flyspell-correct-word-before-point "correct")
      ("C-a" flyspell-auto-correct-word "auto")
      ("M-q" nil "quit"))
    (define-key flyspell-mode-map (kbd "C-c i m") 'hydra-spell/body)
    (define-key flyspell-mode-map (kbd "C-c i >") 'cycle-ispell-languages)
    (define-key flyspell-mode-map (kbd "C-c i s") 'spanish-dictionary)
    (define-key flyspell-mode-map (kbd "C-c i e") 'english-dictionary)
    (advice-remove 'flyspell-mode 'importing-flyspell-config-advice))
  (advice-add 'flyspell-mode :before 'importing-flyspell-config-advice)
  (with-eval-after-load 'tex-mode
    (add-hook 'latex-mode-hook #'flyspell-mode)
    (add-hook 'tex-mode-hook #'flyspell-mode))
  (with-eval-after-load 'latex
    (add-hook 'LaTeX-mode-hook #'flyspell-mode))
  (with-eval-after-load 'tex
    (add-hook 'TeX-mode-hook #'flyspell-mode)))
#+end_src

*** /calendar-mode/

#+begin_src elisp
(with-eval-after-load 'calendar
  (add-hook 'calendar-mode-hook (lambda () (setq truncate-lines t)))
  (setq calendar-week-start-day 1
        ;; calendar-day-name-array     ["domingo" "lunes" "martes"
        ;;                              "miércoles" "jueves" "viernes" "sábado"]
        ;; calendar-day-abbrev-array   ["dom" "lun" "mar" "mié" "jue" "vie" "sáb"]
        ;; calendar-day-header-array   ["D" "L" "M" "X" "J" "V" "S"]
        ;; calendar-month-name-array   ["Enero" "Febrero" "Marzo" "Abril" "Mayo"
        ;;                              "Junio" "Julio" "Agosto" "Septiembre"
        ;;                              "Octubre" "Noviembre" "Diciembre"]
        ;; calendar-month-abbrev-array ["Ene" "Feb" "Mar" "Abr" "May" "Jun"
        ;;                              "Jul" "Ago" "Sep" "Oct" "Nov" "Di
        )
  )
#+end_src

* External packages
** Always required
*** /goto-chg/

#+begin_src elisp
(global-set-key (kbd "C-<") 'goto-last-change)
(global-set-key (kbd "C->") 'goto-last-change-reverse)
#+end_src

*** /undo-tree/

#+begin_src elisp
;;(require 'undo-tree-autoloads)
(with-eval-after-load 'undo-tree
  (setq undo-tree-mode-lighter
        (propertize "^"
                    'face '(:foreground "light slate blue" :weight bold))
        undo-tree-enable-undo-in-region t
        undo-tree-limit undo-limit
        undo-tree-strong-limit undo-strong-limit
        undo-tree-outer-limit undo-outer-limit
        undo-tree-history-directory-alist
        `(("." . ,(expand-file-name "undo-tree" user-emacs-directory))))
  (setcar (cdr (assq 'undo-tree-mode minor-mode-alist))
          undo-tree-mode-lighter))
(global-undo-tree-mode)
(global-set-key (kbd "C-x u") #'undo-tree-visualize)
(global-set-key (kbd "C-_") #'undo-tree)
(global-set-key (kbd "M-_") #'redo-tree)
#+end_src

*** /orderless/

#+begin_src elisp
(require 'orderless)
;; this file overides completion-category-defaults
(require 'message)

(setq orderless-matching-styles '(orderless-regexp orderless-flex)
      ;; consult integration
      orderless-component-separator (lambda (input)
                                      (mapcar
                                       (lambda (component)
                                         (replace-regexp-in-string " +-- .*\\'" "" component t))
                                       (split-string-and-unquote input ",+")))
      orderless-style-dispatchers nil
      completion-styles '(orderless)
      completion-flex-nospace nil
      completion-category-defaults nil
      completion-ignore-case t
      read-buffer-completion-ignore-case t
      read-file-name-completion-ignore-case t)

(defun orderless-first-regexp (pattern index _total)
  (if (= index 0) 'orderless-regexp))

(defun orderless-first-literal (pattern index _total)
  (if (= index 0) 'orderless-literal))

(defun orderless-match-reset ()
  (unless (or completion-in-region-mode
              (eq orderless-matching-styles '(orderless-regexp orderless-flex)))
    (setq orderless-matching-styles '(orderless-regexp orderless-flex))))
(add-hook 'completion-in-region-mode-hook 'orderless-match-reset)
(add-hook 'minibuffer-exit-hook 'orderless-match-reset)

(defun orderless-match-components-cycle ()
  "Components match regexp for the rest of the session."
  (interactive)
  (cond
   ;; first in cycle
   ((equal orderless-matching-styles '(orderless-regexp orderless-flex))
    (setq orderless-matching-styles '(orderless-regexp)
          orderless-style-dispatchers nil)
    (message "orderless-regexp"))
   ;; second in cycle
   ((equal orderless-matching-styles '(orderless-regexp))
    (setq orderless-matching-styles '(orderless-literal))
    (message "orderless-literal"))
   ;; third in cycle
   ((equal orderless-matching-styles '(orderless-literal))
    (setq orderless-matching-styles '(orderless-flex))
    (message "orderless-flex"))
   ;; last in cycle
   ((equal orderless-matching-styles '(orderless-flex))
    (setq orderless-matching-styles '(orderless-regexp orderless-flex))
    (message "orderless-regexp orderless-flex")))
  (cond 
   (icomplete-mode
    (completion--flush-all-sorted-completions)
    (icomplete-pre-command-hook)
    (icomplete-post-command-hook))
   ((bound-and-true-p vertico-mode)
    (vertico--update-candidates 
     (max 0 (- (point) (minibuffer-prompt-end))) 
     (minibuffer-contents-no-properties)))))

(define-key minibuffer-local-completion-map (kbd "C-o")
  'orderless-match-components-cycle)
(define-key completion-in-region-mode-map (kbd "C-o")
  'orderless-match-components-cycle)
#+end_src

*** /vertico-mode/ (when installed)

#+begin_src elisp
(when (require 'vertico nil t)
  (require 'vertico-grid)
  ;;(require 'vertico-autoloads nil t)

  (setq completion-styles '(orderless)
        completion-category-overrides '((file (styles basic-remote partial-completion)))
        completion-in-region-function
        (lambda (&rest args)
          (apply (if vertico-mode
                     #'consult-completion-in-region
                   #'completion--in-region)
                 args))
        vertico-grid-rows 5
        vertico-grid-min-columns 4)

  (defun basic-remote-try-completion (string table pred point)
    (and (vertico--remote-p string)
         (completion-basic-try-completion string table pred point)))
  (defun basic-remote-all-completions (string table pred point)
    (and (vertico--remote-p string)
         (completion-basic-all-completions string table pred point)))
  (add-to-list
   'completion-styles-alist
   '(basic-remote basic-remote-try-completion basic-remote-all-completions nil))

  (define-key vertico-map (kbd "C-o") 'orderless-match-components-cycle)
  (define-key vertico-map (kbd "M-z") 'vertico-quick-exit)

  ;;(vertico-grid-mode)
  (vertico-mode))
#+end_src

*** /tree-sitter/

#+begin_src elisp
;; (add-hook 'emacs-lisp-mode-hook #'tree-sitter-mode)
;; (add-hook 'lisp-mode-hook #'tree-sitter-mode)
;; (add-hook 'rust-mode-hook #'tree-sitter-mode)
;; (add-hook 'python-mode-hook #'tree-sitter-mode)
;; (add-hook 'typescript-mode-hook #'tree-sitter-mode)
;; (add-hook 'js-mode-hook #'tree-sitter-mode)
;; (add-hook 'json-mode-hook #'tree-sitter-mode)
;; (add-hook 'html-mode-hook #'tree-sitter-mode)
;; (add-hook 'nxhtml-mode-hook #'tree-sitter-mode)
;; (add-hook 'c-mode-hook #'tree-sitter-mode)
(defun tree-sitter-startup:tmp ()
  (require 'tree-sitter)
  (require 'tree-sitter-langs)
  (global-tree-sitter-mode)

  (remove-hook 'find-file-hook 'tree-sitter-startup:tmp)
  (fmakunbound 'tree-sitter-startup:tmp))
(add-hook 'find-file-hook 'tree-sitter-startup:tmp)
#+end_src

*** CANC /helm/
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
(when (load "helm" t)
  (customize-set-variable 'helm-ff-keep-cached-candidates nil)
  (setq helm-completion-mode-string ""
        helm-split-window-inside-p t
        helm-always-two-windows nil
        helm-reuse-last-window-split-state t
        ;; helm-display-function 'helm-display-buffer-in-own-frame
        ;; helm-display-function 'helm-display-buffer-popup-frame ;; transparent
        helm-autoresize-max-height 60
        helm-autoresize-min-height 6
        helm-candidate-number-limit 150
        helm-echo-input-in-header-line nil
        helm-display-header-line nil
        helm-default-display-buffer-functions '(display-buffer-in-side-window))
  ;; [ <input line on top>
  ;; (add-hook 'helm-minibuffer-set-up-hook 'helm-hide-minibuffer-maybe)
  ;; ]
  ;; (push '("\\`\\*helm.*\\*\\'" (display-buffer-in-side-window)) display-buffer-alist)
  ;; (push '("\\`\\*helm help\\*\\'" (display-buffer-pop-up-window)) display-buffer-alist)

  (set-face-attribute 'helm-source-header nil
                      :family 'unspecified
                      :height 'unspecified
                      :weight 'unspecified
                      :foreground "white"
                      :background "slate gray")

  ;; (defun helm-insert-utf8 ()
  ;;   (interactive)
  ;;   (let ((utf8-hash-table (ucs-names)))
  ;;     (helm :sources
  ;;           `((name . "Unicode character by name")
  ;;             (candidates . ,(hash-table-keys utf8-hash-table))
  ;;             (action . (lambda (key) (insert (gethash key ,utf8-hash-table))))))))

  (require 'helm-config)
  (require 'helm-mode)
  (helm-mode 1)
  (helm-autoresize-mode 1)
  (define-key global-map [remap execute-extended-command] 'helm-M-x)
  (define-key global-map (kbd "C-x C-r") 'helm-recentf)
  (cond ((fboundp 'helm-rg)
         (define-key global-map (kbd "M-g a") 'helm-rg))
        ((fboundp 'helm-ag)
         (define-key global-map (kbd "M-g a") 'helm-ag))
        (t
         (define-key global-map (kbd "M-g a") 'helm-do-grep-ag)))
  (define-key global-map (kbd "C-h SPC") 'helm-all-mark-rings)

  (with-eval-after-load 'company
    (define-key company-mode-map (kbd "C-:") 'helm-company)
    (define-key company-active-map (kbd "C-:") 'helm-company))

  (with-eval-after-load 'flycheck
    (when (fboundp 'helm-flycheck)
      (define-key flycheck-mode-map (kbd "C-c ! h") 'helm-flycheck)))

  (with-eval-after-load 'org
    (require 'helm-org)
    (add-to-list 'helm-completing-read-handlers-alist '(org-capture . helm-org-completing-read-tags))
    (add-to-list 'helm-completing-read-handlers-alist '(org-set-tags . helm-org-completing-read-tags)))

  (with-eval-after-load 'helm-fd
    (unless helm-fd-bin
      (setq helm-fd-bin (or (executable-find "fdfind")
                            (executable-find "fd-find")
                            (executable-find "fd")))))

  (with-eval-after-load 'projectile
    (require 'helm-projectile)
    (cond ((fboundp 'helm-rg)
           (define-key projectile-mode-map (kbd "M-g M-a") 'helm-projectile-rg))
          ((fboundp 'helm-ag)
           (define-key projectile-mode-map (kbd "M-g M-a") 'helm-projectile-ag))
          (t
           (define-key projectile-mode-map (kbd "M-g M-a") 'helm-projectile-grep)))
    (define-key projectile-mode-map (kbd "M-g M-f") (if (fboundp 'helm-fd-project)
                                                        'helm-fd-project
                                                      'helm-projectile-find-file))
    (helm-projectile-on))

  (require 'helm-xref nil 'noerror)

  (require 'helm-elisp)
  (setq helm-show-completion-display-function #'helm-show-completion-default-display-function)

  (when (executable-find "rg")
    (require 'helm-grep)
    (setq helm-grep-ag-command
          "rg --color=always --colors 'match:bg:yellow' --colors 'match:fg:black' --smart-case --no-heading --line-number %s %s %s"
          helm-grep-ag-pipe-cmd-switches
          '("--colors 'match:fg:black'" "--colors 'match:bg:yellow'"))
    (when (fboundp 'helm-ag)
      (require 'helm-ag)
      (setq helm-ag-base-command "rg --color=never --smart-case --no-heading --line-number"
            helm-ag-success-exit-status '(0 2))
      (with-eval-after-load 'helm-projectile
        (when (bug-check-function-bytecode
               'helm-projectile-ag
               "xMXGxyODPADIIIM4AMnKIAgiGMnLIAkiGczNzggJzyBBQCPQIwrQAtAFsAUaxhvR0iDPIEAiLIfT1CGH1dYhhVMA1zFPANjFIYjZASEwh4jT2iGH")
          (defun helm-projectile-ag (&optional options)
            "Helm version of `projectile-ag'."
            (interactive (if current-prefix-arg (list (helm-read-string "option: " "" 'helm-ag--extra-options-history))))
            (if (projectile-project-p)
                (let ((helm-ag-base-command (concat helm-ag-base-command " " options))
                      (current-prefix-arg nil))
                  (helm-do-ag (projectile-project-root) (car (projectile-parse-dirconfig-file))))
              (error "You're not in a project")))))))

  (if (null (fboundp 'helm-swoop))
      (progn
        (global-set-key (kbd "M-i") 'helm-occur)
        (global-set-key (kbd "C-x M-i") 'helm-occur-from-isearch)
        (global-set-key (kbd "M-I") 'helm-occur-visible-buffers))
    (require 'helm-swoop)
    (setq helm-swoop-split-with-multiple-windows nil
          helm-swoop-split-direction 'split-window-vertically
          helm-swoop-split-window-function 'helm-default-display-buffer
          helm-swoop-min-overlay-length 1
          helm-swoop-speed-or-color t
          helm-swoop-use-line-number-face t)
    ;; Change the keybinds to whatever you like :)
    (global-set-key (kbd "M-i") 'helm-swoop)
    (global-set-key (kbd "M-I") 'helm-swoop-back-to-last-point)
    (global-set-key (kbd "C-c M-i") 'helm-multi-swoop)
    (global-set-key (kbd "C-x M-i") 'helm-multi-swoop-all)
    ;; When doing isearch, hand the word over to helm-swoop
    (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
    ;; From helm-swoop to helm-multi-swoop-all
    (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)
    ;; When doing evil-search, hand the word over to helm-swoop
    ;; (define-key evil-motion-state-map (kbd "M-i") 'helm-swoop-from-evil-search)
    ;; Instead of helm-multi-swoop-all, you can also use helm-multi-swoop-current-mode
    (define-key helm-swoop-map (kbd "M-m") 'helm-multi-swoop-current-mode-from-helm-swoop)
    ;; Move up and down like isearch
    (define-key helm-swoop-map (kbd "C-r") 'helm-previous-line)
    (define-key helm-swoop-map (kbd "C-s") 'helm-next-line)
    (define-key helm-multi-swoop-map (kbd "C-r") 'helm-previous-line)
    (define-key helm-multi-swoop-map (kbd "C-s") 'helm-next-line)
    ;; Go to the opposite side of line from the end or beginning of line
    (setq helm-swoop-move-to-line-cycle t))

  ;; [ child frame
  (when (display-graphic-p)
    ;; child frame compatibility
    (defun helm-initial-and-internal-advice (orig-fun &rest args)
      (let ((parent-frame (cdr (assoc 'parent-frame (frame-parameters (selected-frame)) 'eq))))
        (if parent-frame
            (with-selected-frame parent-frame
              (apply orig-fun args))
          (apply orig-fun args))))
    (advice-add 'helm-initial-setup :around 'helm-initial-and-internal-advice)
    (advice-add 'helm-internal :around 'helm-initial-and-internal-advice)
    ;; postframe integration
    (when (load "helm-posframe" t)
      (add-hook 'helm-org-rifle-after-command-hook 'helm-posframe-cleanup)
      (remove-hook 'delete-frame-functions 'helm--delete-frame-function)
      ;; (define-key helm-map (kbd "C-i") 'undefined)
      (setq helm-show-action-window-other-window 'right
            helm-posframe-poshandler 'posframe-poshandler-frame-center
            helm-posframe-parameters '((internal-border-width .     5)
                                       (z-group               . above)))

      (defun helm-show-action-buffer-advice (orig-fun &rest args)
        (let ((helm--buffer-in-new-frame-p t)
              (helm-split-window-state 'vertical))
          (apply orig-fun args)))
      (advice-add 'helm-show-action-buffer :around 'helm-show-action-buffer-advice)

      (defun helm-execute-persistent-action-advice (orig-fun &rest args)
        (let ((helm--buffer-in-new-frame-p t))
          (apply orig-fun args)))
      (advice-add 'helm-execute-persistent-action :around 'helm-execute-persistent-action-advice)
      (helm-posframe-enable)))
  ;; ]

  (add-hook 'helm-after-initialize-hook #'helm-init-relative-display-line-numbers))

#+end_src

*** CANC /gcmh/
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
(add-hook 'emacs-startup-hook
          (lambda ()
            (require 'gcmh)
            (setq minor-mode-alist
                  (cl-delete 'gcmh-mode minor-mode-alist :key 'car))
            (setq gcmh-idle-delay 20
                  gcmh-verbose t
                  gcmh-low-cons-threshold ,gc-cons-threshold
                  gcmh-high-cons-threshold (eval-when-compile
                                             (* 10 1024 1024)))
            (gcmh-mode 1)))
#+end_src

*** /cyphejor/ (when installed)

#+begin_src elisp
(when (require 'cyphejor nil t)
  (setq cyphejor-rules
        '(:upcase
          ("bookmark"    "→")
          ("buffer"      "β")
          ("c"           "ȼ")
          ("csv"         ",")
          ("diff"        "Δ")
          ("dired"       "δ")
          ("elfeed"      "📰")
          ("emacs"       "ε")
          ("emms"        "♪")
          ("eshell"      "ε∫" :postfix)
          ("exwm"        "χ")
          ("fish"        "φ")
          ("fundamental" "∅")
          ("help"        "?")
          ("inferior"    "i" :prefix)
          ("interaction" "i" :prefix)
          ("interactive" "i" :prefix)
          ("lisp"        "λ" :postfix)
          ("menu"        "▤" :postfix)
          ("mode"        "")
          ("nim"         "ℵ")
          ("org"         "Ω")
          ("package"     "↓")
          ("python"      "π")
          ("rust"        "⚙")
          ("search"      "🔍")
          ("sh"          "$")
          ("shell"       "∫" :postfix)
          ("show"        "✓")
          ("text"        "ξ")
          ("tsv"         "↹")
          ("typescript"  "TS")
          ("wdired"      "↯δ")
          ("web"         "ω")
          ("yaml"        "Ⲩ")
          ))
  (cyphejor-mode))
#+end_src

*** CANC /modal/
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
(require 'modal)

(setq modal-insert-cursor-type 'box
      modal-cursor-type 'hollow
      modal-excluded-modes '(buffer-menu-mode
                             ibuffer-mode
                             ;; package-menu-mode
                             ;; debugger-mode
                             ;; dired-mode
                             ediff-mode
                             ;; eshell-mode
                             ;; org-agenda-mode
                             ;; git-rebase-mode
                             ;; docker-container-mode
                             magit-popup-mode
                             ;; magit-mode
                             ;; magit-process-mode
                             ;; magit-status-mode
                             calc-mode)
      modal-insertp-functions '(sp-rewrap-sexp-lc
                                sp-unwrap-sexp-lc
                                comment-dwim
                                undo-tree-undo
                                undo-tree-redo
                                query-replace
                                duplicate-current-line-or-region
                                delete-forward-char
                                electric-newline-and-maybe-indent
                                kill-line
                                newline
                                open-line
                                quoted-insert
                                transpose-chars
                                kill-region
                                transpose-sexps))


(defun keyboard-esc-quit ()
  "Exit the current \"mode\" (in a generalized sense of the word).
This command can exit an interactive command such as `query-replace',
can clear out a prefix argument or a region,
can get out of the minibuffer or other recursive edit,
cancel the use of the current buffer (for special-purpose buffers)."
  (interactive)
  (cond ((eq last-command 'mode-exited) nil)
        ((region-active-p)
         (deactivate-mark))
        ((> (minibuffer-depth) 0)
         (abort-recursive-edit))
        (current-prefix-arg
         nil)
        ((> (recursion-depth) 0)
         (exit-recursive-edit))
        (buffer-quit-function
         (funcall buffer-quit-function))
        (t (keyboard-quit))))

;;;;;;;;;;
;; Keys ;;
;;;;;;;;;;
;; company
(defun modal-config-company-enable ()
  (define-key company-active-map "G" 'company-abort)
  (define-key company-active-map "H" 'company-show-doc-buffer)
  (define-key company-active-map "W" 'company-show-location)
  (define-key company-active-map "S" 'company-search-candidates)
  (define-key company-active-map "\M-S" 'company-filter-candidates)

  (define-key company-search-map "G" 'company-search-abort)
  (define-key company-search-map "S" 'company-search-repeat-forward)
  (define-key company-search-map "R" 'company-search-repeat-backward)
  (define-key company-search-map "O" 'company-search-toggle-filtering))
(with-eval-after-load 'company
  (if modal-mode
      (modal-config-company-enable)))

;; transient
(with-eval-after-load 'transient
  (if modal-mode
      (define-key transient-map "G" 'transient-quit-one)))
;; magit-popup
(with-eval-after-load 'magit-popup
  (if modal-mode
      (define-key magit-popup-mode-map "G" 'magit-popup-quit)))

(defun modal-mode-bind-higher-priority-maps ()
  (if modal-mode
      (progn
        ;; read-key
        (define-key function-key-map "G" "\C-g")
        ;; universal-argument
        (define-key universal-argument-map "U" #'universal-argument-more)
        ;; indent-rigidly
        (define-key indent-rigidly-map "F" #'indent-rigidly-right-to-tab-stop)
        (define-key indent-rigidly-map "B" #'indent-rigidly-left-to-tab-stop)
        (define-key indent-rigidly-map "f" #'indent-rigidly-right)
        (define-key indent-rigidly-map "b" #'indent-rigidly-left)
        ;; company
        (when (boundp 'company-active-map)
          (modal-config-company-enable))
        ;; transient
        (when (boundp 'transient-map)
          (define-key transient-map "G" 'transient-quit-one))
        ;; magit-popup
        (when (boundp 'magit-popup-mode-map)
          (define-key magit-popup-mode-map "G" 'magit-popup-quit)))
    ;; read-key
    (define-key function-key-map "G" nil)
    ;; universal-argument
    (define-key universal-argument-map "U" nil)
    ;; indent-rigidly
    (define-key indent-rigidly-map "F" nil)
    (define-key indent-rigidly-map "B" nil)
    (define-key indent-rigidly-map "f" nil)
    (define-key indent-rigidly-map "b" nil)
    ;; company
    (when (boundp 'company-active-map)
      (define-key company-active-map "G" nil)
      (define-key company-active-map "H" nil)
      (define-key company-active-map "W" nil)
      (define-key company-active-map "S" nil)
      (define-key company-active-map "\M-S" nil)

      (define-key company-search-map "G" nil)
      (define-key company-search-map "S" nil)
      (define-key company-search-map "R" nil)
      (define-key company-search-map "O" nil))
    ;; transient
    (when (boundp 'transient-map)
      (define-key transient-map "G" nil))
    ;; magit-popup
    (when (boundp 'magit-popup-mode-map)
          (define-key magit-popup-mode-map "G" nil))))
(add-hook 'modal-mode-hook 'modal-mode-bind-higher-priority-maps)

;; Modal editing
;; ' (handy as self-inserting symbol)
;; " (handy as self-inserting symbol)
(modal-define-key (kbd "M .") #'imenu-anywhere)
(modal-define-key (kbd "M (") #'sp-rewrap-sexp-lc)
(modal-define-key (kbd "M )") #'sp-unwrap-sexp-lc)
(modal-define-key (kbd "M &") #'rotate-or-inflection)
(modal-define-key (kbd "M ?") #'goto-last-change-reverse)
(modal-define-key (kbd "M /") #'goto-last-change)
;; (modal-define-kbd "." "M-." "definition-at-point")
;; (modal-define-key (kbd ";") (kbd "M-;"))  ;; comment-dwim
;; (modal-define-key (kbd ":") (kbd "M-:"))  ;; eval-expression
(modal-define-key (kbd "M +") #'fold-dwim)
(modal-define-key (kbd "M _") (kbd "C-_"))  ;; undo-tree-undo
;; (modal-define-key (kbd "_") (kbd "M-_"))  ;; undo-tree-redo
;; (modal-define-key (kbd "%") (kbd "M-%"))  ;; query-replace
(modal-define-key (kbd "M *") (kbd "C-*"))  ;; duplicate-current-line-or-region
;; (modal-define-key (kbd "<") (kbd "M-<"))  ;; beginning-of-buffer
;; (modal-define-key (kbd ">") (kbd "M->"))  ;; end-of-buffer
(modal-define-key (kbd "M %") (kbd "C-M-%")) ;; query-replace-regexp
(modal-define-key (kbd "M k h") #'sp-kill-hybrid-sexp)
(modal-define-key (kbd "M k l") (kbd "<C-S-backspace>")) ;; kill-whole-line
(modal-define-key (kbd "M k s") #'kill-to-end-of-sexp)
(modal-define-key (kbd "M k S") #'kill-to-begin-of-sexp)
;; (modal-define-key (kbd "S-SPC") (kbd "C-SPC"))  ;; set-mark-command

(modal-define-key (kbd "A") (kbd "C-a"))  ;; move-beginning-of-line
(modal-define-key (kbd "B") (kbd "C-b"))  ;; backward-char
;; (modal-define-key "\M-b" 'backward-word)
;; c - [ command prefix
(modal-define-key (kbd "C %") (kbd "C-c %"))  ;; org-mark-ring-push
(modal-define-key (kbd "C &") (kbd "C-c &"))  ;; org-mark-ring-goto
(modal-define-key (kbd "C TAB") (kbd "C-c TAB"))  ;; org-show-subtree
(modal-define-key (kbd "C <backtab>") (kbd "C-c <backtab>"))  ;; org-show-all
(modal-define-key (kbd "C '") (kbd "C-c '"))
;; [ equivalent
(modal-define-key (kbd "C !") (kbd "C-c !"))
;; (modal-define-key (kbd "C ! c") #'flycheck-buffer)
;; (modal-define-key (kbd "C ! n") #'flycheck-next-error)
;; (modal-define-key (kbd "C ! p") #'flycheck-previous-error)
;; (modal-define-key (kbd "C ! l") #'flycheck-list-errors)
;; ]
(modal-define-key (kbd "C ,") (kbd "C-c ,"))
(modal-define-key (kbd "C M ,") (kbd "C-c C-,"))  ;; org-insert-structure-template
(modal-define-key (kbd "C A") (kbd "C-c C-a"))
(modal-define-key (kbd "C a") (kbd "C-c a"))  ;; org-agenda
(modal-define-key (kbd "C B") (kbd "C-c C-b"))  ;; go-back
(modal-define-key (kbd "C M-b") (kbd "C-c M-b"))  ;; org-previous-block
(modal-define-key (kbd "C C") (kbd "C-c C-c"))  ;; confirm-commit
(modal-define-key (kbd "C e w") #'er/mark-word)
(modal-define-key (kbd "C e s") #'er/mark-symbol)
(modal-define-key (kbd "C e c") #'er/mark-method-call)
(modal-define-key (kbd "C e q") #'er/mark-inside-quotes)
(modal-define-key (kbd "C e Q") #'er/mark-outside-quotes)
(modal-define-key (kbd "C e p") #'er/mark-inside-pairs)
(modal-define-key (kbd "C e P") #'er/mark-outside-pairs)
(modal-define-key (kbd "C F") (kbd "C-c C-f"))  ;; org-forward-heading-same-level
(modal-define-key (kbd "C M-f") (kbd "C-c M-f"))  ;; org-next-block
;; [ equivalent
(modal-define-key (kbd "C i") (kbd "C-c i"))
;; (modal-define-key (kbd "C i s") #'spanish-dictionary)
;; (modal-define-key (kbd "C i e") #'english-dictionary)
;; (modal-define-key (kbd "C i c") #'flyspell-buffer)
;; (modal-define-key (kbd "C i n") #'flyspell-goto-next-error)
;; (modal-define-key (kbd "C i p") #'flyspell-goto-previous-error)
;; (modal-define-key (kbd "C i a") #'flyspell-auto-correct-word)
;; ]
(modal-define-key (kbd "C K") (kbd "C-c C-k"))  ;; cancel-commit
(modal-define-key (kbd "C l") (kbd "C-c l"))  ;; org-store-link
(modal-define-key (kbd "C L") (kbd "C-c C-l"))  ;; org-insert-link
(modal-define-key (kbd "C m p") #'mc/mark-previous-like-this)
(modal-define-key (kbd "C m n") #'mc/mark-next-like-this)
(modal-define-key (kbd "C m a") #'mc/mark-all-like-this-dwim)
(modal-define-key (kbd "C N") (kbd "C-c C-n"))  ;; smartscan-symbol-go-forward or org-next-visible-heading
(modal-define-key (kbd "C o") #'operate-on-number-at-point-or-region)
(modal-define-key (kbd "C O") (kbd "C-c C-o"))  ;; org-open-at-point
(modal-define-key (kbd "C P") (kbd "C-c C-p"))  ;; smartscan-symbol-go-backward or org-previous-visible-heading
(modal-define-key (kbd "C Q") (kbd "C-c C-q"))
(modal-define-key (kbd "C M-s") (kbd "C-c M-s"))  ;; org-sort-entries-user-defined
(modal-define-key (kbd "C M-r") #'revert-buffer)
(modal-define-key (kbd "C S") (kbd "C-c C-s"))  ;; org-schedule
(modal-define-key (kbd "C D") (kbd "C-c C-d"))  ;; org-deadline
(modal-define-key (kbd "C T") (kbd "C-c C-t"))  ;; org-todo
(modal-define-key (kbd "C U") (kbd "C-c C-u"))  ;; outline-up-heading
;; [ equivalent
(modal-define-key (kbd "C v") (kbd "C-c v"))
;; (modal-define-key (kbd "C v *") #'vimish-fold-unfold-all)
;; (modal-define-key (kbd "C v +") #'vimish-fold-unfold)
;; (modal-define-key (kbd "C v -") #'vimish-fold-refold)
;; (modal-define-key (kbd "C v _") #'vimish-fold-refold-all)
;; (modal-define-key (kbd "C v .") #'vimish-fold-toggle)
;; (modal-define-key (kbd "C v :") #'vimish-fold-toggle-all)
;; (modal-define-key (kbd "C v d") #'vimish-fold-delete)
;; (modal-define-key (kbd "C v D") #'vimish-fold-delete-all)
;; (modal-define-key (kbd "C v f") #'vimish-fold)
;; (modal-define-key (kbd "C v G") #'vimish-fold-avy)
;; (modal-define-key (kbd "C v p") #'vimish-fold-previous-fold)
;; (modal-define-key (kbd "C v n") #'vimish-fold-next-fold)
;; (modal-define-key (kbd "C v s") (kbd "C-c v s"))  ;; org-block-and-result-show-all
;; (modal-define-key (kbd "C v h") (kbd "C-c v h"))  ;; org-block-and-result-hide-all
;; ]
(modal-define-key (kbd "C w -") #'winner-undo)
(modal-define-key (kbd "C w _") #'winner-redo)
(modal-define-key (kbd "C w 2") 'shell-2-window-frame)
(modal-define-key (kbd "C w 3") 'shell-3-window-frame)
(modal-define-key (kbd "C w a") #'toggle-hscroll-aggressive)
(modal-define-key (kbd "C w B") #'windmove-left)
(modal-define-key (kbd "C w d a") #'window-dedicate-all)
(modal-define-key (kbd "C w d t") #'window-dedicate-this)
(modal-define-key (kbd "C V j") (kbd "C-c C-v j"))  ;; org-babel-insert-header-arg
(modal-define-key (kbd "C V J") (kbd "C-c C-v C-j"))  ;; org-babel-insert-header-arg
(modal-define-key (kbd "C V k") (kbd "C-c C-v k"))  ;; org-babel-remove-result
(modal-define-key (kbd "C V K") (kbd "C-c C-v C-k"))  ;; org-babel-remove-result
(modal-define-key (kbd "C V o") (kbd "C-c C-v o"))  ;; org-babel-open-src-block-result
(modal-define-key (kbd "C V O") (kbd "C-c C-v C-o"))  ;; org-babel-open-src-block-result
(modal-define-key (kbd "C V p") (kbd "C-c C-v p"))  ;; org-babel-previous-src-block
(modal-define-key (kbd "C V P") (kbd "C-c C-v C-p"))  ;; org-babel-previous-src-block
(modal-define-key (kbd "C V n") (kbd "C-c C-v n"))  ;; org-babel-next-src-block
(modal-define-key (kbd "C V N") (kbd "C-c C-v C-n"))  ;; org-babel-next-src-block
(modal-define-key (kbd "C w F") #'windmove-right)
(modal-define-key (kbd "C w H") #'window-resize-height)
(modal-define-key (kbd "C w h") #'flop-frame)
(modal-define-key (kbd "C w N") #'windmove-down)
(modal-define-key (kbd "C w o") #'halve-other-window-height)
(modal-define-key (kbd "C w P") #'windmove-up)
(modal-define-key (kbd "C w R") #'rotate-frame-anticlockwise)
(modal-define-key (kbd "C w r") #'rotate-frame-clockwise)
(modal-define-key (kbd "C w t") #'transpose-frame)
(modal-define-key (kbd "C w u a") #'window-undedicate-all)
(modal-define-key (kbd "C w u t") #'window-undedicate-this)
(modal-define-key (kbd "C w v") #'flip-frame)
(modal-define-key (kbd "C w W") #'window-resize-width)
(modal-define-key (kbd "C X D") (kbd "C-c C-x C-d"))  ;; org-clock-display
(modal-define-key (kbd "C X E") (kbd "C-c C-x C-e"))  ;; org-clock-modify-effort-estimate
(modal-define-key (kbd "C X I") (kbd "C-c C-x C-i"))  ;; org-clock-in
(modal-define-key (kbd "C X J") (kbd "C-c C-x C-j"))  ;; org-clock-goto
(modal-define-key (kbd "C X K") (kbd "C-c C-x C-k"))  ;; org-toggle-link-display
(modal-define-key (kbd "C X N") (kbd "C-c C-x C-n"))  ;; org-next-link
(modal-define-key (kbd "C X O") (kbd "C-c C-x C-o"))  ;; org-clock-out
(modal-define-key (kbd "C X P") (kbd "C-c C-x C-p"))  ;; org-previous-link
(modal-define-key (kbd "C X Q") (kbd "C-c C-x C-q"))  ;; org-clock-cancel
(modal-define-key (kbd "C X S") (kbd "C-c C-x C-s"))  ;; org-archive-subtree
(modal-define-key (kbd "C X V") (kbd "C-c C-x C-v"))  ;; org-toggle-inline-images
(modal-define-key (kbd "C X X") (kbd "C-c C-x C-x"))  ;; org-clock-in-last
;; c - ] command prefix
(modal-define-key (kbd "C") (kbd "C-c"))  ;; ido-case-fold
(modal-define-key (kbd "D") (kbd "<deletechar>"))  ;; delete-forward-char
(modal-define-key (kbd "E") (kbd "C-e"))  ;; move-end-of-line
(modal-define-key (kbd "F") (kbd "C-f"))  ;; forward-char
;; (modal-define-key "\M-f" 'forward-word)
(modal-define-key (kbd "G") (kbd "C-g"))
;; h - [ prefix
;; [ equivalent
(modal-define-key (kbd "H") (kbd "C-h"))
;; (modal-define-key (kbd "H b") #'describe-bindings)
;; (modal-define-key (kbd "H e") #'view-echo-area-messages)
;; (modal-define-key (kbd "H f") #'describe-function)
;; (modal-define-key (kbd "H k") #'describe-key)
;; (modal-define-key (kbd "H L") #'describe-language-environment)
;; (modal-define-key (kbd "H m") #'describe-mode)
;; (modal-define-key (kbd "H o") #'describe-symbol)
;; (modal-define-key (kbd "H P") #'describe-package)
;; (modal-define-key (kbd "H s") #'describe-syntax)
;; (modal-define-key (kbd "H v") #'describe-variable)
;; ]
;; h - ] prefix
(modal-define-key (kbd "I") (kbd "C-i"))  ;; indent-for-tab-command
(modal-define-key (kbd "J") (kbd "C-j"))  ;; electric-newline-and-maybe-indent
(modal-define-key (kbd "K") (kbd "C-k"))  ;; kill-line
(modal-define-key (kbd "L") (kbd "C-l"))  ;; recenter-top-bottom
;; (modal-define-key (kbd "M") (kbd "C-m"))  ;; newline
(modal-define-key (kbd "N") (kbd "C-n"))  ;; next-line
(modal-define-key (kbd "Ñ") #'find-next-unsafe-char)
(modal-define-key (kbd "O") (kbd "C-o"))  ;; open-line
(modal-define-key (kbd "P") (kbd "C-p"))  ;; previous-line
(modal-define-key (kbd "Q") (kbd "C-q"))  ;; quoted-insert
(modal-define-key (kbd "R") (kbd "C-r"))  ;; isearch-backward
(modal-define-key (kbd "S") (kbd "C-s"))  ;; isearch-forward
(modal-define-key (kbd "T") (kbd "C-t"))  ;; transpose-chars
(modal-define-key (kbd "U") (kbd "C-u"))  ;; universal-argument
(modal-define-key (kbd "V") (kbd "C-v"))  ;; scroll-up-command
(modal-define-key (kbd "W") (kbd "C-w"))  ;; kill-region
;; x - [ command prefix
(modal-define-key (kbd "X #") (kbd "C-x #"))  ;; server-edit
(modal-define-key (kbd "X TAB") (kbd "C-x TAB"))  ;; indent-rigidly
(modal-define-key (kbd "X <backtab>") (kbd "C-x <C-tab>"))  ;; align-regexp
(modal-define-key (kbd "X RET") (kbd "C-x C-o"))  ;; delete-blank-lines
(modal-define-key (kbd "X S-SPC") (kbd "C-x C-SPC"))  ;; pop-global-mark
(modal-define-key (kbd "X SPC") (kbd "C-x SPC"))  ;; rectangle-mark-mode
(modal-define-key (kbd "X -") (kbd "C-x -"))  ;; shrink-window-if-larger-than-buffer
(modal-define-key (kbd "X <") (kbd "C-x <"))  ;; scroll-left
(modal-define-key (kbd "X >") (kbd "C-x >"))  ;; scroll-right
(modal-define-key (kbd "X ;") (kbd "C-x C-;"))  ;; comment-line
(modal-define-key (kbd "X (") (kbd "C-x ("))  ;; kmacro-start-macro
(modal-define-key (kbd "X )") (kbd "C-x )"))  ;; kmacro-end-macro
(modal-define-key (kbd "X ^") (kbd "C-x ^"))  ;; enlarge-window
(modal-define-key (kbd "X {") (kbd "C-x {"))  ;; shrink-window-horizontally
(modal-define-key (kbd "X }") (kbd "C-x }"))  ;; enlarge-window-horizontally
(modal-define-key (kbd "X +") (kbd "C-x +"))  ;; balance-windows
(modal-define-key (kbd "X 0") (kbd "C-x 0"))  ;; delete-window
(modal-define-key (kbd "X 1") (kbd "C-x 1"))  ;; delete-other-windows
(modal-define-key (kbd "X 2") (kbd "C-x 2"))  ;; vsplit-last-buffer
(modal-define-key (kbd "X 3") (kbd "C-x 3"))  ;; hsplit-last-buffer
(modal-define-key (kbd "X 4 F") (kbd "C-x 4 C-f"))  ;; ido-find-file-other-window
(modal-define-key (kbd "X 4 O") (kbd "C-x 4 C-o"))  ;; ido-display-buffer
(modal-define-key (kbd "X 4 b") (kbd "C-x 4 b"))  ;; ido-switch-buffer-other-window
(modal-define-key (kbd "X 5 F") (kbd "C-x 5 C-f"))  ;; ido-find-file-other-frame
(modal-define-key (kbd "X 5 O") (kbd "C-x 5 C-o"))  ;; ido-display-buffer-other-frame
(modal-define-key (kbd "X 5 0") (kbd "C-x 5 0"))  ;; delete-frame
(modal-define-key (kbd "X 5 1") (kbd "C-x 5 1"))  ;; delete-other-frame
(modal-define-key (kbd "X 5 2") (kbd "C-x 5 2"))  ;; make-frame-command
(modal-define-key (kbd "X 5 B") (kbd "C-x 5 B"))  ;; bookmark-jump-other-frame
(modal-define-key (kbd "X 5 b") (kbd "C-x 5 b"))  ;; ido-switch-buffer-other-frame
(modal-define-key (kbd "X 5 o") (kbd "C-x 5 o"))  ;; other-frame
(modal-define-key (kbd "X C") (kbd "C-x C-c"))  ;; save-buffers-kill-emacs
(modal-define-key (kbd "X c") (kbd "C-x c"))  ;; rotate-or-inflection
(modal-define-key (kbd "X B") 'ibuffer)
(modal-define-key (kbd "X b") (kbd "C-x b"))  ;; switch-buffer
(modal-define-key (kbd "X D") (kbd "C-x C-d"))  ;; list-directory
(modal-define-key (kbd "X d") (kbd "C-x d"))  ;; dired
(modal-define-key (kbd "X E") (kbd "C-x C-e"))  ;; eval-last-sexp
(modal-define-key (kbd "X e") (kbd "C-x e"))  ;; kmacro-end-and-call-macro
(modal-define-key (kbd "X F") (kbd "C-x C-f"))  ;; find-file
(modal-define-key (kbd "X f") (kbd "C-x f"))  ;; find-file-at-point
(modal-define-key (kbd "X h") (kbd "C-x h"))  ;; mark-whole-buffer
(modal-define-key (kbd "X i") (kbd "C-x i"))  ;; ido-insert-file
(modal-define-key (kbd "X K TAB") #'select-kbd-macro)
(modal-define-key (kbd "X K K") (kbd "C-x C-k C-k"))  ;; kmacro-end-or-call-macro-repeat
(modal-define-key (kbd "X K N") (kbd "C-x C-k C-n"))  ;; kmacro-cycle-ring-next
(modal-define-key (kbd "X K n") (kbd "C-x C-k n"))  ;; kmacro-name-last-macro
(modal-define-key (kbd "X K P") (kbd "C-x C-k C-p"))  ;; kmacro-cycle-ring-previous
(modal-define-key (kbd "X K V") (kbd "C-x C-k C-v"))  ;; kmacro-view-macro-repeat
(modal-define-key (kbd "X k") (kbd "C-x k"))  ;; kill-buffer
(modal-define-key (kbd "X L") (kbd "C-x C-l"))  ;; downcase-region
(modal-define-key (kbd "X M-l") (kbd "C-x M-l"))  ;; recenter-horizontal
(modal-define-key (kbd "X o") (kbd "C-x o"))  ;; other-window
(modal-define-key (kbd "X O") #'ff-find-other-file)
(modal-define-key (kbd "X P") (kbd "C-x C-p"))  ;; mark-page
(modal-define-key (kbd "X p s") (kbd "C-x p s"))  ;; bookmark-save
(modal-define-key (kbd "X Q") (kbd "C-x C-q"))  ;; read-only-mode
(modal-define-key (kbd "X R") (kbd "C-x C-r"))  ;; recentf-open
;; [ equivalent
(modal-define-key (kbd "X r") (kbd "C-x r"))
;; (modal-define-key (kbd "X r SPC") (kbd "C-x r SPC"))  ;; point-to-register
;; (modal-define-key (kbd "X r +") (kbd "C-x r +"))  ;; increment-register
;; (modal-define-key (kbd "X r b") (kbd "C-x r b"))  ;; bookmark-jump
;; (modal-define-key (kbd "X r c") (kbd "C-x r c"))  ;; clean-rectangle
;; (modal-define-key (kbd "X r d") (kbd "C-x r d"))  ;; delete-rectangle
;; (modal-define-key (kbd "X r f") (kbd "C-x r f"))  ;; frameset-to-register
;; (modal-define-key (kbd "X r i") (kbd "C-x r i"))  ;; insert-register
;; (modal-define-key (kbd "X r j") (kbd "C-x r j"))  ;; jump-to-register
;; (modal-define-key (kbd "X r k") (kbd "C-x r k"))  ;; kill-rectangle
;; (modal-define-key (kbd "X r l") (kbd "C-x r l"))  ;; list-bookmarks
;; (modal-define-key (kbd "X r m") (kbd "C-x r m"))  ;; bookmark-set
;; (modal-define-key (kbd "X r N") (kbd "C-x r N"))  ;; rectangle-number-lines
;; (modal-define-key (kbd "X r n") (kbd "C-x r n"))  ;; number-to-register
;; (modal-define-key (kbd "X r o") (kbd "C-x r o"))  ;; open-rectangle
;; (modal-define-key (kbd "X r r") (kbd "C-x r r"))  ;; copy-rectangle-to-register
;; (modal-define-key (kbd "X r s") (kbd "C-x r s"))  ;; copy-to-register
;; (modal-define-key (kbd "X r t") (kbd "C-x r t"))  ;; string-rectangle
;; (modal-define-key (kbd "X r U") (kbd "C-x r U"))  ;; undo-tree-restore-state-from-register
;; (modal-define-key (kbd "X r u") (kbd "C-x r u"))  ;; undo-tree-save-state-to-register
;; (modal-define-key (kbd "X r y") (kbd "C-x r y"))  ;; yank-rectangle
;; (modal-define-key (kbd "X r M-w") (kbd "C-x r M-w"))  ;; copy-rectangle-as-kill
;; ]
(modal-define-key (kbd "X S") (kbd "C-x C-s"))  ;; save-buffer
(modal-define-key (kbd "X s") (kbd "C-x s"))  ;; save-some-buffers
(modal-define-key (kbd "X U") (kbd "C-x C-u"))  ;; upcase-region
(modal-define-key (kbd "X v =") #'magit-diff)
(modal-define-key (kbd "X v b") #'magit-branch)
(modal-define-key (kbd "X v c") #'magit-checkout)
(modal-define-key (kbd "X v L") #'vc-print-root-log)
(modal-define-key (kbd "X v l") #'vc-print-log)
(modal-define-key (kbd "X v m") #'hydra-smerge/body)
(modal-define-key (kbd "X v P") #'magit-push)
(modal-define-key (kbd "X v p") #'magit-pull)
(modal-define-key (kbd "X v R") #'magit-rebase-continue)
(modal-define-key (kbd "X v r") #'magit-rebase)
(modal-define-key (kbd "X v v") #'magit-status)
(modal-define-key (kbd "X W") (kbd "C-x C-w"))  ;; write-file
(modal-define-key (kbd "X X") (kbd "C-x C-x"))  ;; exchange-point-and-mark
(modal-define-key (kbd "X z") (kbd "C-x z"))  ;; repeat
(modal-define-key (kbd "X M-0") (kbd "C-x C-0"))  ;; text-scale-adjust
(modal-define-key (kbd "X M-=") (kbd "C-x C-="))  ;; text-scale-adjust
(modal-define-key (kbd "X M--") (kbd "C-x C--"))  ;; text-scale-adjust
(modal-define-key (kbd "X M-+") (kbd "C-x C-+"))  ;; text-scale-adjust
;; x - ] command prefix
(modal-define-key (kbd "Y") (kbd "C-y"))  ;; yank
(modal-define-key (kbd "Z") (kbd "C-x z"))  ;; repeat (suspend-frame)

(modal-define-key (kbd "S-\\") (kbd "C-M-\\"))  ;; indent-region
(modal-define-key (kbd "S-@") (kbd "C-M-@"))  ;; mark-sexp
;; Caps-lock don't work with M-<Cap letter>, use Shift
(modal-define-key (kbd "M-A") (kbd "C-M-a"))  ;; beginning-of-defun
(modal-define-key (kbd "M-B") (kbd "C-M-b"))  ;; backward-sexp
(modal-define-key (kbd "M-C") (kbd "C-M-c"))  ;; exit-recursive-edit
(modal-define-key (kbd "M-D") (kbd "C-M-d"))  ;; down-list
(modal-define-key (kbd "M-E") (kbd "C-M-e"))  ;; end-of-defun
(modal-define-key (kbd "M-F") (kbd "C-M-f"))  ;; forward-sexp
;; G - [ command prefix
;; G - ] command prefix
(modal-define-key (kbd "M-H") (kbd "C-M-h"))  ;; mark-defun
(modal-define-key (kbd "M-I") (kbd "C-M-i"))  ;; completion-at-point/flyspell-auto-correct-word
(modal-define-key (kbd "M-J") (kbd "C-M-j"))  ;; indent-new-comment-line
(modal-define-key (kbd "M-K") (kbd "C-M-k"))  ;; kill-sexp
(modal-define-key (kbd "M-N") (kbd "C-M-n"))  ;; forward-list
(modal-define-key (kbd "M-L") (kbd "C-M-l"))  ;; reposition-window
(modal-define-key (kbd "M-O") (kbd "C-M-o"))  ;; split-line
(modal-define-key (kbd "M-P") (kbd "C-M-p"))  ;; backward-list
(modal-define-key (kbd "M-Q") "C-M-q")  ;; prog-indent-sexp
(modal-define-key (kbd "M-R") (kbd "C-M-r"))  ;; isearch-backward-regexp
(modal-define-key (kbd "M-S") (kbd "C-M-s"))  ;; isearch-forward-regexp
(modal-define-key (kbd "M-T") (kbd "C-M-t"))  ;; transpose-sexps
(modal-define-key (kbd "M-U") (kbd "C-M-u"))  ;; backward-up-list
(modal-define-key (kbd "M-V n") (kbd "C-M-v"))  ;; scroll-other-window
(modal-define-key (kbd "M-W") (kbd "C-M-w"))  ;; append-next-kill
(modal-define-key (kbd "M-X") (kbd "C-M-x"))  ;; eval-defun
;; Y - [ command prefix
;; Y - ] command prefix
;; Z - [ command prefix
;; Z - ] command prefix

;; (modal-define-key (kbd "M-Q") #'fill-paragraph)
(modal-define-key (kbd "M-V p") (kbd "C-M-S-v"))  ;; scroll-other-window-down

;;;;;;;;;;;;;;;
;; Caps keys ;;
;;;;;;;;;;;;;;;
;; (global-set-key "ª" 'modal-global-mode-post-command)
(modal-define-key "ª" #'caps-lock-mode)
(modal-define-key "º" #'caps-lock-mode-post-command)
;; Modal keys
;; (modal-define-key (kbd "µ") #'caps-lock-mode) ;; #'modal-global-mode-toggle)
;; (modal-define-key (kbd "<key-924>") #'caps-lock-mode) ;; #'modal-global-mode-toggle)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Make compatible with other modules ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define-key special-mode-map [?\S-\ ] nil)        ;; simple.el
(with-eval-after-load 'rmail
  (define-key rmail-mode-map [?\S-\ ] nil))       ;; rmail.el
(with-eval-after-load 'cus-edit
  (define-key custom-mode-map [?\S-\ ] nil)       ;; cus-edit.el
  (define-key custom-mode-link-map [?\S-\ ] nil)) ;; cus-edit.el
(mapc (lambda (keymap)
        (define-key keymap [?\S-\ ] nil))
      (keymaps-with-binding [?\S-\ ]))

;;;;;;;;;;;;;;;;
;; Ubiquitous ;;
;;;;;;;;;;;;;;;;
;; (setq isearch-mode-map (make-composed-keymap (copy-keymap modal-mode-map) isearch-mode-map)
;;       query-replace-map (make-composed-keymap (copy-keymap modal-mode-map) query-replace-map)
;;       function-key-map (make-composed-keymap (copy-keymap modal-mode-map) function-key-map)
;;       minibuffer-local-map (make-composed-keymap (copy-keymap modal-mode-map) minibuffer-local-map))

;;;;;;;;;;;;;;;;;;;
;; new quit bind ;;
;;;;;;;;;;;;;;;;;;;
;; (define-key query-replace-map "\M-q" 'quit)          ;; read-event
;; (define-key function-key-map "\M-q" "\C-g")          ;; read-key
;; (define-key isearch-mode-map "\M-q" 'isearch-abort)  ;; isearch-mode
;; ;; minibuffer keys
;; (define-key minibuffer-local-map "\M-q" 'abort-recursive-edit)
;; (define-key minibuffer-local-ns-map "\M-q" 'abort-recursive-edit)
;; (define-key minibuffer-local-isearch-map "\M-q" 'abort-recursive-edit)
;; (define-key minibuffer-local-completion-map "\M-q" 'abort-recursive-edit)
;; (define-key minibuffer-local-must-match-map "\M-q" 'abort-recursive-edit)
;; (define-key minibuffer-local-filename-completion-map "\M-q" 'abort-recursive-edit)
;; (global-set-key "\M-q" 'keyboard-quit)

;;;;;;;;;;;;;;;;;;;;;;
;; Globally enabled ;;
;;;;;;;;;;;;;;;;;;;;;;
(modal-global-mode 1)
#+end_src

*** CANC /objed/
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
(require 'objed)

;; (add-hook 'prog-mode-hook 'objed-local-mode)

(setq objed-init-p-function
      (lambda ()
        (and
         (not (minibufferp))
         (not (and (bobp) (eobp)))
         ;; don't interfere with other special modes
         ;; like hydra
         (not overriding-terminal-local-map)
         (not objed--block-p)
         (not objed-disabled-p)
         (not (apply 'derived-mode-p objed-disabled-modes))
         ;; don't activate when completing the regular Emacs way
         (not (get-buffer-window "*Completions*" 0))
         ;; don't activate during a company completion
         (not (bound-and-true-p company-candidates))
         ;; FIXME: temp workaround for starting commit
         ;; message in insertion mode
         (not (eq last-command 'magit-commit-create))
         (or (memq  major-mode '(messages-buffer-mode help-mode))
             (not (derived-mode-p 'comint-mode 'special-mode 'dired-mode)))))
      objed-initial-object 'symbol
      objed-auto-init-on-buffer-change nil
      objed-disabled-modes
      '(exwm-mode
        browse-kill-ring-mode
        completion-list-mode
        outline-mode
        special-mode)
      objed-mode-line-format
      '(:eval (propertize
               (format "%s(%s)"
                       (symbol-name objed--object)
                       (char-to-string (aref (symbol-name objed--obj-state) 0)))
               'face 'objed-mode-line))
      objed-cursor-color "#ff8c00"
      objed-use-hl nil
      objed--dispatch-alist nil
      objed--dispatch-key-alist nil)


(setcdr objed-map nil)
;; common emacs keys
(define-key objed-map (kbd "C-g") 'objed-quit)
(define-key objed-map (kbd "C-?") 'objed-show-top-level)
(define-key objed-map (kbd "C-o") 'objed-open-line)
(define-key objed-map (kbd "C-x C-x") 'objed-exchange-point-and-mark)
;; TODO: birdview mode/scroll mode
(define-key objed-map (kbd "C-h k") 'objed-describe-key)
(define-key objed-map (kbd "C-h n") 'which-key-show-next-page-cycle)
(define-key objed-map (kbd "C-h p") 'which-key-show-previous-page-cycle)
(define-key objed-map (kbd "C-M-w") 'objed-append-mode)
;; todo: restore object state, too?
(define-key objed-map (kbd "C-~") 'objed-undo-in-object)
;; general movement
(define-key objed-map (kbd "C-f") (objed--call-and-switch right-char char))
(define-key objed-map (kbd "C-b") (objed--call-and-switch left-char char))
(define-key objed-map (kbd "C-S-f") 'objed-move-char-forward)
(define-key objed-map (kbd "C-S-b") 'objed-move-char-backward)
(define-key objed-map (kbd "M-f") 'objed-forward-word)
(define-key objed-map (kbd "M-b") 'objed-backward-word)
(define-key objed-map (kbd "M-S-f") 'objed-move-word-forward)
(define-key objed-map (kbd "M-S-b") 'objed-move-word-backward)
(define-key objed-map (kbd "C-M-f") (objed--call-and-switch
                               objed--forward-sexp sexp))
(define-key objed-map (kbd "C-M-b") (objed--call-and-switch
                               objed--backward-sexp sexp))
(define-key objed-map (kbd "C-M-S-f") 'objed-move-object-forward)
(define-key objed-map (kbd "C-M-S-b") 'objed-move-object-backward)
(define-key objed-map (kbd "C-p") (objed--call-and-switch
                                   previous-line line
                                   nil
                                   (when (objed--point-in-periphery)
                                     (back-to-indentation))))
(define-key objed-map (kbd "C-n") (objed--call-and-switch
                                   next-line line
                                   nil
                                   (when (objed--point-in-periphery)
                                     (back-to-indentation))))
(define-key objed-map (kbd "C-S-n") 'objed-move-line-forward)
(define-key objed-map (kbd "C-S-p") 'objed-move-line-backward)
(define-key objed-map (kbd "M-+") 'objed-backward-until-context)
(define-key objed-map (kbd "M-ç") 'objed-forward-until-context)
(define-key objed-map (kbd "C-,") 'objed-previous) ;; objed-current-or-previous-context
(define-key objed-map (kbd "C-.") 'objed-next) ;; objed-current-or-next-context
(define-key objed-map (kbd "<C-home>") 'objed-top-object)
(define-key objed-map (kbd "<C-end>") 'objed-bottom-object)
;; block expansions
(define-key objed-map (kbd "<home>") 'objed-beg-of-block)
(define-key objed-map (kbd "<end>") 'objed-end-of-block)
(define-key objed-map (kbd "C-M-o") 'objed-expand-block)
;; context expansions
(define-key objed-map (kbd "C-S-o") 'objed-expand-context)
                                        ;(define-key objed-map (kbd "") 'objed-current-or-previous-context)
                                        ;(define-key objed-map (kbd "") 'objed-current-or-next-context)
(define-key objed-map (kbd "M-SPC") 'objed-toggle-state)
(define-key objed-map (kbd "M-j") 'objed-toggle-side)
;; marking/unmarking
(define-key objed-map (kbd "C-ç") 'objed-mark)
;; mark upwards
(define-key objed-map (kbd "C-+") 'objed-toggle-mark-backward)
;; (define-key objed-map "M" 'objed-unmark-all)
(define-key objed-map (kbd "C-=") 'objed-extend)
;; TODO: second + include more
(define-key objed-map (kbd "C-M-+") 'objed-include-backward)
(define-key objed-map (kbd "C-M-ç") 'objed-include-forward)
;; basic edit ops
(define-key objed-map (kbd "C-w") 'objed-kill)
(define-key objed-map (kbd "M-w") 'objed-copy)
(define-key objed-map (kbd "C-S-d") 'objed-delete)
(define-key objed-map (kbd "C-y") 'objed-yank)
(define-key objed-map (kbd "C-\\")
  ;; dont exit
  (objed-define-op nil objed-indent ignore))
(define-key objed-map (kbd "M-;")
  (objed-define-op nil objed-comment-or-uncomment-region))
(define-key objed-map (kbd "C-$")
  (objed-define-op nil flyspell-region))
;; quote op
(define-key objed-map (kbd "M-)") 'objed-raise)
(define-key objed-map (kbd "M-(")
  (objed-define-op nil objed-electric-pair))
;; (define-key objed-map "\""
;;   (objed-define-op nil objed-electric))
;; direct object switches
(define-key objed-map (kbd "C-:") 'objed-goto-next-identifier)
(define-key objed-map (kbd "C-;") 'objed-goto-prev-identifier)
                                        ;(define-key objed-map "_" 'objed-toggle-indentifier-place)
;; prefix keys
(define-key objed-map (kbd "M-s x") 'objed-op-map)
(define-key objed-map (kbd "M-s c") 'objed-object-map)
;; for custom user object and op commands
                                        ;(define-key objed-map (kbd "C-c o '") 'objed-user-map)
                                        ;(define-key objed-map (kbd "C-c o -") 'objed-other-user-map)
(define-key objed-map (kbd "M-g C-o") 'objed-occur)
;; special commands
(define-key objed-map (kbd "M-*") 'objed-mark-more)
(define-key objed-map (kbd "C-S-u") 'objed-last)
;; zap to object, jump to objects with avy
(define-key objed-map (kbd "M-g o") 'objed-ace)
(define-key objed-map (kbd "M-g M-o") 'objed-ace)
;; swiper like object search
;; TODO: start query replace in current object,
;; or for all
(define-key objed-map (kbd "C-%") 'objed-replace)
(define-key objed-map (kbd "M-:") 'objed-eval-expression)
(define-key objed-map (kbd "C-&")
  (objed-define-op nil objed-pipe-region))
(define-key objed-map (kbd "C-|")
  (objed-define-op nil objed-ipipe))
                                        ;(define-key objed-map "!" 'objed-execute)
(define-key objed-map (kbd "<C-M-return>")
  'objed-insert-new-object)
;; move windows
(define-key objed-map (kbd "<s-left>") 'objed-move-window-line-left)
(define-key objed-map (kbd "<s-right>") 'objed-move-window-line-right)
(define-key objed-map (kbd "<s-up>") 'objed-move-window-line-up)
(define-key objed-map (kbd "<s-down>") 'objed-move-window-line-down)
;; move text
(define-key objed-map (kbd "<C-left>") 'objed-indent-left)
(define-key objed-map (kbd "<C-right>") 'objed-indent-right)
(define-key objed-map (kbd "<M-right>") 'objed-indent-to-right-tab-stop)
(define-key objed-map (kbd "<M-left>") 'objed-indent-to-left-tab-stop)
(define-key objed-map (kbd "<C-M-left>") 'objed-forward-barf-sexp)
(define-key objed-map (kbd "<C-M-right>") 'objed-forward-slurp-sexp)
(define-key objed-map (kbd "<C-S-left>") 'objed-forward-barf-sexp)
(define-key objed-map (kbd "<C-S-right>") 'objed-forward-slurp-sexp)
(define-key objed-map (kbd " <S-left>") 'objed-move-object-backward)
(define-key objed-map (kbd " <S-right>") 'objed-move-object-forward)
;; for some objects up down is more intuitive
(define-key objed-map (kbd " <S-up>") 'objed-move-object-backward)
(define-key objed-map (kbd " <S-down>") 'objed-move-object-forward)






(define-key objed-mode-map (kbd "M-#") nil)
(define-key objed-mode-map (kbd "M-(") nil)
(define-key objed-mode-map (kbd "M-)") nil)
(define-key objed-mode-map (kbd "M-[") nil)
(define-key objed-mode-map (kbd "M-]") nil)
(define-key objed-mode-map (kbd "C-,") nil)
(define-key objed-mode-map (kbd "C-.") nil)
(define-key objed-mode-map (kbd "C-<") nil)
(define-key objed-mode-map (kbd "C->") nil)
(define-key objed-mode-map (kbd "C-c o c") 'objed-activate-object)
(define-key objed-mode-map (kbd "C-c o (") 'objed-until-beg-of-object-at-point)
(define-key objed-mode-map (kbd "C-c o )") 'objed-until-end-of-object-at-point)
(define-key objed-mode-map (kbd "C-c o [") 'objed-beg-of-object-at-point)
(define-key objed-mode-map (kbd "C-c o ]") 'objed-end-of-object-at-point)
(define-key objed-mode-map (kbd "C-;") 'objed-prev-identifier)
(define-key objed-mode-map (kbd "C-:") 'objed-next-identifier)


(push '(end-of-visual-line . line) objed-cmd-alist)
(push '(beginning-of-visual-line . line) objed-cmd-alist)

;; (with-eval-after-load 'which-key
;;   (which-key-add-key-based-replacements "=" "avy inside")
;;   (which-key-add-key-based-replacements "c" "choose type")
;;   (which-key-add-key-based-replacements "x" "additional op")
;;   (which-key-add-key-based-replacements "#" "avy other")
;;   (which-key-add-key-based-replacements "`" "forward boundary")
;;   (which-key-add-key-based-replacements "´" "backward boundary")
;;   (which-key-add-key-based-replacements "'" "user map")
;;   (which-key-add-key-based-replacements "-" "other user map"))

(defun objed--insert-keys-rebound-p ()
  "Return non-nil when any self insertion key is rebound."
  (cl-dolist (char (string-to-list "abcdefghijklmnopqrstuvwxyz"))
    (let ((binding (key-binding (vector char))))
      (when (not (and
                  (symbolp binding)
                  (string-match "insert" (symbol-name binding))))
        (cl-return binding)))))

(defun objed-focus-change (&optional _ign)
  (when objed--buffer
    (with-current-buffer objed--buffer
      (objed--reset))))

(defun objed-focus-change-add-hook ()
  (if (boundp 'after-focus-change-function)
      (add-function :before after-focus-change-function 'objed-focus-change)
    (add-hook 'focus-in-hook 'objed-focus-change)
    (add-hook 'focus-out-hook 'objed-focus-change)))
(add-hook 'objed-init-hook 'objed-focus-change-add-hook)

(defun objed-focus-change-remove-hook ()
  (if (boundp 'after-focus-change-function)
      (remove-function after-focus-change-function 'objed-focus-change)
    (remove-hook 'focus-in-hook 'objed-focus-change)
    (remove-hook 'focus-out-hook 'objed-focus-change)))
(add-hook 'objed-exit-hook 'objed-focus-change-remove-hook)

(advice-add 'objed-eval-expression :before 'objed-focus-change)

(defun objed-toggle-mode-activate ()
  (interactive)
  (if objed-mode
      (progn
        (objed-quit)
        (objed-mode -1)
        (message "objed-mode disabled"))
    (objed-mode 1)
    (objed-activate)
    (message "objed-mode enabled and activated")))

(global-set-key (kbd "M-SPC") 'objed-activate)
(global-set-key (kbd "M-s 7 o") 'objed-toggle-mode-activate)
(global-set-key (kbd "M-s c") 'objed-activate-object)
(objed-mode 1)
#+end_src

*** /company/ (when installed)

#+begin_src elisp
(when (load "company" t)
  ;; [ required
  ;; sudo apt-get install libclang-3.4-dev clang-3.4 clang-format-3.4 clang-modernize-3.4 clang
  ;; ]
  ;;(add-to-list 'load-path "~/.emacs.d/elpa/company-0.8.12")
  ;;(add-to-list 'load-path "~/.emacs.d/elpa/elpa/company-c-headers-20150801.901")
  (if (null (require 'company-template nil 'noerror))
      (message-color #("ERROR missing package `company-template'"
                       0 5 (face error)))
    (define-key company-template-nav-map [(shift tab)]
      (lookup-key company-template-nav-map [tab]))
    (define-key company-template-nav-map (kbd "<backtab>")
      (lookup-key company-template-nav-map (kbd "TAB")))
    (define-key company-template-nav-map [tab] nil)
    (define-key company-template-nav-map (kbd "TAB") nil))
  ;; [
  ;;(require 'company-capf)
  ;; ]
  ;;(require 'company-c-headers)
  ;;(require 'company-yasnippet)

  (defface mode-line-company-mode
    '((t :foreground "slate blue" :weight bold))
    "Project name" :group 'mode-line)
  (setcar (cdr (assq 'company-mode minor-mode-alist))
          (propertize "C" 'face 'mode-line-company-mode))
  (add-hook 'after-init-hook 'global-company-mode)

  ;; Colors
  (face-spec-set 'company-preview '((t (:foreground "darkgray" :underline t))))
  (face-spec-set 'company-preview-common '((t (:inherit company-preview))))
  (face-spec-set 'company-tooltip '((t (:background "lightgray" :foreground "black"))))
  (face-spec-set 'company-tooltip-selection '((t (:background "steelblue" :foreground "white"))))
  (face-spec-set 'company-tooltip-common '((((type x)) (:inherit company-tooltip :weight bold))
                                           (t (:inherit company-tooltip))))
  (face-spec-set 'company-tooltip-common-selection
                 '((((type x)) (:inherit company-tooltip-selection :weight bold))
                   (t (:inherit company-tooltip-selection))))


  ;; [ disable slow 'company-semantic'. comment with ede-project
  ;;(delete 'company-semantic company-backends)
  ;; ]
  (setq company-tooltip-minimum-width 20
        company-tooltip-minimum 2
        company-selection-wrap-around t
        company-minimum-prefix-length 1
        company-idle-delay 0.2
        company-tooltip-idle-delay 0.2)

  (defun toggle-company-semantic ()
    "Toggle semantic backend."
    (interactive)
    (if (memq 'company-semantic company-backends)
        (progn
          (delete 'company-semantic company-backends)
          (message "`company-semantic' removed from company backends"))
      (push 'company-semantic company-backends)
      (message "`company-semantic' added to company backends")))

  ;; company-c-headers
  ;; (add-to-list 'company-backends 'company-c-headers)
  ;; company c++ system headers
  ;; (with-eval-after-load 'cc-mode
  ;;   (require 'semantic/bovine/gcc)
  ;;   (let ((dirs (semantic-gcc-get-include-paths "c++")))
  ;;     (dolist (dir dirs)
  ;;       (add-to-list 'company-c-headers-path-system (concat dir "/"))))
  ;;   (delete-dups company-c-headers-path-system))
  ;; company c++ user headers
  ;; (with-eval-after-load 'c-c++-config
  ;;   (dolist (path c-c++-include-paths)
  ;;     (add-to-list 'company-c-headers-path-user path)))
  ;; hs-minor-mode for folding source code
  ;;(add-hook 'c-mode-common-hook 'hs-minor-mode)

  ;; Available C style:
  ;; “gnu”: The default style for GNU projects
  ;; “k&r”: What Kernighan and Ritchie, the authors of C used in their book
  ;; “bsd”: What BSD developers use, aka “Allman style” after Eric Allman.
  ;; “whitesmith”: Popularized by the examples that came with Whitesmiths C, an early commercial C compiler.
  ;; “stroustrup”: What Stroustrup, the author of C++ used in his book
  ;; “ellemtel”: Popular C++ coding standards as defined by “Programming in C++, Rules and Recommendations,” Erik Nyquist and Mats Henricson, Ellemtel
  ;; “linux”: What the Linux developers use for kernel development
  ;; “python”: What Python developers use for extension modules
  ;; “java”: The default style for java-mode (see below)
  ;; “user”: When you want to define your own style
  ;; (setq
  ;;  c-default-style "linux" ;; set style to "linux"
  ;;  )

  (with-eval-after-load 'company-dabbrev
    (setq company-dabbrev-downcase nil))

;;;;;;;;;;;;;;
;; Posframe ;;
;;;;;;;;;;;;;;
  (when (and (display-graphic-p) (load "company-posframe" t))
    (setq company-posframe-lighter "")
    (add-hook 'company-mode-hook #'company-posframe-mode))

;;;;;;;;;;;;
;; Auxtex ;;
;;;;;;;;;;;;
  (with-eval-after-load 'auctex
    (require 'company-auctex)
    (company-auctex-init))

;;;;;;;;;;
;; Keys ;;
;;;;;;;;;;
  ;; (define-key c-mode-map  [(tab)] 'company-complete)
  ;; (define-key c++-mode-map  [(tab)] 'company-complete)
  (define-key company-active-map [return] nil)
  (define-key company-active-map (kbd "RET") nil)
  (define-key company-active-map [tab] #'company-complete-selection)
  (define-key company-active-map (kbd "TAB") #'company-complete-selection)
  (define-key company-active-map (kbd "<backtab>") #'company-complete-common-or-cycle)
  (define-key company-active-map [?\C-o] #'company-other-backend)
  (define-key company-active-map [?\C-t] #'company-begin-backend)
  ;;(define-key company-mode-map [(control tab)] 'company-complete)
  ;; `company-complete` conflicts with `company-template-forward-field` with TAB #515

  (global-set-key (kbd "M-s 7 ,") 'toggle-company-semantic)
  (global-set-key (kbd "C-c y") #'company-yasnippet)
  (global-set-key (kbd "C-c c c") #'company-complete)
  (global-set-key (kbd "C-c c b") #'company-begin-backend))
#+end_src

*** /ace-window/

*after (require 'mode-line-config)*

#+begin_src elisp
(require 'ace-window)
(set-face-attribute 'aw-mode-line-face nil
                    :weight 'bold
                    :foreground "mint cream")
(if exwm-p
    (set-face-attribute 'aw-leading-char-face nil
                        :weight 'bold
                        :foreground "green yellow"
                        ;; integers sometimes hide char
                        :height 3.0
                        :underline nil
                        :overline nil
                        :box nil
                        :inherit 'unspecified)
 (set-face-attribute 'aw-leading-char-face nil
                     :weight 'ultra-bold
                     :foreground "white"
                     :background "black"
                     :height 'unspecified
                     :underline nil
                     :overline nil
                     :box nil
                     :inherit 'unspecified))

(defun aw-move-deleting-window (window)
  "Real move the current buffer to WINDOW.
Switch the current window to the previous buffer."
  (let ((buffer (current-buffer)))
    (delete-window (selected-window))
    (aw-switch-to-window window)
    (switch-to-buffer buffer)))

(defun aw-easyfocus ()
  (interactive)
  (make-process :name "easyfocus" :command '("easyfocus"))
  (selected-window))

(push " *which-key*" aw-ignored-buffers)
(setq minor-mode-alist
      (assq-delete-all 'ace-window-mode minor-mode-alist)
      aw-scope 'visible
      aw-dispatch-alist
      '((?R aw-refresh "Refresh mode-line")
        (?X aw-delete-window "Delete Window")
        (?S aw-swap-window "Swap Windows")
        (?D aw-move-deleting-window "Move Deleting Window")
        (?M aw-move-window "Move Window")
        (?C aw-copy-window "Copy Window")
        (?J aw-switch-buffer-in-window "Select Buffer")
        (?N aw-flip-window "Flip Window")
        (?U aw-switch-buffer-other-window "Switch Buffer Other Window")
        (?E aw-execute-command-other-window "Execute Command Other Window")
        (?F aw-split-window-fair "Split Fair Window")
        (?V aw-split-window-vert "Split Vert Window")
        (?B aw-split-window-horz "Split Horz Window")
        (?O delete-other-windows "Delete Other Windows")
        (?T aw-transpose-frame "Transpose Frame")
        ;; ?i ?r ?t are used by hyperbole.el
        (?? aw-show-dispatch-help)
        (?\M-o aw-easyfocus))
      aw-keys
      (let ((keys
             '(?a ?b ?c ?d ?e ?f ?g ?h ;; ?i
                  ?j ?k ?l ?m ?n ?o ?p ?q ;; ?r
                  ?s ;; ?t
                  ?u ?v ?w ?x ?y ?z)))
        (dolist (dispatch aw-dispatch-alist)
          (setq keys (delete (car dispatch) keys)))
        keys)
      aw-dispatch-always t
      aw-minibuffer-flag nil
      aw-background t)

(defun aw-refresh ()
  (interactive)
  (aw-update)
  (force-mode-line-update t))

;; (ace-window-display-mode)

(global-set-key (kbd "M-o") 'ace-window)
;; (global-set-key (kbd "M-O") 'aw-refresh)
#+end_src

*** /hydra/

#+begin_src elisp
(require 'hydra)
(setq hydra-head-format "%s ")
#+end_src

*** /operate-on-number/

#+begin_src elisp
(require 'operate-on-number-autoloads)

(defhydra hydra-operate (:foreign-keys nil)
  "OPERATE"
  ("+"  apply-operation-to-number-at-point)
  ("-"  apply-operation-to-number-at-point)
  ("*"  apply-operation-to-number-at-point)
  ("/"  apply-operation-to-number-at-point)
  ("\\" apply-operation-to-number-at-point)
  ("^"  apply-operation-to-number-at-point)
  ("<"  apply-operation-to-number-at-point)
  (">"  apply-operation-to-number-at-point)
  ("#"  apply-operation-to-number-at-point)
  ("%"  apply-operation-to-number-at-point)
  ("'"  operate-on-number-at-point))

(global-set-key (kbd "C-c o m") #'hydra-operate/body)
(global-set-key (kbd "C-c o o") #'operate-on-number-at-point-or-region)
#+end_src

*** /avy/

#+begin_src elisp
(require 'avy)
(require 'link-hint)

(set-face-attribute 'avy-lead-face nil
                    :bold nil
                    :background "#b4002e")
(set-face-attribute 'avy-lead-face-0 nil
                    :bold nil
                    :background "#2642df")

(setq avy-dispatch-alist
      '((?M . avy-action-kill-move)
        (?K . avy-action-kill-stay)
        (?T . avy-action-teleport)
        (?  . avy-action-mark)
        (?C . avy-action-copy)
        (?Y . avy-action-yank)
        (?L . avy-action-yank-line)
        (?I . avy-action-ispell)
        (?Z . avy-action-zap-to-char))
      avy-keys
      (let ((keys
             '(?q ?w ?e ?r ?t ?y ?u ?i ?o ?p
                  ?a ?s ?d ?f ?g ?h ?j ?k ?l
                  ?z ?x ?c ?v ?b ?n ?m)))
        (dolist (dispatch avy-dispatch-alist)
          (setq keys (delete (car dispatch) keys)))
        keys)
      avy-single-candidate-jump t)

(defmacro avy-prefix-all-windows (avy-fun)
  `(defun ,(intern (concat (symbol-name avy-fun)
                           "-prefix-all-windows"))
       (arg)
     (interactive "p")
     (let ((current-prefix-arg nil)
           (avy-all-windows (cl-case arg
                              (1 nil)
                              ((2 4) t)
                              ((3 5 16) 'all-frames)
                              (otherwise avy-all-windows))))
       (call-interactively (quote ,avy-fun)))))

(defun avy-completions-word-or-subword-1 ()
  (interactive)
  (switch-to-completions)
  (let (avy-all-windows)
    (call-interactively 'avy-goto-word-or-subword-1)))

(defun avy-completions-word-1 ()
  (interactive)
  (switch-to-completions)
  (let (avy-all-windows)
    (call-interactively 'avy-goto-word-1)))

(defun avy-completions-word-0 ()
  (interactive)
  (switch-to-completions)
  (let (avy-all-windows)
    (call-interactively 'avy-goto-word-0)))

(defun avy-completions-line ()
  (interactive)
  (switch-to-completions)
  (let (avy-all-windows)
    (call-interactively 'avy-goto-line)))

(defun avy-completions-timer ()
  (interactive)
  (switch-to-completions)
  (let (avy-all-windows)
    (call-interactively 'avy-goto-char-timer)))

(defun avy-completions-candidate ()
  (interactive)
  (switch-to-completions)
  (let (avy-all-windows)
    (when (avy-with avy-goto-char
            (avy-jump "[\t\n]\\(?1:[^\t\n]+\\)"
                      :group 1))
      (choose-completion))))

;;;;;;;;;;
;; Keys ;;
;;;;;;;;;;
(define-key completion-in-region-mode-map (kbd "M-z")
  'avy-completions-candidate)
(define-key minibuffer-local-completion-map (kbd "M-z")
  'avy-completions-candidate)
(define-key completion-list-mode-map (kbd "M-z")
  'avy-completions-candidate)

(define-key completion-in-region-mode-map (kbd "M-Z")
  'avy-completions-word-or-subword-1)
(define-key minibuffer-local-completion-map (kbd "M-Z")
  'avy-completions-word-or-subword-1)

(define-key completion-in-region-mode-map (kbd "C-M-z")
  'avy-completions-timer)
(define-key minibuffer-local-completion-map (kbd "C-M-z")
  'avy-completions-timer)

(define-key completion-in-region-mode-map (kbd "M-g w")
  'avy-completions-word-1)
(define-key minibuffer-local-completion-map (kbd "M-g w")
  'avy-completions-word-1)

(define-key completion-in-region-mode-map (kbd "M-g W")
  'avy-completions-word-0)
(define-key minibuffer-local-completion-map (kbd "M-g W")
  'avy-completions-word-0)

(define-key completion-in-region-mode-map (kbd "M-g l")
  'avy-completions-line)
(define-key minibuffer-local-completion-map (kbd "M-g l")
  'avy-completions-line)

(global-set-key (kbd "M-g c") (avy-prefix-all-windows
                               avy-goto-char))
(global-set-key (kbd "M-g C") (avy-prefix-all-windows
                               avy-goto-char-2))
(global-set-key (kbd "C-M-z") (avy-prefix-all-windows
                               avy-goto-char-timer))
(global-set-key (kbd "M-g s") (avy-prefix-all-windows
                               avy-goto-symbol-1))
(global-set-key (kbd "M-g l") (avy-prefix-all-windows
                               avy-goto-line))
(global-set-key (kbd "M-g w") (avy-prefix-all-windows
                               avy-goto-word-1))
(global-set-key (kbd "M-g W") (avy-prefix-all-windows
                               avy-goto-word-0))
(global-set-key (kbd "M-Z")   (avy-prefix-all-windows
                               avy-goto-char-in-line))
(global-set-key (kbd "M-z")   (avy-prefix-all-windows
                               avy-goto-word-or-subword-1))
(global-set-key (kbd "M-g L")   (avy-prefix-all-windows
                                 avy-resume))
(global-set-key (kbd "M-g k") (avy-prefix-all-windows
                               link-hint-open-link))
(global-set-key (kbd "M-g K") (avy-prefix-all-windows
                               link-hint-copy-link))
(global-set-key (kbd "M-g SPC") 'avy-pop-mark)
#+end_src

*** CANC /vimish-fold/
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
(require 'vimish-fold)
(set-face-attribute 'vimish-fold-overlay nil
                    :foreground 'unspecified
                    :background "#0f0f0f"
                    :underline t
                    :inherit 'unspecified)
;; (face-spec-set 'vimish-fold-overlay '((t (:background "#0f0f0f" :underline t))))

(defvar fold-threshold 1)

(defmacro deffold (func-name params
                             interactive
                             let*-list
                             start-cond
                             &optional while-cond
                             exclude-start include-end)
  (or while-cond (setq while-cond start-cond))
  (let* ((timesp (memq 'times params))
         (vimish-or-goback
          `(condition-case nil
               (save-excursion
                 (vimish-fold beg end))
             (error (goto-char beg)
                    (if (/= 0 (forward-line))
                        (cl-return-from ,func-name)))))
         (vimish-beg-end
          `(let ((end ,(if include-end '(progn (forward-line)
                                               (1- (point)))
                         '(1- (point)))))
             ,(if (memq 'threshold params)
                  `(if (< threshold (count-lines beg end))
                       ,vimish-or-goback)
                vimish-or-goback)))
         (looking-at-end
          `((while ,while-cond
              (when (/= 0 (forward-line))
                ,vimish-beg-end
                (cl-return-from ,func-name)))
            ,vimish-beg-end)))
    `(defun ,func-name ,params
       ,interactive
       (let* ,let*-list
         (save-excursion
           ,(if timesp
                '(if (< times 0)
                     (goto-char (point-min))
                   (beginning-of-line))
              '(goto-char (point-min)))
           (cl-block ,func-name
             ;; Iterations
             (while ,(if timesp
                         '(/= -1 (cl-decf times))
                       't)
               ;; Looking at begin
               (while (not ,start-cond)
                 (if (/= 0 (forward-line))
                     (cl-return-from ,func-name)))
               ,@(if exclude-start
                     `((if (/= 0 (forward-line))
                           (cl-return-from ,func-name))
                       (let ((beg (point)))
                         ;; Looking at end
                         ,@looking-at-end))
                   `((let ((beg (point)))
                       (if (/= 0 (forward-line))
                           (cl-return-from ,func-name))
                       ;; Looking at end
                       ,@looking-at-end))))))))))

(deffold fold-indent (level threshold)
  (interactive (list (read-number "Level: " 1)
                     (read-number "Threshold: " fold-threshold)))
  ((indentation (* level tab-width)))
  (and (= indentation (current-indentation))
       (not (looking-at-p "[[:space:]]*$")))
  (or (<= indentation (current-indentation))
      (looking-at-p "[[:space:]]*$")
      (char-equal ?\\ (char-before (1- (point))))))

(deffold fold-regexp (regexp times threshold)
  (interactive (list (read-regexp "Regexp: ")
                     (read-number "Times: " -1)
                     (read-number "Threshold: " fold-threshold)))
  nil
  (looking-at-p regexp))

(deffold fold-precomp (&optional threshold)
  (interactive "p")
  ((threshold (or threshold 1)))
  (cond
   ((derived-mode-p 'c-mode 'c++-mode)
    (looking-at-p "[[:space:]]*#"))
   ((derived-mode-p 'python-mode 'elpy-mode)
    (looking-at-p "[[:space:]]*\\(from\\|import\\)")))
  (or (looking-at-p "[[:space:]]*$")
      (let ((char (char-before (1- (point)))))
        (and char (char-equal ?\\ char)))
      (cond
       ((derived-mode-p 'c-mode 'c++-mode)
        (looking-at-p "[[:space:]]*#"))
       ((derived-mode-p 'python-mode 'elpy-mode)
        (looking-at-p "[[:space:]]*\\(from\\|import\\)")))))

(deffold fold-comment (&optional threshold)
  (interactive "p")
  ((threshold (or threshold 1)))
  (cond
   ((derived-mode-p 'lisp-interaction-mode 'emacs-lisp)
    (looking-at-p "[[:space:]]*;"))
   ((derived-mode-p 'c-mode 'c++-mode)
    (looking-at-p "[[:space:]]*/[/*]"))
   ((derived-mode-p 'python-mode 'elpy-mode)
    (looking-at-p "[[:space:]]*#")))
  (or (objed--bounds-of-comment-at-point)
      (cond
       ((derived-mode-p 'lisp-interaction-mode 'emacs-lisp)
        (looking-at-p "[[:space:]]*;"))
       ((derived-mode-p 'c-mode 'c++-mode)
        (looking-at-p "[[:space:]]*/[/*]"))
       ((derived-mode-p 'python-mode 'elpy-mode)
        (looking-at-p "[[:space:]]*#")))))

;; [ cc
(deffold fold-cc-class (times threshold)
  (interactive (list (read-number "Times: " -1)
                     (read-number "Threshold: " fold-threshold)))
  (pos-bracket)
  (if (looking-at "[[:space:]]*class [\0-\377[:nonascii:]]*?{")
      (setq pos-bracket (1- (match-end 0))))
  (and (goto-char pos-bracket)
       (forward-sexp)
       nil)
  t t)

(deffold fold-cc-comment (times threshold)
  (interactive (list (read-number "Times: " -1)
                     (read-number "Threshold: " fold-threshold)))
  (while-function)
  (or (if (looking-at-p "[[:space:]]*/\\*")
          (setq while-function (lambda () (not (if (looking-at-p ".*?\\*/")
                                                 (forward-line 1))))))
      (if (looking-at-p "[[:space:]]*//")
          (setq while-function (lambda () (looking-at-p "[[:space:]]*//")))))
  (funcall while-function))
;; ]

;; [ Scripting
(deffold fold-script-comment (times threshold)
  (interactive (list (read-number "Times: " -1)
                     (read-number "Threshold: " fold-threshold)))
  nil
  (looking-at-p "[[:space:]]*#")
  (looking-at-p "[[:space:]]*\\($\\|#\\)"))
;; ]

;; [ Python
(deffold fold-python-class (times threshold)
  (interactive (list (read-number "Times: " -1)
                     (read-number "Threshold: " fold-threshold)))
  (indentation)
  (and (looking-at-p "[[:space:]]*class ")
       (setq indentation (current-indentation)))
  (or (looking-at-p "[[:space:]]*$")
      (char-equal ?\\ (char-before (1- (point))))
      (< indentation (current-indentation)))
  t)

(deffold fold-python-class-header (times threshold)
  (interactive (list (read-number "Times: " -1)
                     (read-number "Threshold: " fold-threshold)))
  (indentation)
  (and (looking-at-p "[[:space:]]*class ")
       (setq indentation (current-indentation)))
  (or (looking-at-p "[[:space:]]*$")
      (char-equal ?\\ (char-before (1- (point))))
      (and (< indentation (current-indentation))
           (not (looking-at-p "[[:space:]]*\\(@\\|\\(async +\\)?def \\)"))))
  t)

(deffold fold-python-function (times threshold)
  (interactive (list (read-number "Times: " -1)
                     (read-number "Threshold: " fold-threshold)))
  (indentation)
  (and (looking-at-p "[[:space:]]*\\(async +\\)?def ")
       (setq indentation (current-indentation)))
  (or (looking-at-p "[[:space:]]*$")
      (char-equal ?\\ (char-before (1- (point))))
      (if (looking-at "[[:space:]]*\"\"\"[\0-\377[:nonascii:]]*?\"\"\"")
          (goto-char (match-end 0)))
      (if (looking-at "[[:space:]]*'''[\0-\377[:nonascii:]]*?'''")
          (goto-char (match-end 0)))
      (< indentation (current-indentation)))
  t)

(deffold fold-python-import (times threshold)
  (interactive (list (read-number "Times: " -1)
                     (read-number "Threshold: " fold-threshold)))
  (indentation)
  (and (looking-at-p "[[:space:]]*\\(import \\|from \\)")
       (setq indentation (current-indentation)))
  (or (looking-at-p "[[:space:]]*\\($\\|import \\|from \\|except \\|finally:\\)")
      (char-equal ?\\ (char-before (1- (point))))
      (if (looking-at "[[:space:]]*\\(try:[[:space:]]*\\|#[^\n]*\\)\n\\([[:space:]]*\\(#[^\n]*\\)?\n\\)*[[:space:]]*\\(import \\|from \\)")
          (goto-char (match-end 0)))
      (< indentation (current-indentation))))

(deffold fold-python-docstring (times threshold)
  (interactive (list (read-number "Times: " -1)
                     (read-number "Threshold: " fold-threshold)))
  (docstring-delimiter)
  (or (if (looking-at-p "[[:space:]]*'''")
          (setq docstring-delimiter "[^\n]*'''"))
      (if (looking-at-p "[[:space:]]*\"\"\"")
          (setq docstring-delimiter "[^\n]*\"\"\"")))
  (not (looking-at-p docstring-delimiter))
  nil t)

(deffold fold-python-pytest (times threshold)
  (interactive (list (read-number "Times: " -1)
                     (read-number "Threshold: " fold-threshold)))
  nil
  (looking-at-p "\\(-\\{10,\\}\\|_\\{10,\\}\\) [_A-Z][_a-zA-Z0-9\\., ]* \\(-\\{10,\\}\\|_\\{10,\\}\\)")
  (not
   (looking-at-p
    "\\(=\\{10,\\}\\|-\\{10,\\}\\|_\\{10,\\}\\) [_A-Z0-9][_a-zA-Z0-9\\., ]* \\(=\\{10,\\}\\|-\\{10,\\}\\|_\\{10,\\}\\)"))
  t)
;; ]

;; [ php
(deffold fold-php-class-header (times threshold)
  (interactive (list (read-number "Times: " -1)
                     (read-number "Threshold: " fold-threshold)))
  (pos-bracket)
  (if (looking-at "[[:space:]]*class [\0-\377[:nonascii:]]*?{")
      (setq pos-bracket (save-excursion
                          (goto-char (1- (match-end 0)))
                          (forward-sexp)
                          (point))))
  (or (looking-at-p "[[:space:]]*$")
      (char-equal ?\\ (char-before (1- (point))))
      (and (>= pos-bracket (point))
           (not (if (looking-at-p "[[:space:]]*\\(public +\\|protected +\\|private +\\)?\\(static +\\)?function [\0-\377[:nonascii:]]*?{")
                    (forward-line -1)))))
  t t)

(deffold fold-php-function (times threshold)
  (interactive (list (read-number "Times: " -1)
                     (read-number "Threshold: " fold-threshold)))
  (pos-bracket)
  (if (looking-at "[[:space:]]*\\(public +\\|protected +\\|private +\\)?\\(static +\\)?function [\0-\377[:nonascii:]]*?{")
      (setq pos-bracket (1- (match-end 0))))
  (and (goto-char pos-bracket)
       (forward-sexp)
       nil)
  t t)

(defun fold-php-comment (times threshold)
  (interactive (list (read-number "Times: " -1)
                     (read-number "Threshold: " fold-threshold)))
  (fold-cc-comment times threshold)
  (fold-script-comment times threshold))
;; ]

(defun fold-derived-mode (arg blocks)
  (interactive (list current-prefix-arg
                     (completing-read-multiple
                      "Blocks: "
                      '("class" "defun" "require"
                        "comment" "docstring" "header")
                      nil t)))
  (cond
   ;; list parameter `arg'?
   ((pcase arg
      ('(4) ;; C-u prefix
       (vimish-fold-delete-all)
       t)))
   ;; zero `arg'?
   ((and (numberp arg)
         (= arg 0))
    (call-interactively 'fold-indent))
   ((derived-mode-p 'python-mode 'elpy-mode)
    (or arg (setq arg -1))
    (dolist (b blocks)
      (pcase b
        ("class"
         (fold-python-class arg fold-threshold))
        ("defun"
         (fold-python-function arg fold-threshold))
        ("require"
         (fold-python-import arg fold-threshold))
        ("comment"
         (fold-script-comment arg fold-threshold))
        ("docstring"
         (fold-python-docstring arg fold-threshold))
        ("header"
         (fold-python-class-header arg fold-threshold))
        (_ (message "Case: `%s' not implemented" b)))))
   ((derived-mode-p 'php-mode)
    (or arg (setq arg -1))
    (dolist (b blocks)
      (pcase b
        ("class"
         (fold-cc-class arg fold-threshold))
        ("defun"
         (fold-php-function arg fold-threshold))
        ("comment"
         (fold-php-comment arg fold-threshold))
        ("header"
         (fold-php-class-header arg fold-threshold))
        (_ (message "Case: `%s' not implemented" b)))))
   ;; last case, a lot of progmodes derive from c-mode
   ((derived-mode-p 'c-mode 'c++-mode)
    (fold-indent (or arg -1) fold-threshold)
    (fold-precomp)
    (fold-comment))))

(defun fold-dwim (&optional arg)
  (interactive "P")
  (cond
   ;; exists region?
   (mark-active
    (call-interactively #'vimish-fold))
   ;; exists vimish overlay at point?
   ((cl-block nested-dolist
      (dolist (overlay (overlays-at (point)))
        (when (vimish-fold--vimish-overlay-p overlay)
          (cl-return-from nested-dolist t)))
      nil)
    (if arg
        (vimish-fold-delete)
      (vimish-fold-toggle)))
   ;; exists function or class definition at point?
   ((condition-case nil
        (save-excursion
          (let ((pos (point)))
            (end-of-line)
            (let* ((beg (progn (beginning-of-defun) (point)))
                   (end (progn (end-of-defun) (1- (point)))))
              (if (and (<= beg pos)
                       (< pos end)
                       (goto-char beg)
                       (or (looking-at-p "[[:space:]]*class ")
                           (bounds-of-thing-at-point 'defun))
                       (= 0 (forward-line))
                       (setq beg (point))
                       (< beg end))
                  (if arg
                      (vimish-fold-delete)
                    (vimish-fold beg end))))))
      (error (vimish-fold-next-fold)
             (vimish-fold-toggle)
             t)))
   ;; exists vimish overlays in buffer?
   ((cl-block nested-dolist
      (dolist (overlay (overlays-in (point-min) (point-max)))
        (when (vimish-fold--vimish-overlay-p overlay)
          (cl-return-from nested-dolist t)))
      nil)
    (if arg
        (vimish-fold-delete-all)
      (if (cl-every (lambda (overlay)
                      (eq (overlay-get overlay 'type) 'vimish-fold--folded))
                    (vimish-fold--folds-in (point-min) (point-max)))
          (vimish-fold-unfold-all)
        (vimish-fold-refold-all))))
   ;; else
   (t
    (setq prefix-arg arg)
    (call-interactively 'fold-derived-mode))))

(vimish-fold-global-mode 1)

(defun hs-or-vimish-toggle (&optional e)
  (interactive)
  (if (and hs-minor-mode
           (not (cl-block nested-dolist
                  (dolist (overlay (overlays-at (point)))
                    (when (vimish-fold--vimish-overlay-p overlay)
                      (cl-return-from nested-dolist t)))
                  nil)))
      (hs-toggle-hiding e)
    (vimish-fold-toggle)))

;;;;;;;;;;
;; Keys ;;
;;;;;;;;;;
(define-key vimish-fold-folded-keymap "n" #'vimish-fold-next-fold)
(define-key vimish-fold-folded-keymap "p" #'vimish-fold-previous-fold)
(define-key vimish-fold-folded-keymap "+" #'vimish-fold-unfold)
(define-key vimish-fold-folded-keymap "*" #'vimish-fold-unfold-all)
(define-key vimish-fold-folded-keymap "d" #'vimish-fold-delete)
(define-key vimish-fold-folded-keymap "D" #'vimish-fold-delete-all)

(global-set-key (kbd "C-c @ M-g") #'vimish-fold-avy)
(global-set-key (kbd "C-c @ +") #'vimish-fold-unfold)
(global-set-key (kbd "C-c @ *") #'vimish-fold-unfold-all)
(global-set-key (kbd "C-c @ -") #'vimish-fold-refold)
(global-set-key (kbd "C-c @ _") #'vimish-fold-refold-all)
(global-set-key (kbd "C-c @ .") #'vimish-fold-toggle)
(global-set-key (kbd "C-c @ :") #'vimish-fold-toggle-all)
(global-set-key (kbd "C-c @ d") #'vimish-fold-delete)
(global-set-key (kbd "C-c @ D") #'vimish-fold-delete-all)
(global-set-key (kbd "C-c @ f") #'vimish-fold)
(global-set-key (kbd "C-c @ p") #'vimish-fold-previous-fold)
(global-set-key (kbd "C-c @ n") #'vimish-fold-next-fold)
(global-set-key (kbd "C-c @ w") 'fold-dwim)
(global-set-key (kbd "<C-tab>") 'hs-or-vimish-toggle)
#+end_src

*** CANC /bookmark+/
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
(require 'bookmark+)

(setq bmkp-auto-light-when-jump 'all-in-buffer
      bmkp-auto-light-when-set 'all-in-buffer
      bmkp-last-as-first-bookmark-file nil
      ;;bmkp-light-style-autonamed 'lfringe
      ;;bmkp-light-style-non-autonamed 'lfringe
      bmkp-bmenu-commands-file (expand-file-name
                                "cache/bmk-bmenu-commands.el"
                                user-emacs-directory)
      bmkp-bmenu-state-file (expand-file-name
                             "cache/bmk-bmenu-state.el"
                             user-emacs-directory))

(set-face-background 'bmkp-light-non-autonamed "DarkSlateGray")
(set-face-background 'bmkp-light-autonamed "DimGray")
#+end_src

*** /which-key/

#+begin_src elisp
(require 'which-key)

(setq which-key-lighter ""
      ;; Allow C-h to trigger which-key before it is done automatically
      which-key-show-early-on-C-h t
      ;; Set the time delay (in seconds) for the which-key popup to appear.
      which-key-idle-delay 1.0

      ;; Set the maximum length (in characters) for key descriptions (commands or
      ;; prefixes). Descriptions that are longer are truncated and have ".." added.
      which-key-max-description-length 30

      ;; Use additonal padding between columns of keys. This variable specifies the
      ;; number of spaces to add to the left of each column.
      which-key-add-column-padding 0

      ;; Set the separator used between keys and descriptions. Change this setting to
      ;; an ASCII character if your font does not show the default arrow. The second
      ;; setting here allows for extra padding for Unicode characters. which-key uses
      ;; characters as a means of width measurement, so wide Unicode characters can
      ;; throw off the calculation.
      which-key-separator " → "
      which-key-unicode-correction 3

      ;; Set the prefix string that will be inserted in front of prefix commands
      ;; (i.e., commands that represent a sub-map).
      which-key-prefix-prefix "+"

      ;; Set to t to show the count of keys shown vs. total keys in the mode line.
      which-key-show-remaining-keys nil
      ;; which-key-special-keys nil
      ;; Location
      which-key-popup-type 'side-window
      which-key-side-window-location '(right bottom)
      which-key-show-prefix 'top)

(if (display-graphic-p)
    (progn
      (push '(("ESC" . nil) . ("⎋" . nil)) which-key-replacement-alist)
      (push '(("TAB" . nil) . ("↹" . nil)) which-key-replacement-alist)
      (push '(("RET" . nil) . ("↵" . nil)) which-key-replacement-alist)
      (push '(("DEL" . nil) . ("⇤" . nil)) which-key-replacement-alist)
      (push '(("SPC" . nil) . ("␣" . nil)) which-key-replacement-alist)
      (setq which-key-special-keys '("⎋" "↹" "↵" "⇤" "␣"))
      (set-face-attribute 'which-key-special-key-face nil
                      :bold t
                      :inverse-video 'unspecified
                      :inherit 'unspecified
                      :foreground "#78e56d")
      (when (require 'which-key-posframe nil t)
        (setq which-key-posframe-poshandler 'posframe-poshandler-frame-center)
        (which-key-posframe-mode)))
  ;; Set the special keys. These are automatically truncated to one character and
  ;; have which-key-special-key-face applied. Disabled by default. An example
  ;; setting is
  (setq which-key-special-keys '("SPC" "TAB" "RET" "ESC" "DEL"))
  (set-face-attribute 'which-key-special-key-face nil
                      :foreground "#78e56d"))

(global-set-key (kbd "C-h C-h") 'which-key-show-top-level)
(which-key-mode)
#+end_src

*** /expand-region/

#+begin_src elisp
(require 'expand-region)

(setq expand-region-autocopy-register "º"
      expand-region-smart-cursor t
      expand-region-subword-enabled t)

(global-subword-mode)

(global-set-key (kbd "M-s r") #'er/expand-region)
(global-set-key (kbd "M-s s") #'er/mark-symbol)
(global-set-key (kbd "M-s d") #'mark-defun)
(global-set-key (kbd "M-s S") #'swap-regions)
#+end_src

*** /xterm-color/

#+begin_src elisp
(setq xterm-color-preserve-properties t)
(require 'xterm-color)

(if (daemonp)
    (setenv "EDITOR" "emacsclient -c -n")
  (setenv "EDITOR" "emacs"))
;; (setenv "PAGER" "cat")
#+end_src

*** /rebox2/

#+begin_src elisp
(require 'rebox2)

(rebox-register-template 227 728
                         '("//,----------"
                           "//| box123456"
                           "//`----------"))

(setq rebox-style-loop '(41 27 23 21 11))

;;;;;;;;;
;; C++ ;;
;;;;;;;;;
(rebox-register-template 247 748
                         '("// ---------"
                           "// box123456"
                           "// ---------"))

(defun my-c++-setup ()
  "Override comment c and c++ defaults."
  (setq comment-start "/* "
        comment-end " */"
        rebox-min-fill-column 90)
  (unless (memq 46 rebox-style-loop)
    (make-local-variable 'rebox-style-loop)
    (setcdr (last rebox-style-loop) '(46 47))))
(add-hook 'c++-mode-hook #'my-c++-setup)

;;(global-set-key [(shift meta q)] 'rebox-dwim)
;;(global-set-key [(meta q)] 'rebox-cycle)

(defhydra hydra-rebox (:foreign-keys run)
  "BOX"
  ("C-+" (lambda () (interactive) (cl-incf rebox-min-fill-column 10) (rebox-fill) (message "Fill column: %i" rebox-min-fill-column)) "+10")
  ("C--" (lambda () (interactive) (cl-decf rebox-min-fill-column 10) (rebox-fill) (message "Fill column: %i" rebox-min-fill-column)) "-10")
  ("C-*" (lambda () (interactive) (cl-incf rebox-min-fill-column 1) (rebox-fill) (message "Fill column: %i" rebox-min-fill-column)) "+1")
  ("C-/" (lambda () (interactive) (cl-decf rebox-min-fill-column 1) (rebox-fill) (message "Fill column: %i" rebox-min-fill-column)) "-1")
  ("C-<left>" (lambda () (interactive) (rebox-cycle '(-1))))
  ("C-<right>" rebox-cycle "cycle")
  ("C-d" rebox-dwim "dwim")
  ("C-f" rebox-fill "fill")
  ("M-q" nil "quit"))

(global-set-key (kbd "C-c ; m") 'hydra-rebox/body)
(global-set-key (kbd "C-c ; l") 'comment-line)
#+end_src

*** /thing-cmds/

#+begin_src elisp
(require 'thing-cmds-autoloads)
#+end_src

*** /rotate-text/

#+begin_src elisp
(require 'rotate-text)

(add-to-list 'rotate-text-symbols
             '("trace" "debug" "info" "warning" "error" "fatal"))
(add-to-list 'rotate-text-symbols
             '("unsigned" "signed"))
(add-to-list 'rotate-text-symbols
             '("void" "bool" "char" "wchar_t" "short" "int"
               "long" "size_t" "float" "double"))
(add-to-list 'rotate-text-symbols
             '("red" "green" "blue" "black" "white" "orange"
               "yellow" "cyan" "violet" "magenta" "brown"
               "salmon" "golden" "pink"))
(add-to-list 'rotate-text-symbols
             '("==" "!=" "<" ">" "<=" ">="))
(add-to-list 'rotate-text-symbols
             '("&&" "||"))
(add-to-list 'rotate-text-symbols
             '("=" "+=" "-=" "*=" "/=" "%=" "<<=" ">>=" "&="
               "^=" "|="))
(add-to-list 'rotate-text-symbols
             '("static_cast" "dynamic_cast" "const_cast" "reinterpret_cast"))
(add-to-list 'rotate-text-symbols
             '("false" "true"))
(add-to-list 'rotate-text-symbols
             '("None" "False" "True"))


(global-set-key (kbd "M-<up>") #'rotate-text)
(global-set-key (kbd "M-<down>") #'rotate-text-backward)
#+end_src

*** /multiple-cursors/

#+begin_src elisp
(with-eval-after-load 'multiple-cursors
  (setq mc/list-file (expand-file-name "cache/mc-lists.el" user-emacs-directory)))

;; Add a cursor to each line in active region
(global-set-key (kbd "C-c m r") 'mc/edit-lines)

;; Add a cursor based on keywords in the buffer
;; (global-set-key (kbd "C->") 'mc/mark-next-like-this)
;; (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)

(global-set-key (kbd "C-c m p") #'mc/mark-previous-like-this)
(global-set-key (kbd "C-c m n") #'mc/mark-next-like-this)
(global-set-key (kbd "C-c m a") #'mc/mark-all-like-this-dwim)

(global-set-key (kbd "C-c m S") #'mc/mark-previous-symbol-like-this)
(global-set-key (kbd "C-c m s") #'mc/mark-next-symbol-like-this)
(global-set-key (kbd "C-c m M-s") #'mc/mark-all-symbols-like-this)
(global-set-key (kbd "C-c m C-s") #'mc/mark-all-symbols-like-this-in-defun)

(global-set-key (kbd "C-c m W") #'mc/mark-previous-word-like-this)
(global-set-key (kbd "C-c m w") #'mc/mark-next-word-like-this)
(global-set-key (kbd "C-c m M-w") #'mc/mark-all-words-like-this)
(global-set-key (kbd "C-c m C-w") #'mc/mark-all-words-like-this-in-defun)

(global-set-key (kbd "C-S-<mouse-1>") #'mc/add-cursor-on-click)


;; [ Add a cursor win mouse
;; another option
;; (global-unset-key (kbd "M-<down-mouse-1>"))
;; (global-set-key (kbd "M-<mouse-1>") 'mc/add-cursor-on-click)
;; ]
#+end_src

*** /very-long-files/ (vlf)

#+begin_src elisp
(require 'vlf-setup)

(setq vlf-batch-size (eval-when-compile (* 1024 1024)))

(defun find-file-check-make-large-file-read-only-hook ()
  "If a file is over a given size, make the buffer read only."
  (when (> (buffer-size) vlf-batch-size)
    (setq buffer-read-only t)
    (buffer-disable-undo)
    (fundamental-mode)
    (message "Big file: %s. Read-only, fundamental mode & undo disabled."
             (buffer-file-name))))
(add-hook 'find-file-hook 'find-file-check-make-large-file-read-only-hook)
#+end_src

*** /figlet/

#+begin_src elisp
(require 'figlet)

(setq figlet-default-font "banner"
      figlet-options
      '("-w" "90"))
#+end_src

*** /guess-language/

#+begin_src elisp
(require 'guess-language)

;; (add-hook 'text-mode-hook 'guess-language-mode)

(defface guess-language-mode-line
  '((t  (:foreground "#822")))
  "Face used in search mode for titles."
  :group 'guess-language)

(setcar (cdr (assq 'guess-language-mode minor-mode-alist))
        '(:eval
          (propertize (format "%s" (or guess-language-current-language "∅"))
                      'face 'guess-language-mode-line)))

(setq guess-language-languages '(en es)
      guess-language-min-paragraph-length 35)

(defun language-text-to-speak-region (start end)
  (interactive (if (use-region-p)
                   (list (region-beginning) (region-end))
                 (list (point) (point-max))))
  (let ((string (buffer-substring-no-properties start end))
        (language (symbol-name (guess-language-region start end))))
    (setq language-text-to-speak-process
          (cond
           ((executable-find "espeak")
            (start-process "*espeak-process*" nil
                           "espeak" "--stdin" "-v" language))
           ((executable-find "festival")
            (make-process
             :name "*festival-process*"
             :command (list "festival" "--tts" "--language"
                            (pcase language
                              ("es" "spanish")
                              ("en" "english")))
             :coding 'latin-1))))
    (process-send-string language-text-to-speak-process (concat string "\n"))
    (process-send-eof language-text-to-speak-process)))

(defun language-text-to-speak-stop ()
  (interactive)
  (if language-text-to-speak-process
      (interrupt-process language-text-to-speak-process)))

(mapc (lambda (x)
        (global-set-key
         (kbd (concat "C-c g " (car x))) (cdr x)))
      '(("p" . language-phonemic-script-at-point)
        ("t" . language-en-es-translation-at-point)
        ("b" . language-en-es-phonemic-script-and-translation-at-point)
        ("R" . language-text-to-speak-region)
        ("S" . language-text-to-speak-stop)))
#+end_src

*** /annotate/

#+begin_src elisp
(with-eval-after-load 'annotate
  (setcar (cdr (assq 'annotate-mode minor-mode-alist)) "📓")

  (setq annotate-file (expand-file-name
                       ".annotations"
                       "~/Prog/org")
        annotate-use-messages nil
        annotate-annotation-column 80
        annotate-annotation-max-size-not-place-new-line 10
        annotate-blacklist-major-mode '(text-mode))

  (defun annotate-refresh ()
    (interactive)
    (if (null annotate-mode)
        (annotate-mode)
      (annotate-with-inhibit-modification-hooks
       (annotate-mode -1)
       (annotate-mode 1))))

  (setcdr annotate-mode-map nil)
  (define-key annotate-mode-map (kbd "C-c A a") 'annotate-annotate)
  (define-key annotate-mode-map (kbd "C-c A s") 'annotate-show-annotation-summary)
  (define-key annotate-mode-map (kbd "C-c A n") 'annotate-goto-next-annotation)
  (define-key annotate-mode-map (kbd "C-c A p") 'annotate-goto-previous-annotation)
  (define-key annotate-mode-map (kbd "C-c A r") 'annotate-refresh))

;; (add-hook 'find-file-hook 'annotate-mode)
(global-set-key (kbd "C-c A A") 'annotate-mode)
#+end_src

*** /ov/

#+begin_src elisp
(require 'ov)
(global-set-key (kbd "M-g M-f") 'ov-goto-next)
(global-set-key (kbd "M-g M-b") 'ov-goto-prev)
#+end_src

** Not always required
*** /string-inflection/

#+begin_src elisp
(global-set-key (kbd "C-c C-u") 'string-inflection-all-cycle)
#+end_src

*** /rotate-text/

#+begin_src elisp
(require 'rotate-text-autoloads)
(global-set-key (kbd "C-c C-+") 'rotate-text)
(global-set-key (kbd "C-c C--") 'rotate-text-backward)
#+end_src

*** /grugru/

#+begin_src elisp
(with-eval-after-load 'grugru
  (eval-when-compile
    (require 'grugru))
  (grugru-default-setup)
  (grugru-define-multiple
   (rust-mode
    (non-alphabet "&&" "||")
    (non-alphabet "&" "|")
    (non-alphabet "+" "-")
    (non-alphabet "*" "/" "%")
    (non-alphabet "+=" "-=")
    (non-alphabet "*=" "/=" "%=")
    (non-alphabet "&=" "|=" "^=")
    (non-alphabet ">>=" "<<=")
    (non-alphabet "++" "--")
    (non-alphabet "==" "!=")
    (non-alphabet "<" "<=" ">" ">=")
    (symbol "true" "false")
    (symbol "break" "continue"))
   (python-mode
    (non-alphabet "+" "-")
    (non-alphabet "*" "/" "%")
    (non-alphabet "+=" "-=")
    (non-alphabet "*=" "/=" "%=")
    (non-alphabet "&=" "|=" "^=")
    (non-alphabet ">>=" "<<=")
    (non-alphabet "==" "!=")
    (non-alphabet "<" "<=" ">" ">=")
    (symbol "True" "False" "None")
    (symbol "break" "continue"))
   ))

(global-set-key (kbd "C-;") #'grugru)
#+end_src

*** /syslog-mode/

#+begin_src elisp
(push '("\\.log\\'" . syslog-mode) auto-mode-alist)
(with-eval-after-load 'syslog-mode
  (push '("\\_<\\([A-Za-z]*[Ww]arnings?\\|WARNINGS?\\|[Ww]arn\\|WARN\\|[Dd]eprecated\\|DEPRECATED\\)\\_>"
          1 'syslog-warn)
        syslog-font-lock-keywords)
  (push '("\\_<\\([A-Za-z]*[Ee]rrors?\\|ERRORS?\\|[A-Za-z]*[Ee]xceptions?\\|EXCEPTIONS?\\|\\(std\\)?[Ee]rr\\(no\\)?\\|\\(STD\\)?ERR\\(NO\\)?\\|[Nn]ot?\\|NOT?\\|[Ff]ailed\\|FAILED\\|[Ff]ailures?\\|FAILURES?\\|[Ff]ails?\\|FAILS?\\)\\_>"
          1 'syslog-error)
        syslog-font-lock-keywords)
  (defun syslog-fix-buffer ()
    (goto-char (point-min))
    (let ((inhibit-read-only t))
      (when (search-forward "\e" nil t)
        (ansi-color-apply-on-region (point-min) (point-max))
        (goto-char (point-min)))
      (while (search-forward "\r" nil t)
        (replace-match "" t t)))
    (set-buffer-modified-p nil))
  (add-hook 'syslog-mode-hook 'syslog-fix-buffer))
#+end_src

*** /fd-dired/

#+begin_src elisp
(with-eval-after-load 'fd-dired
  (cond ((executable-find "fdfind")
         (setq fd-dired-program "fdfind"))
        ((executable-find "fd-find")
         (setq fd-dired-program "fd-find"))
        ((executable-find "fd")
         (setq fd-dired-program "fd"))))

(global-set-key (kbd "M-g f") 'fd-dired)
#+end_src

*** /rg/ (before consult)

#+begin_src elisp
(global-set-key (kbd "M-g R") 'rg-menu)
(global-set-key (kbd "M-g r") 'rg-menu)
(with-eval-after-load 'rg
  (rg-enable-default-bindings (kbd "M-g a"))
  (push '(rg-mode "\nFile: " "\n\n" "-*-"
                  (lambda (arg)
                    (re-search-forward hs-block-end-regexp nil t))
                  nil) hs-special-modes-alist)
  (defun rg-mode-hideshow-config ()
    (setq-local comment-start "-*-"
                comment-end "-*-")
    (hs-minor-mode))
  (add-hook 'rg-mode-hook 'rg-mode-hideshow-config))
#+end_src

*** /consult/ (when installed, after rg and fd-dired)

#+begin_src elisp
(when (locate-library "consult")
  (with-eval-after-load 'consult
    ;; (add-hook 'completion-list-mode-hook 'consult-preview-at-point-mode)
    (define-key completion-list-mode-map " " 'consult-preview-at-point)
    (setq consult-project-root-function 'project-root-directory
          consult-find-args "find . -not ( -wholename */.* -prune -readable )"
          consult-ripgrep-args
          "rg --hidden --null --line-buffered --color=never --max-columns=1000 --path-separator /   --smart-case --no-heading --line-number ."
          consult--gc-threshold gc-cons-threshold
          consult-async-split-style 'comma)

    ;; (defun consult-ripgrep-ext ()
    ;;   (interactive)
    ;;   (let ((file-name (buffer-file-name)))
    ;;     (if file-name
    ;;         (let* ((file-ext (file-name-extension file-name))
    ;;                (file-type
    ;;                 (car
    ;;                  (split-string
    ;;                   (--min-by
    ;;                    (>= (length it) (length other))
    ;;                    (or (split-string
    ;;                         (shell-command-to-string
    ;;                          (concat
    ;;                           "rg --type-list | rg ' \\*." file-ext "(,|$)'"))
    ;;                         "\n" t)
    ;;                        (user-error "Type not found in ripgrep")))
    ;;                   ":")))
    ;;                (consult-ripgrep-command
    ;;                 (concat "rg -t"
    ;;                         file-type
    ;;                         (substring consult-ripgrep-command 2))))
    ;;           (call-interactively 'consult-ripgrep))
    ;;       (call-interactively 'consult-ripgrep))))

    (defvar consult--fd-command
      (or (executable-find "fdfind")
          "fd"))
    (defun consult--fd-builder (input)
      (pcase-let* ((`(,arg . ,opts) (consult--command-split input))
                   (`(,re . ,hl) (funcall consult--regexp-compiler
                                          arg 'extended)))
        (when re
          (list :command (append
                          (list consult--fd-command
                                "--hidden" "--color=never" "--full-path"
                                (consult--join-regexps re 'extended))
                          opts)
                :highlight hl))))
    (defun consult-fd (&optional dir initial)
      (interactive "P")
      (let* ((prompt-dir (consult--directory-prompt "Fd" dir))
             (default-directory (cdr prompt-dir)))
        (find-file (consult--find (car prompt-dir) #'consult--fd-builder initial)))))

  (autoload 'consult-fd "consult" nil t)
  ;; (autoload 'consult-ripgrep-ext "consult" nil t)
  (global-set-key (kbd "M-y") 'consult-yank-pop)
  (global-set-key (kbd "M-g F") 'consult-find)
  (global-set-key (kbd "M-g f") 'consult-fd)
  (global-set-key (kbd "M-g l") 'consult-locate)
  (global-set-key (kbd "M-g e") 'consult-error)
  (global-set-key (kbd "M-g r") 'consult-ripgrep)
  ;;(global-set-key (kbd "M-g R") 'consult-ripgrep-ext)
  (global-set-key (kbd "M-g O") 'consult-outline)
  (global-set-key (kbd "M-g o") 'consult-multi-occur)
  (global-set-key (kbd "M-g m") 'consult-mark)
  (global-set-key (kbd "M-g M") 'consult-global-mark)
  (global-set-key (kbd "M-g i") 'consult-imenu)
  (global-set-key (kbd "M-g I") 'consult-project-imenu)
  (global-set-key (kbd "M-g M-g") 'consult-goto-line)
  (global-set-key (kbd "M-g M-l") 'consult-line)
  (global-set-key (kbd "M-g C-k") 'consult-kmacro)
  (global-set-key (kbd "M-g b") 'consult-buffer)
  (global-set-key (kbd "M-g 4 b") 'consult-buffer-other-window)
  (global-set-key (kbd "M-g 5 b") 'consult-buffer-other-frame)
  (global-set-key (kbd "C-x r x") 'consult-register)
  (global-set-key (kbd "C-x r b") 'consult-bookmark))
#+end_src

*** /embark/

#+begin_src elisp
(with-eval-after-load 'embark
  (when (locate-library "embark-consult")
    (with-eval-after-load 'consult
      (require 'embark-consult)))
  
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none))))

  (setq embark-action-indicator
        (lambda (map &optional _target)
          (which-key--show-keymap "Embark" map nil nil 'no-paging)
          #'which-key--hide-popup-ignore-command)
        embark-become-indicator embark-action-indicator)

  (defun embark-act-noquit ()
    "Run action but don't quit the minibuffer afterwards."
    (interactive)
    (let ((embark-quit-after-action nil))
      (embark-act))))

(autoload 'embark-act-noquit "embark" nil t)
(global-set-key (kbd "C-.") 'embark-act)
(global-set-key (kbd "C-:") 'embark-act-noquit)
#+end_src

*** Language server protocol /lsp-mode/                            :programming:

#+begin_src elisp
(with-eval-after-load 'lsp-mode
  (message "Importing lsp-config")

  (add-hook 'lsp-after-open-hook #'lsp-enable-imenu)
  (add-hook 'lsp-mode-hook #'lsp-enable-which-key-integration)
  (when (fboundp 'lsp-origami-try-enable)
    (add-hook 'lsp-after-open-hook #'lsp-origami-try-enable))

  (set-face-attribute 'lsp-face-highlight-read nil
                      :inherit 'unspecified
                      :underline t
                      :weight 'bold
                      :background 'unspecified)
  (set-face-attribute 'lsp-face-highlight-write nil
                      :inherit 'unspecified
                      :underline t
                      :weight 'bold
                      :background 'unspecified)

  (setq minor-mode-alist
        (delq (assoc 'lsp-mode
                     minor-mode-alist)
              minor-mode-alist)
        lsp-enable-symbol-highlighting nil
        lsp-enable-xref nil ;; lsp-enable-xref t suppress etags--xref-backend
        ;; performance
        read-process-output-max (* 3 1024 1024)
        lsp-completion-provider :capf
        lsp-idle-delay 2.0
        lsp-enable-file-watchers nil
        lsp-file-watch-threshold 500
        ;; snippet is slow
        lsp-enable-snippet nil
        ;; lsp log
        lsp-log-io nil    ;; `(lsp-workspace-show-log)' Display the log buffer
        lsp-log-max 1000  ;; Max lines in the log buffer
        ;; lsp
        lsp-keymap-prefix "s-l"
        ;; flycheck option bug https://github.com/emacs-lsp/lsp-ui/issues/347
        lsp-diagnostics-provider :flymake
        lsp-modeline-code-actions-enable nil
        lsp-modeline-diagnostics-enable nil
        lsp-file-watch-ignored (cons "[/\\\\]tmp$"
                                     lsp-file-watch-ignored)
        ;; eldoc
        lsp-eldoc-render-all t
        ;; signature
        ;; lsp-signature-render-documentation nil
        ;; headerline
        lsp-headerline-breadcrumb-enable nil)

  (if (null (require 'lsp-pyls nil 'noerror))
      (message-color #("ERROR missing package `lsp-pyls'" 0 5 (face error)))
    ;; lsp-pyls
    ;; [ Fix https://github.com/palantir/python-language-server/issues/771
    ;;   changing autopep8 for yapf
    (setq lsp-pyls-plugins-autopep8-enabled nil
          lsp-pyls-plugins-yapf-enabled t)
    ;; ]
    )

  ;; [ lsp-ui
  (if (require 'lsp-ui nil 'noerror)
      (progn (add-hook 'lsp-mode-hook #'lsp-ui-mode)

             (setq lsp-ui-doc-enable nil
                   lsp-signature-auto-activate nil ;; <xor signature>
                   lsp-ui-doc-include-signature t  ;; <xor signature>
                   lsp-ui-doc-position 'top
                   lsp-ui-doc-alignment 'frame
                   lsp-ui-doc-max-height 10
                   lsp-ui-doc-max-width 80
                   ;; lsp-ui-sideline
                   lsp-ui-sideline-delay 0.5
                   lsp-ui-sideline-show-hover t)
             (when (or (eq lsp-diagnostics-provider :flymake)
                       (and (eq lsp-diagnostics-provider :auto)
                            (not (locate-library "flycheck"))))
               ;; not working with flymake
               (setq lsp-ui-sideline-show-diagnostics nil))

             (defun lsp-ui-or-xref-find-definitions ()
               (interactive)
               (let (result)
                 (condition-case nil
                     (setq result (call-interactively
                                   'lsp-ui-peek-find-definitions))
                   (error (call-interactively 'xref-find-definitions)))
                 (if (and (stringp result)
                          (string-equal "Not found" (substring result 0 9)))
                     (call-interactively 'xref-find-definitions))))

             (defun lsp-ui-or-xref-find-references ()
               (interactive)
               (let (result)
                 (condition-case nil
                     (setq result (call-interactively
                                   'lsp-ui-peek-find-references))
                   (error (call-interactively 'xref-find-references)))
                 (if (and (stringp result)
                          (string-equal "Not found" (substring result 0 9)))
                     (call-interactively 'xref-find-references))))

             (define-key lsp-ui-mode-map [remap xref-find-definitions]
               'lsp-ui-or-xref-find-definitions)
             (define-key lsp-ui-mode-map [remap xref-find-references]
               'lsp-ui-or-xref-find-references))

    (defun lsp-or-xref-find-definition ()
      (interactive)
      (let (result)
        (condition-case nil
            (setq result (call-interactively 'lsp-find-definition))
          (error (call-interactively 'xref-find-definitions)))
        (if (and (stringp result)
                 (string-equal "Not found" (substring result 0 9)))
            (call-interactively 'xref-find-definitions))))

    (defun lsp-or-xref-find-references ()
      (interactive)
      (let (result)
        (condition-case nil
            (setq result (call-interactively 'lsp-find-references))
          (error (call-interactively 'xref-find-references)))
        (if (and (stringp result)
                 (string-equal "Not found" (substring result 0 9)))
            (call-interactively 'xref-find-references))))

    (define-key lsp-mode-map [remap xref-find-definitions]
      'lsp-or-xref-find-definition)
    (define-key lsp-mode-map [remap xref-find-references]
      'lsp-or-xref-find-references))
  ;; ]

  ;; [ company-lsp -- not supported by lsp-mode
  ;; (when (and (featurep 'company)
  ;;            (load "company-lsp" t))
  ;;   (push 'company-lsp company-backends)
  ;;   (setq company-lsp-cache-candidates 'auto))
  ;; ]

  ;; [ dap-mode
  (when (locate-library "dap-mode")
    (defun dap-enable-which-key-integration ()
      (apply
       #'which-key-add-major-mode-key-based-replacements
       major-mode
       (lsp--prepend-prefix
        (list "d" "debugging"
              "d m" "dap hydra menu"
              "d d" "start dap debugging"
              "d t" "toggle dap tooltip mode"))))
    (add-hook 'lsp-mode-hook #'dap-enable-which-key-integration)
    (define-key lsp-command-map (kbd "d m") #'dap-hydra)
    (define-key lsp-command-map (kbd "d d") #'dap-debug)
    (define-key lsp-command-map (kbd "d t") #'dap-tooltip-mode))
  ;; ]
  )
#+end_src

*** Language server protocol /eglot/                               :programming:

#+begin_src elisp
(with-eval-after-load 'eglot
     (message "Importing eglot-config")

     (defun eglot-xor-semantic ()
       (semantic-mode (if (eglot-managed-p)
                          -1
                        1)))
     (setq mode-line-misc-info
           (delq (assoc 'eglot--managed-mode
                        mode-line-misc-info)
                 mode-line-misc-info)
           ;; performance
           read-process-output-max (* 3 1024 1024)
           ;; eglot
           eglot-events-buffer-size 50000
           eglot-sync-connect nil
           eglot-ignored-server-capabilites '(:documentHighlightProvider)
           eglot-managed-mode-hook (nconc
                                    '(eglot-xor-semantic
                                      ;; (lambda ()
                                      ;;   (eldoc-mode -1))
                                      )
                                    eglot-managed-mode-hook))
     (setcdr (assoc '(c++-mode c-mode) eglot-server-programs)
             '("ccls" "--init={\"clang\": {\"extraArgs\": [\"-std=c++17\"]}}"))
     (setcdr (assoc '(php-mode phps-mode) eglot-server-programs)
             '("intelephense" "--stdio")))
#+end_src

*** /rust/                                                         :programming:

#+begin_src elisp
;; rustic has automatic configuration
(with-eval-after-load 'rustic
  (message "Importing rustic config")
  (setq rustic-lsp-client 'eglot))
(with-eval-after-load 'rust-mode
  (message "Importing rust-mode config")
  (add-hook 'rust-mode-hook 'eglot-ensure))
#+end_src

*** /java/                                                         :programming:

#+begin_src elisp
;; [ eglot
(add-hook 'java-mode-hook 'eglot-ensure)
;; ]
;; [ lsp-mode
;; (add-hook 'java-mode-hook (lambda ()
;;                             (when (require 'lsp-java nil t)
;;                               (lsp-deferred))))
;; (defun load-once-java-stuff ()
;;   (with-eval-after-load 'dap-mode
;;     (require 'dap-java))
;;   (remove-hook 'java-mode-hook 'load-once-java-stuff))
;; (add-hook 'java-mode-hook 'load-once-java-stuff)
;; ]
#+end_src

*** /javascript/                                                   :programming:

#+begin_src elisp
(defun language-server-protocol-js-cond ()
  (unless (derived-mode-p 'ein:ipynb-mode)
    (eglot-ensure)
    ;;(lsp-deferred)
    ))
(add-hook 'js-mode-hook #'language-server-protocol-js-cond)
(with-eval-after-load 'js
  (with-eval-after-load 'dap-mode
    (require 'dap-firefox)
    (dap-firefox-setup))
  (setq js-indent-level 2)
  (define-key js-mode-map "'" #'insert-pair)
  (define-key js-mode-map [(meta ?.)] nil))
#+end_src

*** /typescript/                                                   :programming:

#+begin_src elisp
(setcar (rassoc 'typescript-mode auto-mode-alist) "\\.tsx?\\'")
(add-hook 'typescript-mode-hook 'lsp-deferred)
(with-eval-after-load 'typescript-mode
  (with-eval-after-load 'dap-mode
    (require 'dap-firefox)
    (dap-firefox-setup))
  (setq typescript-indent-level 2)
  (define-key typescript-mode-map "'" #'insert-pair))
#+end_src

*** /php-mode/                                                     :programming:

#+begin_src elisp
(add-to-list 'auto-mode-alist '("\\.php\\'" . php-mode))
(add-hook 'php-mode-hook 'eglot-ensure)
(with-eval-after-load 'php-mode
  (with-eval-after-load 'dap-mode
    (require 'dap-php))
  (setq php-mode-coding-style 'psr2)

  ;; Keys
  (define-key php-mode-map (kbd "M-b") nil)
  (define-key php-mode-map (kbd "C-.") nil))
#+end_src

*** /sh-mode/                                                      :programming:

#+begin_src elisp
(with-eval-after-load 'sh-script
  (define-key sh-mode-map "'" #'insert-pair))
#+end_src

*** /minimap/

#+begin_src elisp
(with-eval-after-load 'minimap
  (setq minor-mode-alist (assq-delete-all 'minimap-mode minor-mode-alist))

  ;; (add-hook 'minimap-sb-mode-hook
  ;;           (lambda ()
  ;;             (setq mode-line-format nil)
  ;;             (set-window-fringes (minimap-get-window) 0 0 nil)))

  ;;(minimap-mode 1)

  ;;    ###    ########  ####
  ;;   ## ##   ##     ##  ##
  ;;  ##   ##  ##     ##  ##
  ;; ##     ## ########   ##
  ;; ######### ##         ##
  ;; ##     ## ##         ##
  ;; ##     ## ##        ####

  ;; (set-face-attribute 'minimap-font-face nil
  ;;                     :family "Iosevka Term")

  (unless (face-foreground 'minimap-current-line-face)
    (set-face-attribute 'minimap-current-line-face nil
                        :foreground "yellow"))

  (setq minimap-window-location 'right
        minimap-width-fraction 0.0 ;; always minimum width 
        minimap-minimum-width 15
        minimap-update-delay 0.3
        minimap-always-recenter nil
        minimap-recenter-type 'relative
        minimap-display-semantic-overlays nil ;; heavy old parser
        minimap-tag-only nil
        minimap-hide-scroll-bar t
        minimap-hide-fringes t
        minimap-enlarge-certain-faces nil
        minimap-sync-overlay-properties '(invisible)
        minimap-major-modes '(prog-mode text-mode))

  ;; minimap version 1.2
  ;; (defun minimap-toggle ()
  ;;   "Toggle minimap for current buffer."
  ;;   (interactive)
  ;;   (if (minimap-get-window)
  ;;       (minimap-kill)
  ;;     (minimap-create)))
  ;; (global-set-key (kbd "M-s 7 m") 'minimap-toggle)
  )
(global-set-key (kbd "M-s 7 m") 'minimap-mode)
#+end_src

*** /csv-mode/

#+begin_src elisp
(require 'csv-mode-autoloads)
(with-eval-after-load 'csv-mode
  (setq csv-separators '("," ";" "	" "|")
        ;; [ read defcustom csv-separators :set field
        csv-separator-chars (mapcar #'string-to-char csv-separators)
        csv--skip-chars (apply #'concat "^\n" csv-separators)
        csv-separator-regexp (apply #'concat `("[" ,@csv-separators "]"))
        csv-font-lock-keywords
        ;; NB: csv-separator-face variable evaluates to itself.
        `((,csv-separator-regexp (0 'csv-separator-face)))
        ;; ]
        csv-field-quotes '("\"")  ;; ("\"" "'" "`")
        csv-comment-start-default nil  ;; "#"
        csv-comment-start nil  ;; "#"
        csv-align-style 'auto
        csv-align-padding 1
        csv-header-lines 1
        csv-invisibility-default nil)

  (defun count-occurrences-in-current-line (char)
    "Count occurrences of CHAR in current line."
    (cl-count char (buffer-substring-no-properties (line-beginning-position) (line-end-position))))

  (defun csv-count-occurrences-separators-in-current-line ()
    "Return list of count occurrences of csv separators in current line."
    (mapcar #'count-occurrences-in-current-line (mapcar #'string-to-char (default-value 'csv-separators))))

  (defun csv-separators-max (&optional line)
    "Return max occurrence separator."
    (save-excursion
      (goto-char (point-min))
      (if line (forward-line (1- line)))
      (let* ((frec (csv-count-occurrences-separators-in-current-line))
             (assoc-list (cl-mapcar #'cons frec (default-value 'csv-separators))))
        (while (and (cl-every (lambda (number)
                                (= 0 number))
                              frec)
                    (= 0 (forward-line 1)))
          (setq frec (csv-count-occurrences-separators-in-current-line)
                assoc-list (cl-mapcar #'cons frec (default-value 'csv-separators))))
        (if (cl-every (lambda (number)
                        (= 0 number))
                      frec)
            nil
          (cdr (assoc (seq-max frec) assoc-list))))))

  (defun csv-detect-separator (&optional line)
    "Detect csv separator in current buffer and update csv variables."
    (interactive (list (line-number-at-pos)))
    ;; (make-local-variable 'csv-separators)
    (let ((csv-sep-max (csv-separators-max line)))
      (if (not csv-sep-max)
          (message "CSV separator not found, call `csv-detect-separator' or restart `csv-mode'")
        (csv-set-comment-start nil)
        (setq-local csv-separators (list csv-sep-max))
        (setq-local csv-separator-chars (mapcar #'string-to-char csv-separators))
        (setq-local csv--skip-regexp (concat "^\n" csv-separator-chars))
        (setq-local csv-separator-regexp (concat "[" csv-separator-chars "]"))
        (setq-local csv-font-lock-keywords (list (list csv-separator-regexp '(0 'csv-separator-face))))
        (message "CSV separator detected: %s" csv-separators))))

  ;;(add-hook 'csv-mode-hook #'csv-detect-separator)

  ;; Keys
  (define-key csv-mode-map (kbd "<tab>") 'csv-forward-field)
  (define-key csv-mode-map (kbd "<backtab>") 'csv-backward-field))
#+end_src

*** /markdown-mode+/

#+begin_src elisp
(with-eval-after-load 'markdown-mode
  (message "Importing markdown-mode+")

  (require 'markdown-mode+))
#+end_src

*** /yaml-mode/

#+begin_src elisp
(add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-mode))
(with-eval-after-load 'yaml-mode
  (define-key yaml-mode-map "\C-m" 'newline-and-indent))
#+end_src

*** TODO /rst/                                                        :markdown:

- [ ] Find /sphinx-frontend-config/ in repo

#+begin_src elisp
(with-eval-after-load 'rst
  (message "Importing rst config")

  (with-eval-after-load 'sphinx-doc
    (require 'sphinx-frontend-config)))
#+end_src

*** /latex/                                                           :markdown:

#+begin_src elisp
(add-to-list 'auto-mode-alist '("\\.ptx\\'" . latex-mode))
(with-eval-after-load 'latex
  (message "Importing latex config")
  ;; latex mode buttons
  (defvar TeX-bar-LaTeX-button-alist
    (quote
     ((latex :image
             (lambda nil
               (if TeX-PDF-mode "pdftex" "tex"))
             :command
             (progn
               (TeX-save-document
                (TeX-master-file))
               (TeX-command "LaTeX"
                            (quote TeX-master-file)
                            -1))
             :help
             (lambda
               (&rest ignored)
               (TeX-bar-help-from-command-list "LaTeX")))
      (pdfpslatex :image "pdftex" :command
                  (progn
                    (TeX-save-document
                     (TeX-master-file))
                    (TeX-command "PDFpsLaTeX"
                                 (quote TeX-master-file)
                                 -1))
                  :help
                  (lambda
                    (&rest ignored)
                    (TeX-bar-help-from-command-list "PDFpsLaTeX")))
      (evince :image "viewpdf" :command
              (TeX-command "Evince"
                           (quote TeX-master-file)
                           -1)
              :help
              (lambda
                (&rest ignored)
                (TeX-bar-help-from-command-list "Evince")))
      (clean :image "delete" :command
             (TeX-command "Clean"
                          (quote TeX-master-file)
                          -1)
             :help
             (lambda
               (&rest ignored)
               (TeX-bar-help-from-command-list "Clean")))
      (pdflatex :image "pdftex" :command
                (progn
                  (TeX-save-document
                   (TeX-master-file))
                  (TeX-command "PDFLaTeX"
                               (quote TeX-master-file)
                               -1))
                :help
                (lambda
                  (&rest ignored)
                  (TeX-bar-help-from-command-list "PDFLaTeX")))
      (next-error :image "error" :command TeX-next-error :enable
                  (plist-get TeX-error-report-switches
                             (intern
                              (TeX-master-file)))
                  :visible
                  (plist-get TeX-error-report-switches
                             (intern
                              (TeX-master-file))))
      (view :image
            (lambda nil
              (if TeX-PDF-mode "viewpdf" "viewdvi"))
            :command
            (TeX-command "View"
                         (quote TeX-master-file)
                         -1)
            :help
            (lambda
              (&rest ignored)
              (TeX-bar-help-from-command-list "View")))
      (file :image "dvips" :command
            (TeX-command "File"
                         (quote TeX-master-file)
                         -1)
            :visible
            (not TeX-PDF-mode)
            :help
            (lambda
              (&rest ignored)
              (TeX-bar-help-from-command-list "File")))
      (bibtex :image "bibtex" :command
              (TeX-command "BibTeX"
                           (quote TeX-master-file)
                           -1)
              :help
              (lambda
                (&rest ignored)
                (TeX-bar-help-from-command-list "BibTeX")))
      (clean :image "delete" :command
             (TeX-command "Clean"
                          (quote TeX-master-file)
                          -1)
             :help
             (lambda
               (&rest ignored)
               (TeX-bar-help-from-command-list "Clean")))
      (latex-symbols-experimental :alias :eval-group LaTeX-symbols-toolbar-switch-contents LaTeX-symbols-toolbar-contents))))

  (defvar TeX-bar-LaTeX-buttons
    (quote
     (new-file open-file dired kill-buffer save-buffer undo cut copy paste
               [separator nil]
               latex next-error view bibtex
               (pdfpslatex evince clean)))))
#+end_src

*** /org-mode/                                                        :markdown:

#+begin_src elisp
(setq org-replace-disputed-keys t)
(unless (fboundp 'org-mode)
  (message "`org-mode' not found")
  (autoload 'org-mode "org" nil t))
(with-eval-after-load 'org
  (message "Importing org-config")
  ;; Spell checker
  (add-hook 'org-mode-hook 'flyspell-mode)
  ;; (add-hook 'org-mode-hook
  ;;           (defun org-mode-modify-syntax-entry<-and-continuation-lines ()
  ;;             (modify-syntax-entry ?< "_" org-mode-syntax-table)))
  ;; (plist-put org-format-latex-options :scale 1.) ;; default

  ;; ;;;;; ;;
  ;; Faces ;;
  ;; ;;;;; ;;
  (defface org-checkbox-todo
    '((t (:inherit org-todo)))
    "Face for the text part of an unchecked org-mode checkbox."
    :group 'org-faces)
  (font-lock-add-keywords
   'org-mode
   '(("^[ \t]*\\(?:[-+*]\\|[0-9]+[).]\\)[ \t]+\\(\\(?:\\[@\\(?:start:\\)?[0-9]+\\][ \t]*\\)?\\[\\(?: \\|\\([0-9]+\\)/\\2\\)\\][^\n]*\n\\)"
      0 'org-checkbox-todo append))
   'append)

  (defface org-checkbox-partial
    '((t (:foreground "gold" :inherit org-todo)))
    "Face for the text part of a checked org-mode checkbox."
    :group 'org-faces)
  (font-lock-add-keywords
   'org-mode
   '(("^[ \t]*\\(?:[-+*]\\|[0-9]+[).]\\)[ \t]+\\(\\(?:\\[@\\(?:start:\\)?[0-9]+\\][ \t]*\\)?\\[\\(?:-\\|\\([0-9]+\\)/\\2\\)\\][^\n]*\n\\)"
      0 'org-checkbox-partial append))
   'append)

  (defface org-checkbox-done
    '((t (:inherit org-done)))
    "Face for the text part of a checked org-mode checkbox."
    :group 'org-faces)
  (font-lock-add-keywords
   'org-mode
   '(("^[ \t]*\\(?:[-+*]\\|[0-9]+[).]\\)[ \t]+\\(\\(?:\\[@\\(?:start:\\)?[0-9]+\\][ \t]*\\)?\\[\\(?:X\\|\\([0-9]+\\)/\\2\\)\\][^\n]*\n\\)"
      0 'org-checkbox-done append))
   'append)


  (set-face-attribute 'org-agenda-date nil
                      :background "#262e0d"
                      :box `(:line-width ,(if (>= emacs-major-version 28) '(-1 . -1) -1)))
  (set-face-attribute 'org-agenda-date-today nil
                      :background "#262e0d"
                      :box `(:line-width ,(if (>= emacs-major-version 28) '(-1 . -1) -1)))
  (set-face-attribute 'org-agenda-date-weekend nil
                      :box `(:line-width ,(if (>= emacs-major-version 28) '(-1 . -1) -1)))
  ;; (set-face-attribute 'org-scheduled-previously nil :foreground "rosy brown")
  ;; (set-face-attribute 'org-upcoming-deadline nil :foreground "orange")
  ;; (set-face-attribute 'org-warning nil :foreground "gold")
  ;; (set-face-attribute 'org-tag nil :bold nil)
  ;; (set-face-attribute 'org-level-1 nil :bold t :foreground "dark cyan")
  ;; (set-face-attribute 'org-level-2 nil :bold t :foreground "medium turquoise")
  ;; (set-face-attribute 'org-level-3 nil :bold t :foreground "pale turquoise")
  (face-spec-set 'org-ellipsis
                 '((((class color) (background dark))
                    :foreground "white"
                    :underline nil :overline nil :box nil :extend nil)
                   (((class color) (background light))
                    :foreground "dark goldenrod"
                    :underline nil :overline nil :box nil :extend nil)))

  (set-face-attribute 'org-block-begin-line nil
                      ;; :foreground "#388EFF" :background "#222210")
                      :overline nil
                      :underline nil)  ;; "#A7A6AA")

  (set-face-attribute 'org-block nil
                      :background "#070000")

  (set-face-attribute 'org-block-end-line nil
                      ;; :foreground "#388EFF" :background "#222210")
                      :underline nil
                      :overline nil)  ;; "#A7A6AA")

  (set-face-attribute 'org-code nil
                      :foreground "#bbff95")
  (org-link-set-parameters
   "file"
   :face (lambda (path) (if (file-exists-p path) 'org-link 'org-warning)))

  (require 'org-table)
  (setq org-hide-emphasis-markers nil
        org-hide-leading-stars nil
        org-priority-faces
        '((?A . "#C39BD3")
          (?B . "#AF7AC5")
          (?C . "#9B59B6")
          (?D . "#884EA0")
          (?E . "#76448A")

          (?F . "#85C1E9")
          (?G . "#5DADE2")
          (?H . "#3498DB")
          (?I . "#2E86C1")
          (?J . "#2874A6")

          (?K . "#82E0AA")
          (?L . "#58D68D")
          (?M . "#2ECC71")
          (?N . "#28B463")
          (?O . "#239B56"))
        org-emphasis-alist
        '(("*" (:foreground "#AAF") bold)
          ("/" (:foreground "#FF8") italic)
          ("_" underline)
          ("=" org-verbatim verbatim)
          ("~" org-code)
          ("+" (:strike-through t)))
        ;; TODO keyword faces
        org-todo-keyword-faces
        '(("TODO" :foreground "orange red" :weight bold)               ;; TODO
          ("NEXT" :foreground "gold" :weight bold)                     ;; NEXT
          ("DONE" :foreground "forest green" :weight bold)             ;; DONE
          ("PLAN" :foreground "deep sky blue" :weight bold)            ;; PLANNED
          ("STAR" :foreground "sky blue" :weight bold)                 ;; STARTED
          ("REOP" :foreground "indian red" :weight bold)               ;; REOPENED
          ("FINI" :foreground "dark olive green" :weight bold)         ;; FINISHED
          ("ENOU" :foreground "green yellow" :weight bold)             ;; ENOUGH
          ("DELE" :foreground "light green" :weight bold)              ;; DELEGATED
          ("LINK" :foreground "violet" :weight bold)                   ;; LINKED
          ("WAIT" :foreground "blue violet" :weight bold)              ;; WAITING
          ("HOLD" :foreground "dark violet" :weight bold :underline t) ;; HOLD
          ("CANC" :foreground "dark green" :weight bold)               ;; CANCELED
          ("FIXM" :foreground "dark red" :weight bold)                 ;; FIXME
          ("VERI" :foreground "dodger blue" :weight bold)              ;; VERIFY
          ("UNDO" :foreground "royal blue" :weight bold))              ;; UNDO
        ;; TAG faces
        org-tag-faces
        '(("@business"      :foreground "deep sky blue") ;; #00bfff
          ("@admin"         :foreground "blue")          ;; #0000ff
          ("@health"        :foreground "pink")          ;; #ffc0cb
          ("@job"           :foreground "dim gray")
          ("@improvement"   :foreground "green")         ;; #00ff00
          ("@research"      :foreground "yellow")        ;; #ffff00
          ("@language"      :foreground "orange")        ;; #ffa500
          ("@sport"         :foreground "purple")        ;; #a020f0
          ("@entertainment" :foreground "lime green")    ;; #32cd32
          ("@others"        :foreground "red")           ;; #ff0000
          ("business"       :foreground "#00a0e0")
          ("admin"          :foreground "#0000e0")
          ("job"            :foreground "dark gray")
          ("health"         :foreground "#e0a1ba")
          ("improvement"    :foreground "#00e000")
          ("research"       :foreground "#e0e000")
          ("language"       :foreground "#e0b400")
          ("sport"          :foreground "#9010e0")
          ("entertainment"  :foreground "#20ba20")
          ("others"         :foreground "#e00000"))
        org-tag-alist
        '((:startgrouptag) ("business")      (:grouptags) ("@business")
          (:endgrouptag)
          (:startgrouptag) ("admin")         (:grouptags) ("@admin")
          (:endgrouptag)
          (:startgrouptag) ("job")           (:grouptags) ("@job")
          (:endgrouptag)
          (:startgrouptag) ("improvement")   (:grouptags) ("@improvement")
          (:endgrouptag)
          (:startgrouptag) ("health")        (:grouptags) ("@health")
          (:endgrouptag)
          (:startgrouptag) ("research")      (:grouptags) ("@research")
          (:endgrouptag)
          (:startgrouptag) ("language")      (:grouptags) ("@language")
          (:endgrouptag)
          (:startgrouptag) ("sport")         (:grouptags) ("@sport")
          (:endgrouptag)
          (:startgrouptag) ("entertainment") (:grouptags) ("@entertainment")
          (:endgrouptag)
          (:startgrouptag) ("others")        (:grouptags) ("@others")
          (:endgrouptag))
        org-table-convert-region-max-lines 9999)
  ;;(:box t :foreground "#AAF")

  ;; ;;;;;;; ;;
  ;; Modules ;;
  ;; ;;;;;;; ;;

  (add-to-list 'org-modules 'org-id)
  (add-to-list 'org-modules 'org-habit)
  (add-to-list 'org-modules 'org-mouse)

  ;; ;;;;;;;;;;;;;;; ;;
  ;; Startup options ;;
  ;; ;;;;;;;;;;;;;;; ;;
  (setq org-hide-block-startup t
        org-link-descriptive nil ;; nil display the full links
        org-id-link-to-org-use-id 'use-existing
        org-replace-disputed-keys t
        org-startup-folded 'content
        org-startup-with-inline-images t
        org-pretty-entities t
        org-use-property-inheritance nil
        org-use-sub-superscripts nil
        org-export-with-sub-superscripts '{}
        org-export-allow-bind-keywords nil
        org-tags-column -80
        org-cycle-include-plain-lists t ;; 'integrate ;; list initally folded
        org-tags-sort-function #'string>
        org-ellipsis "▼"
        org-use-speed-commands
        (lambda () (and (looking-at org-outline-regexp)
                        (looking-back "^\**" (line-beginning-position))))
        org-adapt-indentation nil)

  ;; ;;;;;;;;;;;;;;;;;;; ;;
  ;; Babel block options ;;
  ;; ;;;;;;;;;;;;;;;;;;; ;;
  (setenv "GRAPHVIZ_DOT" (executable-find "dot"))

  (setq org-edit-src-content-indentation 0
        org-babel-min-lines-for-block-output 2
        org-babel-sh-command "bash"
        org-babel-python-command "python3"
        ;; inhibit any future confirmation requests
        org-confirm-babel-evaluate nil
        ;; no code will be evaluated as part of the export, no header arguments
        ;; will be obeyed. To evaluate insert at the beginning of the file:
        ;; # -*- org-confirm-babel-evaluate: t -*-
        org-export-babel-evaluate nil
        org-src-fontify-natively t
        org-src-tab-acts-natively t
        org-plantuml-jar-path (expand-file-name
                               "cache/java/plantuml.jar"
                               user-emacs-directory)
        org-babel-default-header-args:plantuml
        '((:results . "file")
          (:exports . "results")
          (:java . "-Dfile.encoding=UTF-8"))
        org-ditaa-jar-path (expand-file-name "cache/java/ditaa.jar"
                                             user-emacs-directory))

  ;; active Babel languages
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((C          . t)
     (awk        . t)
     (calc       . t)
     (ditaa      . t)
     (dot        . t)
     (emacs-lisp . t)
     (gnuplot    . t)
     (java       . t)
     (js         . t)
     (latex      . t)
     (maxima     . t)
     (octave     . t)
     (org        . t)
     (perl       . t)
     (php        . t)
     (plantuml   . t)
     (python     . t)
     (shell      . t)
     (sql        . t)
     (sqlite     . t)))

  (require 'ob)
  (require 'ob-screen)
  (require 'ob-async)

  (push (lambda () (require 'ob-screen))
        ob-async-pre-execute-src-block-hook)
  (setq ob-async-no-async-languages-alist
        '("ipython")
        org-babel-default-header-args:python
        '((:results . "output"))
        org-babel-default-header-args:sh
        '((:results . "output"))
        org-babel-default-header-args:bash
        '((:results . "output")))

  ;; Activated by default
  ;; (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
  ;; (add-to-list 'org-src-lang-modes '("conf" . conf))
  (push '("ini"      . conf) org-src-lang-modes)
  (push '("log"      . compilation) org-src-lang-modes)
  ;; [ replaced by ob-async
  ;; (push '("sh-async" . sh) org-src-lang-modes)
  ;; ;; new Babel languages
  ;; (defun org-babel-execute:sh-async (body params)
  ;;   "Execute a block of shell code BODY asynchronously.  PARAMS ignored."
  ;;   (let ((pid (process-id
  ;;               (async-start
  ;;                `(lambda ()
  ;;                   (org-babel-execute:shell ,body ,params))
  ;;                (lambda (result)
  ;;                  (message "sh-async result: %s" result))))))
  ;;     (message "Launched shell source code block asynchronously. PID: %s" pid)
  ;;     (format "PID: %s" pid)))
  ;; ]

  ;; ;;;;;;;;;;;; ;;
  ;; TODO options ;;
  ;; ;;;;;;;;;;;; ;;
  (defun org-abbrev-es-heading ()
    (replace-regexp-in-string
     " +\\'" ""
     (replace-regexp-in-string
      "  +" " "
      (replace-regexp-in-string
       "\\([^[:space:]]\\{3\\}\\)[^[:space:]][^[:space:]]+\\([^[:space:]]\\{2\\}\\)" "\\1…\\2"
       (let ((case-fold-search t))
         (replace-regexp-in-string
          (eval-when-compile
            (concat "\\( \\|\\`\\)\\("
                    (mapconcat 'identity
                               '("al" "un" "uno" "una" "unos" "unas"
                                 "del"
                                 ;; conjunciones
                                 "y" "e" "o" "u"
                                 ;; prepositions
                                 "el" "la" "lo" "las" "los"
                                 "a" "ante" "bajo" "cabe" "con"
                                 "contra" "de" "desde" "durante"
                                 "en" "entre" "hacia" "hasta"
                                 "mediante" "para" "por" "según"
                                 "sin" "so" "sobre" "tras")
                               "\\|")
                    "\\)\\( \\|\\'\\)")) " "
          (org-entry-get nil "ITEM") nil t)) t) t t) t t))
  (require 'org-clock)
  (setq org-duration-units
        (eval-when-compile
          (let ((value 60))
            `(("min" . 1)
              ("h" . ,value)
              ("d" . ,(setq value (* value 6))) ;; 6 h per day
              ("w" . ,(setq value (* value 5))) ;; 5 d per week
              ("m" . ,(setq value (* value 4))) ;; 4 w per month
              ("y" . ,(setq value (* value 10))))))
        org-effort-threshold 20
        org-enforce-todo-dependencies t
        ;; [ 'note Graba el tiempo y una nota cuando se realiza una tarea
        org-log-done 'time ; 'time - solo guarda el tiempo
        ;; ]
        ;;org-clock-in-switch-to-state "STARTED"
        org-clock-out-when-done t
        org-columns-default-format
        "%49ITEM(Heading) %8EFFORT(Effort){:} %8CLOCKSUM(Clocked) %4TODO(Stat)" ;; "%25ITEM %TODO %3PRIORITY %TAGS"
        org-clock-into-drawer "LOGCLOCK"
        org-log-into-drawer "LOGSTATE"
        org-todo-keywords
        '(;; Basic
          (sequence "TODO(t!)" "NEXT(n!)" "STAR(s!)" "|" "DONE(d!)")
          ;; Actions
          (sequence "UNDO(u!)" "VERI(v@/!)" "|" "ENOU(e@/!)" "DELE(l@/!)")
          ;; States
          (sequence "PLAN(p!)" "LINK(k@/!)" "WAIT(w@/!)" "|" "FINI(f!)")
          ;; Problems
          (sequence "FIXM(b@/!)" "REOP(r@/!)" "HOLD(h@/!)" "|" "CANC(c@/!)"))
        org-archive-location ".archived.org::* From %s"
        org-archive-file-header-format nil
        ;; PRIORITIES
        org-highest-priority ?A
        org-default-priority ?H
        org-lowest-priority ?O
        ;; Clocking
        org-clock-string-limit 45
        org-clock-in-resume t
        org-clock-persist t
        org-clock-clocked-in-display 'mode-line
        org-clock-heading-function 'org-abbrev-es-heading)

  (setcdr (assoc 'state org-log-note-headings) "State %-6s <- %-6S %t")

  ;; ;;;;;;;;;;;;;;; ;;
  ;; Convert options ;;
  ;; ;;;;;;;;;;;;;;; ;;
  (require 'ox)
  (eval-when-compile
    (require 'org-macs))
  (defun org-element-find-all (key)
    (let ((alist '())
          (pattern (concat "^[ \t]*#\\+\\(" key "\\):")))
      (org-with-wide-buffer
       (goto-char (point-min))
       (while (re-search-forward
               pattern nil t)
         (let ((element (org-element-at-point)))
           (when (eq (org-element-type element) 'keyword)
             (let ((val (org-element-property :value element)))
               (if (equal (org-element-property :key element)
                          key)
                   (push (read (format "%s" val)) alist))))))
       alist)))

  ;; ;;;;;;;;;;;;;;;;;;; ;;
  ;; Convert to Markdown ;;
  ;; ;;;;;;;;;;;;;;;;;;; ;;
  ;;(require 'ox-md)
  (require 'ox-gfm)  ; Include ox-md
  (defun org-gfm-publish-to-gfm (plist filename pub-dir)
    (org-publish-org-to 'gfm filename ".md" plist pub-dir))

  ;; ;;;;;;;;;;;;;;; ;;
  ;; Convert to Wiki ;;
  ;; ;;;;;;;;;;;;;;; ;;
  (require 'ox-mediawiki)
  ;; Change dispatcher bind key because of conflict with markdown
  (setcar (org-export-backend-menu 
           (-first
            (lambda (b)
              (string-equal "mw" (symbol-name (org-export-backend-name b))))
            org-export-registered-backends)) ?M)

  ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;
  ;; Convert to reStructuredText ;;
  ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;
  (require 'ox-rst)

  ;; ;;;;;;;;;;;;;;;;;;;;;; ;;
  ;; Convert to LibreOffice ;;
  ;; ;;;;;;;;;;;;;;;;;;;;;; ;;
  (require 'ox-odt nil t)

  (setq org-odt-fontify-srcblocks t
        org-odt-create-custom-styles-for-srcblocks t
        org-odt-table-styles
        (append org-odt-table-styles
                '(("TableWithBandingRows" "Custom"
                   ((use-banding-rows-styles . t)))
                  ("TableWithBandingColumns" "Custom"
                   ((use-banding-column-styles . t)))
                  ("TableWithHeaderRow" "Custom"
                   ((use-first-row-styles . t)))))
        ;; Convert formulas
        org-latex-to-mathml-convert-command
        "java -jar %j -unicode -force -df %o %I"
        org-latex-to-mathml-jar-file
        (expand-file-name "cache/java/mathtoweb.jar"
                          user-emacs-directory)
        ;; Convert to other formats
        org-odt-convert-processes
        `(("WINWORD"
           ,(concat "WINWORD /q \"%i\" /mFormatAll"))
          ("LibreOffice"
           "soffice --headless --convert-to %f%x --outdir %d %i")
          ("unoconv"
           "unoconv -f %f -o %d %i"))
        org-odt-convert-process (cond
                                 ((executable-find "WINWORD") "WINWORD")
                                 ((executable-find "soffice") "LibreOffice")
                                 ((executable-find "unoconv") "unoconv")
                                 (t nil))
        org-odt-preferred-output-format (and org-odt-convert-process "doc"))

  (defun org-odt-export-update-convert-processes ()
    (interactive)
    (setq org-odt-convert-processes
          `(("WINWORD"
             ,(concat "WINWORD /q \""
                      (concat (file-name-sans-extension buffer-file-name) ".odt")
                      "\" /m"
                      (or (car (org-element-find-all "MACRO"))
                          "FormatAll")))
            ("LibreOffice"
             "soffice --headless --convert-to %f%x --outdir %d %i")
            ("unoconv"
             "unoconv -f %f -o %d %i"))))

  (defun org-export-update (backend)
    (cond
     ((eq 'odt backend)
      (org-odt-export-update-convert-processes))))
  (add-hook 'org-export-before-processing-hook 'org-export-update)

  ;; ;;;;;;;;;;;;;;;;;;;;;;;;;; ;;
  ;; Convert pytex environments ;;
  ;; ;;;;;;;;;;;;;;;;;;;;;;;;;; ;;

  ;; Formatea el archivo antes del proceso de org-mode
  ;; para tener una salida adecuada.
  ;; (defun pytex-org-export-replacement (backend)
  ;;   "Límpia los códigos pytex para dejar sólo el latex."
  ;;   (org-map-entries
  ;;    (lambda ()
  ;;      (if (cl-find backend '(latex html)) (pytex-clean-environments)))))
  ;; (add-hook 'org-export-before-processing-hook 'pytex-org-export-replacement)

  ;; ;;;;;;;;;;;;;;;; ;;
  ;; Convert to latex ;;
  ;; ;;;;;;;;;;;;;;;; ;;

  ;; [ Formato latex por defecto
  ;; (org los coloca en orden inverso)
  ;; (add-to-list 'org-latex-packages-alist
  ;; '("" "color" nil))
  ;; (add-to-list 'org-latex-packages-alist
  ;; '("verbose,a4paper,headheight=5mm,footskip=7mm,left=19mm,right=16mm,top=37mm,bottom=23mm" "geometry" nil))
  ;; (add-to-list 'org-latex-packages-alist
  ;; '("" "multirow" nil))
  ;; (add-to-list 'org-latex-packages-alist
  ;; '("" "multicol" nil))
  ;; (add-to-list 'org-latex-packages-alist
  ;; '("AUTO" "babel" nil))
  (require 'ox-latex)
  (setq org-latex-listings 'minted ;; xor 'listings
        org-latex-listings-options
        '(("basicstyle" "\\small\\ttfamily")
          ("breaklines" "true")
          ("captionpos" "b")
          ("extendedchars" "true")
          ("tabsize" "4")
          ("columns" "fixed")
          ("keepspaces" "true")
          ("showstringspaces" "false")
          ("breaklines" "true")
          ("frame" "tb")
          ("framerule" "0.5pt")
          ("framexleftmargin" "0.5em")
          ("framexrightmargin" "0.5em")
          ("xleftmargin" "0.5em")
          ("xrightmargin" "0.5em")
          ("mathescape" "false")
          ("escapeinside" "{\\%*}{*)}")
          ("showspaces" "false")
          ("showstringspaces" "false")
          ("numbers" "none")
          ("numberstyle" "\\tiny\\ttfamily")
          ("commentstyle" "\\color{red}")
          ("keywordstyle" "\\color{blue}\\bfseries")
          ("stringstyle" "\\color{green}"))
        org-latex-minted-options
        '(("bgcolor" "blockbg"))
        org-latex-pdf-process
        '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f")
        org-latex-packages-alist
        '(
          ;; ("verbose,a4paper,headheight=5mm,footskip=7mm,left=19mm,right=16mm,top=37mm,bottom=23mm" "geometry" nil)  ;; problems with beamer class
          ("AUTO" "babel" nil)
          ("" "multirow" nil)
          ("" "multicol" nil)
          ;; ("" "titlesec" nil)  ;; problems with beamer class
          ;; ("" "listings")
          ;; xor
          ("" "minted")
          ("" "color" nil)
          "
\\makeatletter
\\definecolor{blockbg}{rgb}{0.95,0.95,0.95}
\\@ifpackageloaded{titlesec}{
\\definecolor{partcolor}{rgb}{0,0,0.1}
\\definecolor{sectcolor}{rgb}{0,0,0.3}
\\definecolor{ssctcolor}{rgb}{0,0,0.5}
\\definecolor{ssstcolor}{rgb}{0,0,0.7}
%\\renewcommand{\\headrulewidth}{0pt}
\\titleformat{\\part}[hang]{\\huge\\sc{\\color{blue}\\titlerule[1pt]\\vspace{2pt}\\titlerule[1pt]}}{\\llap{\\bf\\color{blue}\\thepart.}}{10pt}{\\color{partcolor}}[{\\color{blue}\\titlerule[1pt]\\vspace{2pt}\\titlerule[1pt]}]
\\titleformat{\\section}[hang]{\\Large\\sc}{\\llap{\\bf\\color{blue}\\thesection.}}{10pt}{\\color{sectcolor}}[{\\color{blue}\\nobreak\\titlerule[1pt]}]
\\titleformat{\\subsection}[hang]{\\large\\bf}{\\llap{\\color{blue}\\thesubsection.}}{7pt}{\\color{ssctcolor}\\underline}
\\titleformat{\\subsubsection}[hang]{\\normalsize\\it}{\\llap{\\bf\\color{blue}\\thesubsubsection.}}{4pt}{\\color{ssstcolor}}
}{\\relax}
\\makeatother
")
        ;; org-latex-image-default-width nil
        org-beamer-outline-frame-options "allowframebreaks=0.9"
        org-beamer-frame-default-options "allowframebreaks=0.9"
        )
  ;; ]

  (when (and (eq org-latex-listings 'minted)
             (not (executable-find "pygmentize")))
    (message-color #("WARN pygmentize not found, add to path or run 'apt install python-pygments'."
                     0 4 (face warning))))

  ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;
  ;; Convert to beamer presentation ;;
  ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;
  (require 'ox-beamer)

  ;; ;;;;;;;;;;;;;;; ;;
  ;; Convert to html ;;
  ;; ;;;;;;;;;;;;;;; ;;

  ;; Formato html por defecto
  (require 'ox-html)
  (setq  org-html-head
         "<style type=\"text/css\">
 <!--/*--><![CDATA[/*><!--*/
body{
	font-family: Titillium, Arial, sans-serif;
	background: #fff repeat top left;
	font-weight: 400;
	font-size: 14px;
	color:#505050;
	-webkit-font-smoothing: antialiased;
	-moz-font-smoothing: antialiased;
	font-smoothing: antialiased;
        margin: 10px;
        padding: 60px;
}
a{
	color: #0066FF;
	text-decoration: underline;
}
a:hover{
	color: #66A3FF;
	text-decoration: none;
}
math, math[mode=\"inline\"] {
  display: inline;
  font-family: sans-serif;
  font-style: normal;
font-size: 17px;
}
math[mode=\"display\"] {
  display: block;
  text-align: center;
  font-family: sans-serif;
  font-style: normal;
  font-size: 17px;
}

h1 {
	font-size: 40px;
	line-height: 40px;
	margin: 10px;
	position: relative;
	font-weight: 300;
	color: #0000A0;
	text-shadow: 1px 1px 1px rgba(255,255,255,0.7);
}
h2 {
	font-size: 27px;
	line-height: 27px;
	margin: 16px;
	position: relative;
	font-weight: 300;
	color: #0041C2;
	text-shadow: 1px 1px 1px rgba(255,255,255,0.7);
        text-indent: -20px;
        border-bottom: 2px solid blue;
}
h3 {
	font-size: 18px;
	line-height: 18px;
	margin: 22px;
	position: relative;
	font-weight: 300;
	color: #1569C7;
	text-shadow: 1px 1px 1px rgba(255,255,255,0.7);
        text-indent: -40px;
        text-decoration: underline;
        text-decoration-color: blue;
}
h4 {
	font-size: 17px;
	line-height: 17px;
	margin: 28px;
	position: relative;
	font-weight: 300;
	color: #659EC7;
	text-shadow: 1px 1px 1px rgba(255,255,255,0.7);
        text-indent: -60px;
        text-decoration: underline;
        text-decoration-color: blue;
}

p {
	font-size: 17px;
	line-height: 22px;
	text-align: justify;
	text-indent: 14px;
	margin: 3px 40px 5px 0;
	padding-left: 15px;
	/*font-family: Cambria, Georgia, serif;*/
}

p img {
	vertical-align: middle;
}
li img {
	vertical-align: middle;
}
img {
    max-width: 820px;
}

/* org-mode */

ol {
    list-style-type: decimal;
}
ol > li > ol {
    list-style-type: lower-latin;
}
ol > li > ol > li > ol {
    list-style-type: lower-roman;
}
ol p {
    border-left: none;
}

/*
ol p, ul p, div.figure p{
    border-left: none;
}*/

.todo   { font-family: monospace; color: red; }
.done   { color: green; }
.tag    { background-color: #eee; font-family: monospace;
          padding: 2px; font-size: 80%; font-weight: normal; }
.timestamp { color: #bebebe; }
.timestamp-kwd { color: #5f9ea0; }
.right  { margin-left: auto; margin-right: 0px;  text-align: right; }
.left   { margin-left: 0px;  margin-right: auto; text-align: left; }
.center { margin-left: auto; margin-right: auto; text-align: center; }
.underline { text-decoration: underline; }
#postamble p, #preamble p { font-size: 90%; margin: .2em; }

p.verse { margin-left: 3%; }
div.verbatim {
  border: 1px solid #ccc;
  box-shadow: 3px 3px 3px #eee;
  padding: 8pt;
  overflow: auto;
  margin: 1.2em;
}

samp {
  border: 1px solid #ccc;
  font-size: 14px;
  font-family: \"Lucida Console\", Monaco, monospace;
  background-color: #E8E8E8;
}
code {
  border: 1px solid #ccc;
  font-size: 14px;
  font-family: \"Lucida Console\", Monaco, monospace;
  background-color: #FFFFFF;
}
.org-src-container {
  overflow: auto;
  position: relative;
}
pre {
  border: 1px solid #ccc;
  box-shadow: 3px 3px 3px #eee;
  padding: 8pt;
  font-family: monospace;
  overflow: visible;
  margin: 1.2em;
}
pre.src {
  display: table;
  margin: 1em 0 0 0;
  position: initial;
  padding-top: 1em;
  color: #C0C0C0;
  Background-color: #202020;
}
pre.src:before {
  display: none;
  position: absolute;
  background-color: white;
  top: 0px;
  right: 10px;
  padding: 3px;
  border: 1px solid black;
}
pre.src:hover:before { display: inline;}
pre.src-sh:before    { content: 'sh'; }
pre.src-sh-async:before    { content: 'sh'; }
pre.src-bash:before  { content: 'bash'; }
pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
pre.src-c:before   { content: 'C'; }
pre.src-cpp:before   { content: 'C++'; }
pre.src-R:before     { content: 'R'; }
pre.src-perl:before  { content: 'Perl'; }
pre.src-java:before  { content: 'Java'; }
pre.src-sql:before   { content: 'SQL'; }

table { border-collapse:collapse; }
caption.t-above { caption-side: top; }
caption.t-bottom { caption-side: bottom; }
td, th { vertical-align:top;  }
th.right  { text-align: center;  }
th.left   { text-align: center;   }
th.center { text-align: center; }
td.right  { text-align: right;  }
td.left   { text-align: left;   }
td.center { text-align: center; }
dt { font-weight: bold; }
.footpara:nth-child(2) { display: inline; }
.footpara { display: block; }
.footdef  { margin-bottom: 1em; }
.figure { padding: 1em; }
.figure p { text-align: center; }
.inlinetask {
  padding: 10px;
  border: 2px solid gray;
  margin: 10px;
  background: #ffffcc;
}
#org-div-home-and-up
 { text-align: right; font-size: 70%; white-space: nowrap; }
textarea { overflow-x: auto; }
.linenr { font-size: smaller }
.code-highlighted { background-color: #ffff00; }
.org-info-js_info-navigation { border-style: none; }
#org-info-js_console-label
  { font-size: 10px; font-weight: bold; white-space: nowrap; }
.org-info-js_search-highlight
  { background-color: #ffff00; color: #000000; font-weight: bold; }
/* modificado org-mode */
#text-table-of-contents ul
  { list-style-type: none; }
span.section-number-2 {
  font-size: 30px;
  color: #003399;
}
span.section-number-3 {
  font-size: 20px;
  color: #003399;
}
span.section-number-4 {
  font-size: 18px;
  color: #003399;
}

blockquote {
  border: 1px solid #ccc;
  box-shadow: 3px 3px 3px #eee;
  padding: 8pt;
  overflow: auto;
  margin: 1.2em;
}
  /*]]>*/-->
</style>"
         ;; [ No se debería modificar
         ;; org-html-style-default
         ;; "<link rel=\"stylesheet\" type=\"text/css\" href=\"css/style.css\" />"
         org-html-mathjax-options
         '((path  "js/MathJax.js")
           (scale "100")
           (align "center")
           (indent "2em")
           (mathml nil)))

  ;; Definen =verbatim= y ~code~ en html
  (eval-after-load 'ox-html
    '(progn
       (push '(verbatim . "<samp>%s</samp>") org-html-text-markup-alist)
       (push '(code . "<code>%s</code>") org-html-text-markup-alist)))

  ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;
  ;; Convert to html with Twitter Bootstrap ;;
  ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;
  (require 'ox-twbs)

  ;; ;;;;;;; ;;
  ;; Publish ;;
  ;; ;;;;;;; ;;
  (require 'ox-publish)

  ;; ;;;;; ;;
  ;; Links ;;
  ;; ;;;;; ;;
  (setq org-html-validation-link nil
        org-return-follows-link t)

  (delete '("\\.pdf\\'" . default) org-file-apps)

  (add-to-list 'org-file-apps '("\\.pdf\\'" . "evince \"%s\""))
  (add-to-list 'org-file-apps '("\\.pdf::\\([0-9]+\\)\\'" . "evince \"%s\" -p %1"))
  (add-to-list 'org-file-apps '("\\.png\\'" . "eog \"%s\""))

  ;; ;;;;;; ;;
  ;; Agenda ;;
  ;; ;;;;;; ;;

  ;; (require 'calfw-org)
  ;; (defun cfw:open-org-calendar-command (&args)
  ;;   (interactive)
  ;; ;;  (let ((org-agenda-skip-function 'org-agenda-skip-work))
  ;;   (cfw:open-org-calendar))
  ;; ;;)
  ;; (cl-loop for folder in
  ;;          `("~/var/Dropbox/Orgzly"
  ;;            ,(concat "~/Prog/org/" (getenv "JOB_FOLDER"))
  ;;            "~/Prog/org")
  ;;          when (file-exists-p folder)
  ;;          return folder)
  ;; [ OBSOLETE
  ;;(require 'org-expiry)
  ;;(org-expiry-insinuate)
  ;; ]

  (require 'org-agenda-property)
  (setq org-directory "~/Prog/org/"
        org-agenda-files (let ((files
                                (cl-remove-if-not
                                 'file-exists-p
                                 `("~/var/Dropbox/Orgzly/"
                                   ,(expand-file-name "agenda" org-directory)))))
                           (if (boundp 'personal-notes-directory)
                               (cons personal-notes-directory
                                     files)
                             files))
        org-default-notes-file (expand-file-name
                                ".notes.org"
                                org-directory)
        org-annotate-file-storage-file (expand-file-name
                                        ".org-annotate-file.org"
                                        org-directory)
        org-annotate-file-always-open nil
        org-annotate-file-add-search nil
        ;; <property>
        org-agenda-property-list '("REQUIRED")
        ;; <Agenda includes>
        org-agenda-skip-deadline-prewarning-if-scheduled t
        org-agenda-skip-scheduled-if-deadline-is-shown t
        org-agenda-include-deadlines t
        ;; org-agenda-include-diary t
        ;; org-agenda-include-inactive-timestamps t
        ;; <Agenda format>
        org-agenda-tags-column -80
        org-agenda-time-grid
        '((daily today require-timed remove-match)
          (800 1000 1200 1400 1600 1800 2000)
          "......" "----------------")
        org-agenda-prefix-format
        '((agenda . " %i %-4.4 c%?-12t% s")  ;; (agenda . " %i %-12:c%?-12t% s")
          (timeline . "  % s")
          (todo . " %i %-4.4 c%?-12t% s")    ;; (todo . " %i %-12:c")
          (tags . " %i %-4.4 c")             ;; (tags . " %i %-12:c")
          (search . " %i %-4.4 c"))          ;; (search . " %i %-12:c")
        org-agenda-scheduled-leaders '("Sche" "S-%3dd")
        org-agenda-deadline-leaders  '("Dead" "D+%3dd" "D-%3dd")
        org-agenda-sorting-strategy
        '((agenda habit-down time-up user-defined-up category-keep)
          (todo priority-down category-keep)
          (tags priority-down category-keep)
          (search category-keep))
        org-agenda-cmp-user-defined 'org-agenda-cmp-user-defined-function
        org-agenda-deadline-faces
        '((1.01 . '(:foreground "magenta" :bold t))
          (1.0 . org-warning)
          (0.5 . org-upcoming-deadline)
          (0.0 . default))
        org-deadline-warning-days 15
        org-agenda-start-on-weekday 1
        ;; <Habits>
        org-habit-show-habits-only-for-today t
        org-habit-show-all-today t
        org-habit-preceding-days 14
        org-habit-graph-column 44
        ;; <Agenda commands>
        org-agenda-custom-commands
        '(("h" "[h]abits" 
           ((agenda ""))
           ((org-agenda-show-log t)
            (org-agenda-ndays 7)
            (org-agenda-log-mode-items '(state))
            (org-agenda-skip-function
             '(org-agenda-skip-entry-if
               'notregexp
               ":STYLE: *habit"))))
          ("r" "[r]epeat timestamps"
           ((alltodo ""
                     ((org-agenda-skip-function
                       '(and (not (org-get-repeat))
                             (org-entry-end-position)))))))
          ("c" "[c]alendar" cfw:open-org-calendar-command)
          ("n" "[n]ot closed timestamps"
           ((alltodo ""
                     ((org-agenda-skip-function
                       '(org-agenda-skip-entry-if
                         'regexp
                         "CLOSED: \\[[0-9][0-9][0-9][0-9]-[0-1][0-9]-[0-3][0-9]"))))))
          ("u" "[u]nscheduled tasks"
           ((alltodo ""
                     ((org-agenda-skip-function
                       '(org-agenda-skip-entry-if
                         'scheduled 'deadline
                         ;;'todo '("DONE" "CANCELLED" "FINISHED" "ENOUGH")
                         ))))))
          ("A" "[A]ll scheduled or not"
           ((agenda "")
            (alltodo ""
                     ((org-agenda-skip-function
                       '(org-agenda-skip-entry-if
                         'scheduled 'deadline
                         ;;'todo '("DONE" "CANCELLED" "FINISHED" "ENOUGH")
                         ))))))
          ;;("u" "[u]nscheduled tasks" tags "-SCHEDULED={.+}/!+TODO|+NEXT|+STARTED|+WAITING|+HOLD")
          ))
  (make-directory org-directory t)

  ;; ;;;;;;;;; ;;
  ;; Functions ;;
  ;; ;;;;;;;;; ;;
  (defun org-annotate-file-search (arg)
    (interactive "P")
    (if arg
        (let ((org-annotate-file-add-search t))
          (org-annotate-file))
      (org-annotate-file)))

  (with-eval-after-load 'ob-tangle
    (defun org-byte-compile-tangle-file ()
      (when (derived-mode-p 'emacs-lisp-mode)
        (let ((file-name (buffer-file-name)))
          (when (and (stringp file-name)
                     (file-exists-p file-name))
            (byte-recompile-file file-name nil 0)))))
    (add-hook 'org-babel-post-tangle-hook 'org-byte-compile-tangle-file))

  (defun org-entry-is-todo-get-subtree (pos property)
    (save-excursion
      (goto-char pos)
      (save-restriction
        (org-narrow-to-subtree)
        (goto-char (point-max))
        (save-match-data
          (cl-loop while (re-search-backward org-heading-regexp nil t)
                   when (org-entry-is-todo-p)
                   collect (org-entry-get (point) property))))))

  (defun org-entry-to-key (&optional pos)
    (let ((entry-pos (or pos (point)))
          (order '(;; Todo
                   ("FIXM" . 49) ;; 48 ?0
                   ("REOP" . 50)
                   ("VERI" . 51)
                   ("PLAN" . 52)
                   ("STAR" . 53)
                   ("NEXT" . 54)
                   ("TODO" . 55)
                   ("UNDO" . 56)
                   ;; Hold
                   ("LINK" . 64) ;; ?A
                   ("WAIT" . 65)
                   ("HOLD" . 66)
                   ;; Done
                   ("ENOU" . 71) ;; 97 ?a
                   ("DELE" . 72)
                   ("CANC" . 73)
                   ("FINI" . 74)
                   ("DONE" . 75)
                   )))
      (let ((todo (cdr (assoc (org-entry-get entry-pos "TODO") order))))
        (cond
         ((not todo)
          " ")
         ((< todo 65)
          ;;
          ;; todo
          ;;
          (let ((effort-list (cl-loop for minutes in (org-entry-is-todo-get-subtree entry-pos "EFFORT")
                                      when minutes
                                      collect (org-duration-to-minutes minutes)))
                (priority (org-entry-get entry-pos "PRIORITY"))
                (tags (mapconcat 'identity
                                 (sort (split-string
                                        (or (org-entry-get entry-pos "TAGS") "") ":" t)
                                       'string<) " ")))
            (concat
             ;; type of todo
             "0"
             ;; effort condition
             (if (and effort-list (< (apply 'min effort-list) org-effort-threshold))
                 " "
               "~")
             priority
             (byte-to-string todo)
             tags)))
         ((< todo 71)
          ;;
          ;; blocked
          ;;
          (let ((priority (org-entry-get entry-pos "PRIORITY"))
                (tags (mapconcat 'identity
                                 (sort (split-string
                                        (or (org-entry-get entry-pos "TAGS") "") ":" t)
                                       'string<) " ")))
            (concat
             "1"
             (byte-to-string todo)
             priority
             tags)))
         (t
          ;;
          ;; done
          ;;
          (let ((closed (let ((closed-time (org-entry-get entry-pos "CLOSED")))
                          (if closed-time
                              (number-to-string
                               (- most-positive-fixnum
                                  (round (org-time-string-to-seconds closed-time))))
                            " "))))
            (concat
             "2"
             closed)))))))

  (defun org-agenda-cmp-user-defined-function (a b)
    (let ((a-pos (or (get-text-property 1 'org-marker a)
                     (get-text-property 1 'org-hd-marker a)))
          (b-pos (or (get-text-property 1 'org-marker b)
                     (get-text-property 1 'org-hd-marker b))))
      (if (and a-pos b-pos)
          (let ((a-key (with-current-buffer (marker-buffer a-pos)
                         (org-entry-to-key a-pos)))
                (b-key (with-current-buffer (marker-buffer b-pos)
                         (org-entry-to-key b-pos))))
            (if (string< a-key b-key)
                -1
              1))
        ;; (message "A pos: %s heading: %s entry: %s" a-pos (text-property-any 0 (length a) 'org-heading t a) a)
        ;; (message "B pos: %s heading: %s entry: %s" b-pos (text-property-any 0 (length b) 'org-heading t b) b)
        (if (string< a b)
            -1
          1))))

  (defun org-sort-entries-user-defined ()
    (interactive)
    (org-sort-entries nil ?f 'org-entry-to-key 'string<))

;; <nativecomp incompatible>
;;   (defun org-af (&optional prefix suffix)
;;     "Return filename counting blocks using this function.
;; Filename returned has the format:

;; PREFIX block-number SUFFIX

;; Example: doc-000012.png

;; PREFIX - default buffer name without extension
;; SUFFIX - default .png"
;;     (let ((number 0)
;;           (pre (or prefix (file-name-sans-extension (buffer-name))))
;;           (suf (or suffix ".png")))
;;       (save-excursion
;;         (forward-line 1)
;;         (while (re-search-forward (format "#\\+BEGIN_SRC.*%s" (compile-time-function-name)) nil t)
;;           (cl-incf number)))
;;       (concat pre (format "-%06d" number) suf)))

  (defun org-archive-done-tasks (&optional scope)
    (interactive "P")
    (cond
     ((equal scope '(16))
      (setq scope 'agenda))
     ((equal scope '(4))
      (setq scope 'tree))
     ((equal scope nil)
      (setq scope 'file)))
    (org-map-entries
     (lambda ()
       (org-archive-subtree)
       (setq org-map-continue-from (outline-previous-heading)))
     "/DONE|ENOU|FINI|CANC" scope))

  (defun org-read-entry-property-name ()
    "Read a property name from the current entry."
    (let ((completion-ignore-case t)
          (default-prop (or (and (org-at-property-p)
                                 (match-string-no-properties 2))
                            org-last-set-property)))
      (org-completing-read
       (format "Property [%s]: " (if default-prop default-prop ""))
       (org-entry-properties nil nil)
       nil nil nil nil default-prop)))

  (defun org-region-to-property (&optional property)
    "Copies the region as value to an Org-mode PROPERTY."
    (interactive)
    ;; if no region is defined, do nothing
    (if (use-region-p)
        ;; if a region string is found, ask for a property and set property to
        ;; the string in the region
        (let ((val (replace-regexp-in-string
                    "\\`[ \t\n]*" ""
                    (replace-regexp-in-string "[ \t\n]*\\'" ""
                                              (substring (buffer-string)
                                                         (- (region-beginning) 1)
                                                         (region-end)) t t) t t))
              ;; if none was stated by user, read property from user
              (prop (or property
                        (org-read-entry-property-name))))
          ;; set property
          (org-set-property prop val))))

  (defun org-table-sort-column ()
    "Sort table column at point."
    (interactive)
    (let* ((thisline (org-current-line))
           (thiscol (org-table-current-column))
           (otc org-table-overlay-coordinates)
           beg end bcol ecol tend tbeg column lns pos)
      (when (equal thiscol 0)
        (if (called-interactively-p 'any)
            (setq thiscol
                  (string-to-number
                   (read-string "Use column N for sorting: ")))
          (setq thiscol 1))
        (org-table-goto-column thiscol))
      (org-table-check-inside-data-field)
      (if (org-region-active-p)
          (progn
            (setq beg (region-beginning) end (region-end))
            (goto-char beg)
            (setq column (org-table-current-column)
                  beg (point-at-bol))
            (goto-char end)
            (setq end (point-at-bol 2)))
        (setq column (org-table-current-column)
              pos (point)
              tbeg (org-table-begin)
              tend (org-table-end))
        (if (re-search-backward org-table-hline-regexp tbeg t)
            (setq beg (point-at-bol 2))
          (goto-char tbeg)
          (setq beg (point-at-bol 1)))
        (goto-char pos)
        (if (re-search-forward org-table-hline-regexp tend t)
            (setq end (point-at-bol 1))
          (goto-char tend)
          (setq end (point-at-bol))))
      (setq beg (move-marker (make-marker) beg)
            end (move-marker (make-marker) end))
      (untabify beg end)
      (goto-char beg)
      (org-table-goto-column column)
      (skip-chars-backward "^|")
      (setq bcol (point))
      (goto-char end)
      (forward-line -1)
      (org-table-goto-column column)
      (skip-chars-forward "^|")
      (setq ecol (point))
      (org-table-copy-region bcol ecol nil)
      (setq lns (mapcar (lambda (x) (cons 
                                     (org-sort-remove-invisible 
                                      (substring-no-properties x) )
                                     x))
                        ( mapcar 'car org-table-clip)))
      (setq lns (org-do-sort lns "Column" ))
      (setq org-table-clip (mapcar 'list (mapcar 'cdr lns)))
      (goto-char beg)
      (org-table-goto-column column)
      (org-table-paste-rectangle)
      (org-goto-line thisline)
      (org-table-goto-column thiscol)
      (when otc (org-table-toggle-coordinate-overlays))
      (message "%d element sorted in column %d" (length lns) column)))

  (defun org-auto-redisplay-inline-images ()
    (when org-inline-image-overlays
      (org-redisplay-inline-images)))
  (add-hook 'org-babel-after-execute-hook 'org-auto-redisplay-inline-images)

  (defun org-execute-file-search-in-prog (s)
    (when (derived-mode-p 'prog-mode)
      (let ((searches (split-string s "\\^\\^")))
        (when (< 1 (length searches))
          (goto-char (point-min))
          (cl-every (lambda (search)
                      (and (re-search-forward (regexp-quote search)
                                              nil t)
                           (goto-char (match-end 0))))
                    searches)))))
  (add-hook 'org-execute-file-search-functions 'org-execute-file-search-in-prog)

  (defun org-link-abbrev-path (path)
    (or (cl-some (lambda (abbrev-root)
                   (let* ((root (cdr abbrev-root))
                          (root-len (length root)))
                     (when (and
                            (<= root-len (length path))
                            (string-equal root
                                          (substring path 0 root-len)))
                       (replace-regexp-in-string
                        (concat "^" (regexp-quote root))
                        (concat (car abbrev-root) ":")
                        path t t))))
                 org-link-abbrev-alist)
        path))

  (defun copy-buffer-file-name-org-link ()
    (interactive)
    (let* ((path-name (abbreviate-file-name buffer-file-name))
           (name (file-name-nondirectory path-name)))
      (kill-new (concat "[[" (org-link-abbrev-path path-name) "][" name "]]"))))
  (autoload 'copy-buffer-file-name-org-link "org" nil t)

  (defun copy-buffer-file-name-line-org-link ()
    (interactive)
    (let* ((path-name (abbreviate-file-name buffer-file-name))
           (name (file-name-nondirectory path-name)))
      (kill-new (concat "[[" (org-link-abbrev-path path-name) "::"
                        (number-to-string (line-number-at-pos))
                        "][" name "]]"))))
  (autoload 'copy-buffer-file-name-line-org-link "org" nil t)

  (defun copy-buffer-file-name-search-org-link ()
    (interactive)
    (let* ((path-name (abbreviate-file-name buffer-file-name))
           (name (file-name-nondirectory path-name)))
      (kill-new (concat "[[" (org-link-abbrev-path path-name) "::"
                        (org-link-escape
                         (string-trim-right
                          (save-excursion
                            (back-to-indentation)
                            (buffer-substring-no-properties
                             (point) (progn
                                       (end-of-line)
                                       (point))))))
                        "][" name "]]"))))
  (autoload 'copy-buffer-file-name-search-org-link "org" nil t)

  (defun org-todo-prompt-date (&optional arg)
    (interactive "P")
    (cl-letf* ((org-read-date-prefer-future nil)
               (my-current-time (org-read-date t t nil "when:" nil nil nil))
               ((symbol-function #'org-current-effective-time)
                #'(lambda () my-current-time)))
      (org-todo arg)))

  ;; (defun org-block-and-result-hide-all ()
  ;;   (interactive)
  ;;   (call-interactively #'org-hide-block-all)
  ;;   (call-interactively #'org-babel-result-hide-all))

  ;; (defun org-block-and-result-show-all ()
  ;;   (interactive)
  ;;   (call-interactively #'org-show-block-all)
  ;;   (call-interactively #'org-babel-show-result-all))
  (eval-when-compile
    (require 'org-macs))
  (defun org-entry-put-multiline-property (pom property value)
    "Set PROPERTY to VALUE for entry at point-or-marker POM.
Allow multiline properties.

If the value is nil, it is converted to the empty string.  If it
is not a string, an error is raised.  Also raise an error on
invalid property names.

PROPERTY can be any regular property (see
`org-special-properties').  It can also be \"TODO\",
\"PRIORITY\", \"SCHEDULED\" and \"DEADLINE\".

For the last two properties, VALUE may have any of the special
values \"earlier\" and \"later\".  The function then increases or
decreases scheduled or deadline date by one day."
    (cond ((null value) (setq value ""))
          ((not (stringp value)) (error "Properties values should be strings"))
          ((not (org--valid-property-p property))
           (user-error "Invalid property name: \"%s\"" property)))
    (org-with-point-at pom
      (if (or (not (featurep 'org-inlinetask)) (org-inlinetask-in-task-p))
          (org-back-to-heading t)
        (org-with-limited-levels (org-back-to-heading t)))
      (let ((beg (point)))
        (cond
         ((equal property "TODO")
          (cond ((not (org-string-nw-p value)) (setq value 'none))
                ((not (member value org-todo-keywords-1))
                 (user-error "\"%s\" is not a valid TODO state" value)))
          (org-todo value)
          (org-align-tags))
         ((equal property "PRIORITY")
          (org-priority (if (org-string-nw-p value) (string-to-char value) ?\s))
          (org-align-tags))
         ((equal property "SCHEDULED")
          (forward-line)
          (if (and (looking-at-p org-planning-line-re)
                   (re-search-forward
                    org-scheduled-time-regexp (line-end-position) t))
              (cond ((string= value "earlier") (org-timestamp-change -1 'day))
                    ((string= value "later") (org-timestamp-change 1 'day))
                    ((string= value "") (org-schedule '(4)))
                    (t (org-schedule nil value)))
            (if (member value '("earlier" "later" ""))
                (call-interactively #'org-schedule)
              (org-schedule nil value))))
         ((equal property "DEADLINE")
          (forward-line)
          (if (and (looking-at-p org-planning-line-re)
                   (re-search-forward
                    org-deadline-time-regexp (line-end-position) t))
              (cond ((string= value "earlier") (org-timestamp-change -1 'day))
                    ((string= value "later") (org-timestamp-change 1 'day))
                    ((string= value "") (org-deadline '(4)))
                    (t (org-deadline nil value)))
            (if (member value '("earlier" "later" ""))
                (call-interactively #'org-deadline)
              (org-deadline nil value))))
         ((member property org-special-properties)
          (error "The %s property cannot be set with `org-entry-put'" property))
         (t
          (let* ((range (org-get-property-block beg 'force))
                 (end (cdr range))
                 (case-fold-search t))
            (goto-char (car range))
            (if (re-search-forward (org-re-property property nil t) end t)
                (let ((property-plus (concat property "+")))
                  (delete-region (match-beginning 0) (match-end 0))
                  (goto-char (match-beginning 0))
                  (while (re-search-forward (org-re-property property-plus nil t) end t)
                    (delete-region (match-beginning 0) (1+ (match-end 0)))
                    (goto-char (1- (match-beginning 0)))))
              (goto-char end)
              (insert "\n")
              (backward-char))
            (let ((lines (split-string value "\n")))
              (insert ":" property ": " (pop lines))
              (org-indent-line)
              (end-of-line)
              (dolist (line lines)
                (insert "\n:" property "+: " line)
                (org-indent-line)
                (end-of-line)))))))
      (run-hook-with-args 'org-property-changed-functions property value)))

  (defun org-set-multiline-property (property value)
    "In the current entry, set PROPERTY to VALUE.

When called interactively, this will prompt for a property name, offering
completion on existing and default properties.  And then it will prompt
for a value, offering completion either on allowed values (via an inherited
xxx_ALL property) or on existing values in other instances of this property
in the current file.

Throw an error when trying to set a property with an invalid name."
    (interactive (list nil nil))
    (let ((property (or property (org-read-property-name))))
      ;; `org-entry-put' also makes the following check, but this one
      ;; avoids polluting `org-last-set-property' and
      ;; `org-last-set-property-value' needlessly.
      (unless (org--valid-property-p property)
        (user-error "Invalid property name: \"%s\"" property))
      (let ((value (or value (org-read-property-value property)))
            (fn (cdr (assoc-string property org-properties-postprocess-alist t))))
        (setq org-last-set-property property)
        (setq org-last-set-property-value (concat property ": " value))
        ;; Possibly postprocess the inserted value:
        (when fn (setq value (funcall fn value)))
        (unless (equal (org-entry-get nil property) value)
          (org-entry-put-multiline-property nil property value)))))

  (defun org-shift-advice (orig-fun arg)
    (condition-case-unless-debug nil
        (funcall orig-fun arg)
      (error
       (cl-some (lambda (keymap)
                  (unless (eq keymap org-mode-map)
                    (let ((binding (lookup-key keymap (vector last-command-event))))
                      (if (commandp binding)
                          (call-interactively binding)))))
                (current-active-maps t)))))
  (advice-add 'org-shiftup :around 'org-shift-advice)
  (advice-add 'org-shiftdown :around 'org-shift-advice)

  ;; ;;;;;;;;;;;;; ;;
  ;; Org templates ;;
  ;; ;;;;;;;;;;;;; ;;
  ;; (require 'org-tempo)
  ;; ;; [ Thanks to: https://gist.github.com/alphapapa/84ec3396442915ca277b
  ;; (require 's)
  ;; (defun org-read-structure-template ()
  ;;   "Read org-mode structure template with completion.  Returns template string."
  ;;   (let* ((templates (map 'list 'cdr org-structure-template-alist))
  ;;          (template (completing-read "Template: " templates nil t)))
  ;;     (car (rassoc template org-structure-template-alist))))

  ;; (defun org-babel-insert-structure-template-or-enclose-region ()
  ;;   "Insert structure block template.  When region is active, enclose region in block."
  ;;   (interactive)
  ;;   (let* ((template (org-read-structure-template))
  ;;          (text ""))
  ;;     (if (use-region-p)
  ;;         (progn
  ;;           (setq text (buffer-substring-no-properties (region-beginning) (region-end)))
  ;;           (delete-region (region-beginning) (region-end))
  ;;           (insert (concat "<" template))
  ;;           (org-tempo-complete-tag)
  ;;           (when (char-equal ?  (char-before (point)))
  ;;             (forward-line)
  ;;             (end-of-line))
  ;;           (insert text))
  ;;       (insert (concat "<" template))
  ;;       (org-tempo-complete-tag))))
  ;; ;; ]
  ;; ;;;; ;;
  ;; Keys ;;
  ;; ;;;; ;;
  (add-hook 'org-mode-hook (lambda()
                             (set
                              (make-local-variable 'semantic-mode) nil)))

  (define-key org-mode-map "«" #'insert-pair)
  (define-key org-mode-map (kbd "M-,") #'org-priority)
  (define-key org-mode-map (kbd "C-c v e") #'org-show-entry)
  (define-key org-mode-map (kbd "C-c TAB") #'org-show-subtree)
  (define-key org-mode-map (kbd "C-c <backtab>") #'org-show-all)
  (define-key org-mode-map (kbd "C-c v t") #'org-show-todo-tree)
  ;; (define-key org-mode-map (kbd "C-c v s") #'org-block-and-result-show-all) 
  ;; (define-key org-mode-map (kbd "C-c v h") #'org-block-and-result-hide-all) 
  (define-key org-mode-map (kbd "C-c M-s") #'org-sort-entries-user-defined)
  (define-key org-mode-map (kbd "C-c C") #'org-capture)
  (define-key org-mode-map (kbd "C-c a") #'org-agenda)
  (define-key org-mode-map (kbd "C-c C-l") #'org-store-link)
  (define-key org-mode-map (kbd "C-c L") #'org-insert-link-global)
  (define-key org-mode-map (kbd "C-c O") #'org-open-at-point-global)
  (define-key org-mode-map (kbd "C-c p") #'org-publish)
  (define-key org-mode-map (kbd "C-c C-v <") #'org-babel-insert-structure-template-or-enclose-region)
  (define-key org-mode-map (kbd "C-c C-v k") #'org-babel-remove-result)
  (define-key org-mode-map (kbd "C-c C-v C-k") #'org-babel-remove-result)
  (define-key org-mode-map (kbd "C-c C-x D") #'org-archive-done-tasks)
  (define-key org-mode-map (kbd "M-s 7 k") #'org-toggle-link-display)
  (global-set-key (kbd "C-c A f") 'org-annotate-file-search)
  (eval-after-config 'after-org-config))
#+end_src

*** /ox-textile/                                                      :markdown:

#+begin_src elisp
(with-eval-after-load 'ox-textile
  (defun org-textile-src-block (block contents info)
    (concat
     "<pre><code class=\""
     (org-element-property :language block)
     "\">\n"
     (org-element-property :value block)
     "</code></pre>"))

  (setcdr (assoc 'src-block (org-export-get-all-transcoders 'textile))
          'org-textile-src-block))
#+end_src

*** /org-superstar/ (when installed)

#+begin_src elisp
(when (locate-library "org-superstar")
  (add-hook 'org-mode-hook #'org-superstar-mode)
  (with-eval-after-load 'org-superstar
    ;; ;;;;;;;;;;;;;;; ;;
    ;; Heading markers ;;
    ;; ;;;;;;;;;;;;;;; ;;
    (setq org-superstar-todo-bullet-alist
          '(("TODO" . ?☐)
            ("NEXT" . ?⇒)
            ("DONE" . ?✓)
            ("PLAN" . ?☶)
            ("STAR" . ?☆)
            ("REOP" . ?◯)
            ("FINI" . ?☑)
            ("ENOU" . ?~)
            ("DELE" . ?↓)
            ("LINK" . ?⛓)
            ("WAIT" . ?⏳)
            ("HOLD" . ?✋)
            ("CANC" . ?✗)
            ("FIXM" . ?!)
            ("VERI" . ??)
            ("UNDO" . ?←))
          org-superstar-special-todo-items t
          org-superstar-headline-bullets-list
          ;; '("α" "β" "γ" "δ" "ε" "ζ" "η" "θ" "ι" "κ" "λ" "μ")
          '(?◉ ?○ ?• ?◦ ?‣))))
#+end_src

*** /org-super-agenda/

#+begin_example
;; (setq org-super-agenda-groups
;;       '(;; Each group has an implicit boolean OR operator between its selectors.
;;         (:name "Today"  ; Optionally specify section name
;;                :time-grid t  ; Items that appear on the time grid
;;                :todo "TODAY")  ; Items that have this TODO keyword
;;         (:name "Important"
;;                ;; Single arguments given alone
;;                :tag "bills"
;;                :priority "A")
;;         ;; Set order of multiple groups at once
;;         (:order-multi (2 (:name "Shopping in town"
;;                                 ;; Boolean AND group matches items that match all subgroups
;;                                 :and (:tag "shopping" :tag "@town"))
;;                          (:name "Food-related"
;;                                 ;; Multiple args given in list with implicit OR
;;                                 :tag ("food" "dinner"))
;;                          (:name "Personal"
;;                                 :habit t
;;                                 :tag "personal")
;;                          (:name "Space-related (non-moon-or-planet-related)"
;;                                 ;; Regexps match case-insensitively on the entire entry
;;                                 :and (:regexp ("space" "NASA")
;;                                               ;; Boolean NOT also has implicit OR between selectors
;;                                               :not (:regexp "moon" :tag "planet")))))
;;         ;; Groups supply their own section names when none are given
;;         (:todo "WAITING" :order 8)  ; Set order of this section
;;         (:todo ("SOMEDAY" "TO-READ" "CHECK" "TO-WATCH" "WATCHING")
;;                ;; Show this group at the end of the agenda (since it has the
;;                ;; highest number). If you specified this group last, items
;;                ;; with these todo keywords that e.g. have priority A would be
;;                ;; displayed in that group instead, because items are grouped
;;                ;; out in the order the groups are listed.
;;                :order 9)
;;         (:priority<= "B"
;;                      ;; Show this section after "Today" and "Important", because
;;                      ;; their order is unspecified, defaulting to 0. Sections
;;                      ;; are displayed lowest-number-first.
;;                      :order 1)
;;         ;; After the last group, the agenda will display items that didn't
;;         ;; match any of these groups, with the default order position of 99
;;         ))
#+end_example

#+begin_src elisp
(with-eval-after-load 'org
  (message "Importing org-super-agenda-config")
  (require 'org-super-agenda)

  (setq org-super-agenda-fontify-whole-header-line t
        org-super-agenda-unmatched-name "Tareas"
        org-super-agenda-groups
        '((:name "Horario"
                 :time-grid t
                 :todo "TODAY")
          (:name "Negocios"
                 :tag "@business")
          (:name "Administración"
                 :tag "@admin")
          (:name "Mejora"
                 :file-path "Ethos.org")
          (:name "Trabajo"
                 :tag "@job")
          (:name "Hogar"
                 :tag "@home")
          (:name "Hábito"
                 :habit t)))
  (eval-after-config 'after-org-super-agenda-config)
  (org-super-agenda-mode))
#+end_src

*** /org-appt/

#+begin_src elisp
(with-eval-after-load 'org
  (message "Importing org-appt")

  (require 'appt)
  (fset 'org-appt-start-process
        (if (require 'async nil t)
            #'async-start-process
          (lambda (name program finish &rest args)
            (apply #'start-process name finish program args))))

  (setq appt-disp-window-function 'org-appt-disp-function
        ;; appt-delete-window-function (lambda () t)
        appt-display-interval 2
        appt-message-warning-time 1
        appt-display-duration 1
        appt-display-diary nil
        diary-file (expand-file-name "cache/diary"
                                      user-emacs-directory)
        ;; delete old appointments
        ;; appt-time-msg-list nil
        )
  ;; turn appointment checking on
  (appt-activate t)
  ;; Add org agenda appointments
  ;; t means refresh
  (defun org-appt-update (&rest args)
    (interactive (list nil))
    (let* ((nowtime (current-time))
           (now-ms (nth 2 nowtime)))
      (message (concat
                (let ((inhibit-message t)
                      (message-log-max nil)
                      (org-agenda-files (cl-remove-if-not
                                         'file-exists-p
                                         org-agenda-files)))
                  (org-agenda-to-appt t))
                " at "
                (format-time-string "%Y-%m-%d %T" nowtime)
                (format ".%06d" now-ms)))))
  (advice-add 'org-deadline :after #'org-appt-update)
  (advice-add 'org-schedule :after #'org-appt-update)
  (advice-add 'org-agenda-schedule :after #'org-appt-update)
  (advice-add 'org-time-stamp :after #'org-appt-update)
  (run-at-time "00:00" (* 24 3600) 'org-appt-update)

  (defvar org-appt-disp-functions nil)

  ;; text notification
  (if (not (executable-find "termux-notification"))
      (cl-block 'find
        (cond
         ((fboundp 'notifications-notify)
          (defun org-appt-function-xmessage (msg)
            (notifications-notify
             :title "Org Tasks"
             :body msg
             :timeout 0
             :urgency 'critical)
            (org-appt-start-process "yad disp" "yad" nil "--text" msg)))
         ((executable-find "yad")
          (defun org-appt-function-xmessage (msg)
            (org-appt-start-process "yad disp" "yad" nil "--text" msg)))
         ((executable-find "gxmessage")
          (defun org-appt-function-xmessage (msg)
            (org-appt-start-process "gxmessage disp" "gxmessage" nil msg)))
         ((executable-find "xmessage")
          (defun org-appt-function-xmessage (msg)
            (org-appt-start-process "xmessage disp" "xmessage" nil msg)))
         (t (cl-return-from 'find)))
        (set 'org-appt-disp-functions (cons 'org-appt-function-xmessage org-appt-disp-functions)))
    (defun org-appt-function-termux-notification (msg)
      (org-appt-start-process "termux notification disp" "termux-notification" nil
                              "-c" msg
                              "-t" "Org Agenda"))
    (set 'org-appt-disp-functions (cons 'org-appt-function-termux-notification org-appt-disp-functions)))

  ;; voice notification
  (if (not (executable-find "termux-tts-speak"))
      (cl-block 'find
        (cond
         ((executable-find "sfestival")
          (defun org-appt-function-sfestival (msg)
            (org-appt-start-process "sfestival disp" "sfestival" nil msg)))
         (t (cl-return-from 'find)))
        (set 'org-appt-disp-functions (cons 'org-appt-function-sfestival org-appt-disp-functions)))
    (defun org-appt-function-termux-tts-speak (msg)
      (org-appt-start-process "termux tts disp" "termux-tts-speak" nil
                              "-l" "es" msg))
    (set 'org-appt-disp-functions (cons 'org-appt-function-termux-tts-speak org-appt-disp-functions)))

  ;; vibrate notification
  (when (executable-find "termux-vibrate")
    (defun org-appt-function-termux-vibrate (msg)
      (org-appt-start-process "termux vibrate disp" "termux-vibrate" nil
                              "-d" "1000"))
    (set 'org-appt-disp-functions (cons 'org-appt-function-termux-vibrate org-appt-disp-functions)))

  (unless org-appt-disp-functions
    (set 'org-appt-disp-functions (cons 'message org-appt-disp-functions)))


  (defun org-appt-format-and-calls (min-to-app new-time appt-msg)
    (let ((msg (concat min-to-app " minuto(s) para \n* " appt-msg)))
      (dolist (fun org-appt-disp-functions)
        (funcall fun msg))))

  (defun org-appt-disp-function (min-to-app new-time appt-msg)
    "Display appointment due in MIN-TO-APP (a string) minutes.
NEW-TIME is a string giving the current date.
Displays the appointment message APPT-MSG in a separate buffer.
The arguments may also be lists, where each element relates to a
separate appointment."
    (appt-disp-window min-to-app new-time appt-msg)
    (if org-appt-disp-functions
        (if (atom min-to-app)
            (org-appt-format-and-calls min-to-app new-time appt-msg)
          (cl-mapc (lambda (min msg) (org-appt-format-and-calls min new-time msg))
                   min-to-app appt-msg)))))
#+end_src

*** /org-brain/

#+begin_src elisp
(with-eval-after-load 'org-brain
  (message "Importing org-brain-config")

  (setq org-id-track-globally t
        ;; <only headlines entries>
        ;; org-brain-include-file-entries nil
        ;; org-brain-file-entries-use-title nil
        org-brain-title-max-length 80)

  (push 'org-brain-entry-todo-state org-brain-vis-current-title-prepend-functions)
  (push 'org-brain-entry-tags-string org-brain-vis-current-title-append-functions)


  (when (require 'helm-org-rifle nil t)
    (defun helm-org-rifle-brain ()
      "Rifle files in `org-brain-path'."
      (interactive)
      (let ((helm-org-rifle-close-unopened-file-buffers nil))
        (helm-org-rifle-directories (list org-brain-path))))

    (defun helm-org-rifle-open-in-brain (candidate)
      (-let (((buffer . pos) candidate))
        (with-current-buffer buffer
          (goto-char pos)
          (org-brain-visualize-entry-at-pt))))

    (add-to-list 'helm-org-rifle-actions
                 (cons "Show entry in org-brain" 'helm-org-rifle-open-in-brain)
                 t))

  (when (require 'org-noter nil t)
    (add-hook 'org-noter-insert-heading-hook #'org-id-get-create)
    (defun org-brain-open-org-noter (entry)
      "Open `org-noter' on the ENTRY.
If run interactively, get ENTRY from context."
      (interactive (list (org-brain-entry-at-pt)))
      (org-with-point-at (org-brain-entry-marker entry)
        (org-noter)))

    (define-key org-brain-visualize-mode-map (kbd "\C-c n") 'org-brain-open-org-noter)))
#+end_src

*** /org-tree-slide/

#+begin_src elisp
(with-eval-after-load 'org-tree-slide
  (defvar org-tree-slide-store (make-hash-table :test 'eq))
  (defun org-tree-slide-play-config ()
    (org-show-all)
    (puthash 'face-remapping-alist
             face-remapping-alist org-tree-slide-store)
    (puthash 'hl-line-range-function
             hl-line-range-function org-tree-slide-store)
    (setq-local
     hl-line-range-function
     (lambda ()
       (let ((beg (line-beginning-position))
             (end (line-beginning-position 2)))
         (if (null (overlays-in beg end))
             (cons beg end))))
     face-remapping-alist (let (;; (color "#00C598")
                                (bg (face-attribute 'default :background)))
                            `((default (:height 1.6) default)
                              ;; (header-line (:height 4.5) variable-pitch)
                              (org-level-1 (:height 1.5) org-level-1)
                              (org-block-begin-line
                               (:height 0.5 :foreground ,(face-attribute
                                                          'org-block-begin-line
                                                          :background))
                               org-block-begin-line)
                              ;; (org-block (:background "#D3FBD8") org-block)
                              (org-block-end-line
                               (:height 0.8 :foreground ,(face-attribute
                                                          'org-block-end-line
                                                          :background))
                               org-block-end-line)
                              (org-drawer
                               (:height 0.5 :foreground ,bg)
                               org-drawer)
                              (org-meta-line
                               (:height 0.5 :foreground ,bg)
                               org-meta-line)
                              (org-ellipsis
                               (:height 0.5 :foreground ,bg)
                               org-ellipsis)))))
  (add-hook 'org-tree-slide-play-hook 'org-tree-slide-play-config)

  (defun org-tree-slide-stop-config ()
    (setq-local
     hl-line-range-function
     (gethash 'hl-line-range-function org-tree-slide-store)
     face-remapping-alist
     (gethash 'face-remapping-alist org-tree-slide-store)))
  (add-hook 'org-tree-slide-stop-hook 'org-tree-slide-stop-config)

  (setq org-tree-slide-breadcrumbs " / "
        org-tree-slide-skip-outline-level 2
        org-tree-slide-content-margin-top 0
        org-tree-slide-slide-in-brank-lines 7
        org-tree-slide-slide-in-waiting 0.03
        org-tree-slide-never-touch-face t
        org-tree-slide-activate-message nil
        org-tree-slide-deactivate-message nil))
#+end_src

*** CANC /ellocate/
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
(with-eval-after-load 'ellocate
  (message "Importing ellocate-config")

  (let ((ellocate-dir (expand-file-name "ellocate/" user-emacs-directory)))
    (make-directory ellocate-dir t)
    (setq ellocate-scan-dirs
          (delq nil
                (mapcar
                 (lambda (dir-file)
                   (if (file-directory-p (car dir-file))
                       (progn
                         (setcdr dir-file
                                 (list
                                  (concat ellocate-dir (car (cdr dir-file)))))
                         dir-file)))
                 `((,user-emacs-directory "home--emacs-db")
                   ("~/Prog/"             "home-prog-db")
                   ("~/var/"              "home-var-db"))))))

  (global-set-key (kbd "C-x F") #'ellocate))
#+end_src

*** /smartscan/ (when installed)

#+begin_src elisp
(when (locate-library "smartscan")
  (add-hook 'prog-mode-hook #'smartscan-mode)
  (with-eval-after-load 'smartscan
    (advice-add 'smartscan-symbol-goto :around #'message-silent-advice)
    (setq smartscan-symbol-selector "symbol")

    (defun smartscan-symbol-go-forward (arg)
      "Jumps forward to the next symbol at point"
      (interactive "P")
      (smartscan-symbol-goto (if arg
                                 smartscan-last-symbol-name
                               (smartscan-symbol-at-pt 'end)) 'forward))

    (defun smartscan-symbol-go-backward (arg)
      "Jumps backward to the previous symbol at point"
      (interactive "P")
      (smartscan-symbol-goto (if arg
                                 smartscan-last-symbol-name
                               (smartscan-symbol-at-pt 'beginning)) 'backward))

    (define-key smartscan-map (kbd "M-n") nil)
    (define-key smartscan-map (kbd "C-c C-n") 'smartscan-symbol-go-forward)
    (define-key smartscan-map (kbd "M-p") nil)
    (define-key smartscan-map (kbd "C-c C-p") 'smartscan-symbol-go-backward)
    (define-key smartscan-map (kbd "M-'") nil)
    (define-key smartscan-map (kbd "C-c C-r") 'smartscan-symbol-replace)))
#+end_src

*** /rainbow-delimiters/ (before smartparens)

#+begin_src elisp
(add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
(with-eval-after-load 'rainbow-delimiters
  (with-current-buffer "*scratch*"
    (lisp-interaction-mode))
  (message "Importing rainbow-delimiters-config")
  ;; [
  ;; (require 'cl-lib)
  ;; (require 'color)
  ;; (cl-loop
  ;;  for index from 1 to rainbow-delimiters-max-face-count
  ;;  do
  ;;  (let ((face (intern (format "rainbow-delimiters-depth-%d-face" index))))
  ;;    (cl-callf color-saturate-name (face-foreground face) 30)))
  ;; <xor>
  (set-face-attribute 'rainbow-delimiters-depth-1-face nil
                      :foreground "#999999")
  (set-face-attribute 'rainbow-delimiters-depth-2-face nil
                      :foreground "#8891ff")
  (set-face-attribute 'rainbow-delimiters-depth-3-face nil
                      :foreground "#88fbff")
  (set-face-attribute 'rainbow-delimiters-depth-4-face nil
                      :foreground "#f4ff88")
  (set-face-attribute 'rainbow-delimiters-depth-5-face nil
                      :foreground "#ff88d6")
  (set-face-attribute 'rainbow-delimiters-depth-6-face nil
                      :foreground "#8cff88")
  (set-face-attribute 'rainbow-delimiters-depth-7-face nil
                      :foreground "#c088ff")
  (set-face-attribute 'rainbow-delimiters-depth-8-face nil
                      :foreground "#ffd488")
  (set-face-attribute 'rainbow-delimiters-depth-9-face nil
                      :foreground "#b388ff")
  ;; ]

  (set-face-attribute 'rainbow-delimiters-unmatched-face nil
                      :foreground 'unspecified
                      :inherit 'error
                      :strike-through t))
#+end_src

*** /smartparens/ (when installed)

#+begin_src elisp
(when (locate-library "smartparens")
  (add-hook 'prog-mode-hook #'smartparens-mode)
  (add-hook 'prog-mode-hook #'show-smartparens-mode)
  (add-hook 'org-mode-hook #'smartparens-mode)
  (add-hook 'org-mode-hook #'show-smartparens-mode)
  (with-eval-after-load 'smartparens
    (message "Importing smartparens config")

    (setcar (cdr (assq 'smartparens-mode minor-mode-alist)) nil)

    (unless (require 'smartparens-org nil 'noerror)
      (message-color #("ERROR missing package `smartparens-org'"
                       0 5 (face error))))
    (setq ;;sp-autoinsert-pair nil
     sp-highlight-pair-overlay nil)


    (defun my-open-block-c-mode (id action context)
      "Insert a c block of code when ID ACTION CONTEXT."
      (let* ((current-pos (point))
             (next-char (char-after (1+ current-pos)))
             (pre-pre-char (char-after (- current-pos 3))))
        (when (and
               next-char pre-pre-char
               (eq action 'insert)
               (eq context 'code)
               (char-equal 10 next-char)
               (or (char-equal ?\) pre-pre-char)
                   (save-excursion
                     (beginning-of-line)
                     (looking-at "[[:space:]]*..$"))))
          (indent-according-to-mode)
          (newline)
          (newline)
          (indent-according-to-mode)
          (forward-line -1)
          (indent-according-to-mode))))
    
    (defun my-double-angle-c-mode (id action context)
      "Delete closed angles when ID ACTION CONTEXT."
      (let* ((current-pos (point))
             (next-char (char-after current-pos))
             (next-next-char (char-after (1+ current-pos)))
             (pre-char (char-before (1- current-pos)))
             (pre-pre-char (char-before (- current-pos 2))))
        (when (and
               next-char next-next-char pre-char pre-pre-char
               (eq action 'insert)
               (eq context 'code)
               (char-equal ?> next-char)
               (char-equal ?> next-next-char)
               (char-equal ?< pre-char)
               (not (char-equal ?< pre-pre-char)))
          (delete-char 2))))

    (defun my-double-angle-post (id action context)
      "Unwrap angles and insert single angle when ID ACTION CONTEXT."
      (when (and
             (eq action 'insert)
             (eq context 'code))
        (sp-unwrap-sexp)
        (insert "<")
        ;; (when (bound-and-true-p rainbow-delimiters-mode)
        ;;   (rainbow-delimiters-mode-disable)
        ;;   (rainbow-delimiters-mode-enable))
        ))

    (defun my-double-angle-p (id action context)
      "Check whether a double angle is a c++ operator when ID ACTION CONTEXT."
      (let* ((current-pos (point))
             (pre-char (char-before (1- current-pos)))
             (post-char (char-after current-pos)))
        (if (and
             (eq context 'code)
             (or (and pre-char (char-equal ?< pre-char))
                 (and post-char (char-equal ?< post-char))))
            t
          nil)))

    (defun my-pre-text-code-p (id action context)
      "Check whether precesor is text when ID ACTION CONTEXT."
      (if (eq context 'code) ;; 'comment 'string
          (let ((pos (1- (point))))
            (if (< 0 pos)
                (let ((char (char-before pos)))
                  (if char
                      (if (memq (get-char-code-property char 'general-category)
                                '(Ll Lu Lo Lt Lm Mn Mc Me Nl))
                          t
                        nil)
                    t))
              t))
        t))

    (defun my-c-include-line-p (id action context)
      "Check whether current line is an include when ID ACTION CONTEXT."
      (if (eq context 'code)
          (save-excursion
            (beginning-of-line)
            (if (looking-at "# *include")
                t
              nil))
        nil))

    (defun remove-c-<-as-paren-syntax-backward ()
      "Remove wrong colored angle."
      (interactive)
      (let ((pos (point)))
        (while (<= 0 pos)
          (when (eq (get-char-property pos 'category) 'c-<-as-paren-syntax)
            (remove-text-properties pos (1+ pos) '(category nil))
            (setq pos 0))
          (cl-decf pos))))

    (defun my-org-not-abbrev-p (id action context)
      "Check whether current line isn't an abbrev when ID ACTION CONTEXT."
      (if (eq context 'code)
          (save-excursion
            (beginning-of-line)
            (if (looking-at "[\t ]*<$")
                nil
              t))
        nil))

    (sp-pair "<" ">" :actions '(wrap insert autoskip))
    ;;(sp-local-pair 'c++-mode "<" nil :when '(sp-in-comment-p))
    (sp-local-pair 'shell-script-mode "<" nil :post-handlers '(("[d1]" "SPC")))
    (sp-local-pair 'lisp-mode "'" nil :actions nil)
    (sp-local-pair 'common-lisp-mode "'" nil :actions nil)
    (sp-local-pair 'lisp-interaction-mode "'" nil :actions nil)
    (sp-local-pair 'emacs-lisp-mode "'" nil :actions nil)
    (sp-with-modes '(org-mode)
                   (sp-local-pair "<" nil :post-handlers '(("[d1]" "<") ("[d1]" "SPC"))
                                  :when '(my-org-not-abbrev-p)))
    (sp-with-modes '(c-mode c++-mode)
                   (sp-local-pair "{" nil
                                  :post-handlers '(:add my-open-block-c-mode))
                   (sp-local-pair "/*" "*/" :post-handlers '((" | " "SPC") ("* ||\n[i]" "RET")))
                   (sp-local-pair "<" nil :post-handlers '(("[d1]" "<") ("[d1]" "SPC"))
                                  :when '(my-c-include-line-p my-pre-text-code-p)))

    (defhydra hydra-sp-change (:foreign-keys run)
      "SP"
      ("C-t"            sp-transpose-hybrid-sexp "tr")
      ("S-<left>"       sp-backward-slurp-sexp "←(")
      ("S-<right>"      sp-backward-barf-sexp "(→")
      ("C-<left>"       sp-forward-barf-sexp "←)")
      ("C-<right>"      sp-slurp-hybrid-sexp ")→")
      ("C-<backspace>"  sp-backward-unwrap-sexp "(-)←")
      ("C-<delete>"     sp-unwrap-sexp "(-)")
      ("C-s"            sp-swap-enclosing-sexp "swap")
      ("\""  (lambda () (interactive) (sp-rewrap-sexp '("\"" . "\""))))
      ("\\\""  (lambda () (interactive) (sp-rewrap-sexp '("\\\"" . "\\\""))))
      ("'"  (lambda () (interactive) (sp-rewrap-sexp '("'" . "'"))))
      ("`"  (lambda () (interactive) (sp-rewrap-sexp '("`" . "`"))))
      ("("  (lambda () (interactive) (sp-rewrap-sexp '("(" . ")"))))
      ("["  (lambda () (interactive) (sp-rewrap-sexp '("[" . "]"))))
      ("{"  (lambda () (interactive) (sp-rewrap-sexp '("{" . "}"))))
      ("<"  (lambda () (interactive) (sp-rewrap-sexp '("<" . ">"))))
      ("M-q" nil "quit"))

    (defun kill-to-end-of-sexp ()
      "Delete forward sexp region with kill."
      (interactive)
      (set-mark (point))
      (sp-end-of-sexp)
      (kill-region (point) (mark)))

    (defun kill-to-begin-of-sexp ()
      "Delete backward sexp region with kill."
      (interactive)
      (set-mark (point))
      (sp-beginning-of-sexp)
      (kill-region (point) (mark)))

    (defun toggle-sp-angle-pair ()
      "Toggle angle as pair."
      (interactive)
      (if (member "<" (mapcar (lambda (x) (plist-get x :open)) sp-local-pairs))
          (sp-local-pair major-mode "<" nil :actions nil)
        (sp-local-pair major-mode "<" ">" :actions '(wrap insert autoskip)
                       :post-handlers '(("[d1]" "<") ("[d1]" "SPC"))
                       :when '(my-c-include-line-p my-pre-text-code-p))))

    ;; (defun sp-dwim-of-previous-sexp ()
    ;;   (interactive)
    ;;   (let ((to-beg (- (point) (save-excursion (sp-beginning-of-sexp) (point))))
    ;;         (to-end (- (save-excursion (sp-end-of-sexp) (point)) (point))))
    ;;     (if (<= to-beg to-end)
    ;;         (sp-beginning-of-previous-sexp)
    ;;       (sp-end-of-previous-sexp))))

    ;; (defun sp-dwim-of-next-sexp ()
    ;;   (interactive)
    ;;   (let ((to-beg (- (point) (save-excursion (sp-beginning-of-sexp) (point))))
    ;;         (to-end (- (save-excursion (sp-end-of-sexp) (point)) (point))))
    ;;     (if (<= to-beg to-end)
    ;;         (sp-beginning-of-next-sexp)
    ;;       (sp-end-of-next-sexp))))

    (defun sp-dwim-beginning-of-sexp (&optional arg)
      "Smart beginning of sexp ARG times."
      (interactive "^P")
      (when (= (point) (progn (sp-beginning-of-sexp arg) (point)))
        (sp-beginning-of-previous-sexp arg)))

    (defun sp-dwim-end-of-sexp (&optional arg)
      "Smart end of sexp ARG times."
      (interactive "^P")
      (when (= (point) (progn (sp-end-of-sexp arg) (point)))
        (sp-end-of-next-sexp arg)))


    (defun sp-local-equal-length (str)
      (let ((pos (point))
            (len (length str))
            (it 0)
            (check))
        (while (and (< 0 len)
                    (not (set 'check
                              (string-equal
                               str
                               (buffer-substring-no-properties
                                (- pos len)
                                (min (+ pos it) (point-max)))))))
          (cl-decf len)
          (cl-incf it))
        (if check
            len
          nil)))

    (defun sp-unwrap-sexp-lc ()
      (interactive)
      (let ((ends (sort (mapcar 'cdr sp-pair-list) (lambda (x y) (> (length x) (length y)))))
            (check))
        (while (and ends
                    (not (set 'check (sp-local-equal-length (pop ends))))))
        (if check (left-char check)))
      (call-interactively 'sp-unwrap-sexp))

    (defun sp-rewrap-sexp-lc ()
      (interactive)
      (let ((ends (sort (mapcar 'cdr sp-pair-list) (lambda (x y) (> (length x) (length y)))))
            (check))
        (while (and ends
                    (not (set 'check (sp-local-equal-length (pop ends))))))
        (if check (left-char check)))
      (call-interactively 'sp-rewrap-sexp))

;;;;;;;;;;
    ;; Keys ;;
;;;;;;;;;;
    (define-key smartparens-mode-map (kbd "S-<left>") #'sp-backward-sexp)
    (define-key smartparens-mode-map (kbd "S-<right>") #'sp-forward-sexp)
    (define-key smartparens-mode-map (kbd "M-a") #'sp-backward-up-sexp)
    (define-key smartparens-mode-map (kbd "S-<down>") #'sp-down-sexp)
    (define-key smartparens-mode-map (kbd "C-S-<left>") #'sp-dwim-beginning-of-sexp)
    (define-key smartparens-mode-map (kbd "C-S-<right>") #'sp-dwim-end-of-sexp)
    (define-key smartparens-mode-map (kbd "M-e") #'sp-up-sexp)
    (define-key smartparens-mode-map (kbd "C-S-<down>") #'sp-down-sexp)
    (define-key smartparens-mode-map (kbd "C-S-<delete>") #'kill-to-end-of-sexp)
    (define-key smartparens-mode-map (kbd "M-s <delete>") #'kill-to-end-of-sexp)
    (define-key smartparens-mode-map (kbd "C-S-<insert>") #'kill-to-begin-of-sexp)
    (define-key smartparens-mode-map (kbd "M-s <insert>") #'kill-to-begin-of-sexp)
    (define-key smartparens-mode-map (kbd "C-S-<home>") #'sp-forward-barf-sexp)
    (define-key smartparens-mode-map (kbd "C-S-<end>") #'sp-slurp-hybrid-sexp)
    (define-key smartparens-mode-map (kbd "C-S-<prior>") #'sp-backward-slurp-sexp)
    (define-key smartparens-mode-map (kbd "C-S-<next>") #'sp-backward-barf-sexp)
    (define-key smartparens-mode-map (kbd "C-)") #'sp-unwrap-sexp)
    (define-key smartparens-mode-map (kbd "C-(") #'sp-rewrap-sexp)
    (define-key smartparens-mode-map (kbd "C-\"") #'sp-swap-enclosing-sexp)
    (define-key smartparens-mode-map (kbd "C-S-<return>") #'sp-split-sexp)
    (define-key smartparens-mode-map (kbd "C-c ( m") #'hydra-sp-change/body)
    (define-key smartparens-mode-map (kbd "C-c ( <") #'remove-c-<-as-paren-syntax-backward)
    (define-key smartparens-mode-map (kbd "M-s 7 <") #'toggle-sp-angle-pair)

    ;; (define-key smartparens-mode-map (kbd "C-M-b") 'sp-backward-sexp)
    ;; (define-key smartparens-mode-map (kbd "C-M-f") 'sp-forward-sexp)

    (global-set-key (kbd "M-s 7 (") #'smartparens-mode)))
#+end_src

*** /polymode/ (when installed)

#+begin_src elisp
(with-eval-after-load 'polymode
  (message "Importing polymode config")

  (setcar (cdr (assq 'polymode-minor-mode minor-mode-alist)) "◱")

  (with-eval-after-load 'poly-org
    (setcar (cdr (assq 'poly-org-mode minor-mode-alist)) "◱"))

  (defun polymode-disable-semantic-modes ()
    (semantic-mode -1)
    (semantic-idle-scheduler-mode -1))
  (add-hook 'polymode-minor-mode-hook 'polymode-disable-semantic-modes)

  (define-key polymode-minor-mode-map (kbd "C-'")
    (lookup-key polymode-minor-mode-map "\M-n"))
  (define-key polymode-minor-mode-map "\M-n" nil))
#+end_src

*** /magit/

#+begin_src elisp
(require 'multi-magit-autoloads)
(with-eval-after-load 'magit
  (with-eval-after-load 'magit-mode
    ;; Refresh mode line branch
    (defun vc-refresh-buffers ()
      (interactive)
      (dolist (buffer (buffers-from-file))
        (with-current-buffer buffer
          (when vc-mode
            (setq mode-line-cached nil)
            (vc-refresh-state)))))
    (add-hook 'magit-post-refresh-hook 'vc-refresh-buffers)
    (require 'magit-todos)
    (setq magit-todos-auto-group-items 'always)
    (add-hook 'magit-mode-hook 'magit-todos-mode)
    (require 'multi-magit)
    (setq multi-magit-repolist-columns '(("Name" 25 multi-magit-repolist-column-repo nil)
                                         ("Dirty" 5 multi-magit-repolist-column-status
                                          ((:right-align t)
                                           (:help-echo "N - untracked, U - unstaged, S - staged")))
                                         ("Branch" 25 magit-repolist-column-branch nil)
                                         ("Version" 25 magit-repolist-column-version nil)
                                         ("#B~" 3 magit-repolist-column-stashes
                                          ((:right-align t)
                                           (:help-echo "Number of stashes")))
                                         ("B<U" 3 magit-repolist-column-unpulled-from-upstream
                                          ((:right-align t)
                                           (:help-echo "Upstream changes not in branch")))
                                         ("B>U" 3 magit-repolist-column-unpushed-to-upstream
                                          ((:right-align t)
                                           (:help-echo "Local changes not in upstream")))
                                         ("B<R" 3 magit-repolist-column-unpulled-from-pushremote
                                          ((:right-align t)
                                           (:help-echo "Push branch changes not in current branch")))
                                         ("B>R" 3 magit-repolist-column-unpushed-to-pushremote
                                          ((:right-align t)
                                           (:help-echo "Current branch changes not in push branch")))
                                         ("Path" 99 magit-repolist-column-path nil))))

  ;; (with-eval-after-load 'magit-status
  ;;   (define-key magit-status-mode-map (kbd "M-g c") #'avy-goto-char)
  ;;   (define-key magit-status-mode-map (kbd "M-g C") #'avy-goto-char-2)
  ;;   (define-key magit-status-mode-map (kbd "M-g s") #'avy-goto-char-timer)
  ;;   (define-key magit-status-mode-map (kbd "M-g l") #'avy-goto-line)
  ;;   (define-key magit-status-mode-map (kbd "M-g w") #'avy-goto-word-1)
  ;;   (define-key magit-status-mode-map (kbd "M-g W") #'avy-goto-word-0)
  ;;   (define-key magit-status-mode-map (kbd "M-z")   #'avy-goto-char-timer)
  ;;   (define-key magit-status-mode-map (kbd "M-g k") #'link-hint-open-link)
  ;;   (define-key magit-status-mode-map (kbd "M-g K") #'link-hint-copy-link))
  ;; (with-eval-after-load 'magit-process
  ;;   (define-key magit-process-mode-map (kbd "M-g c") #'avy-goto-char)
  ;;   (define-key magit-process-mode-map (kbd "M-g C") #'avy-goto-char-2)
  ;;   (define-key magit-process-mode-map (kbd "M-g s") #'avy-goto-char-timer)
  ;;   (define-key magit-process-mode-map (kbd "M-g l") #'avy-goto-line)
  ;;   (define-key magit-process-mode-map (kbd "M-g w") #'avy-goto-word-1)
  ;;   (define-key magit-process-mode-map (kbd "M-g W") #'avy-goto-word-0)
  ;;   (define-key magit-process-mode-map (kbd "M-z")   #'avy-goto-char-timer)
  ;;   (define-key magit-process-mode-map (kbd "M-g k") #'link-hint-open-link)
  ;;   (define-key magit-process-mode-map (kbd "M-g K") #'link-hint-copy-link))
  )

(with-eval-after-load 'magit-repos
  (setq magit-repolist-columns '(("Name" 25 magit-repolist-column-ident nil)
                                 ("Branch" 25 magit-repolist-column-branch nil)
                                 ("Version" 25 magit-repolist-column-version nil)
                                 ("#B~" 3 magit-repolist-column-stashes
                                  ((:right-align t)
                                   (:help-echo "Number of stashes")))
                                 ("B<U" 3 magit-repolist-column-unpulled-from-upstream
                                  ((:right-align t)
                                   (:help-echo "Upstream changes not in branch")))
                                 ("B>U" 3 magit-repolist-column-unpushed-to-upstream
                                  ((:right-align t)
                                   (:help-echo "Local changes not in upstream")))
                                 ("B<R" 3 magit-repolist-column-unpulled-from-pushremote
                                  ((:right-align t)
                                   (:help-echo "Push branch changes not in current branch")))
                                 ("B>R" 3 magit-repolist-column-unpushed-to-pushremote
                                  ((:right-align t)
                                   (:help-echo "Current branch changes not in push branch")))
                                 ("Path" 99 magit-repolist-column-path nil))))

(with-eval-after-load 'magit-section
  (face-spec-set 'magit-section-highlight '((((type tty)) :background "grey20"))))
#+end_src

*** /magit-popup/

#+begin_src elisp
(with-eval-after-load 'magit-popup
  (message "Importing magit-popup config")

  (face-spec-set 'magit-popup-argument
                 '((t (:foreground "forest green" :weight bold))))
  ;; (face-spec-set 'magit-popup-disabled-argument
  ;;                '((t (:foreground "slate gray" :weight light))))
  (define-key magit-popup-mode-map "\M-q" 'magit-popup-quit))
#+end_src

*** /docker/

#+begin_src elisp
(with-eval-after-load 'docker-core
  (setq docker-command (or (executable-find "podman")
                           "docker")))
(with-eval-after-load 'docker-compose
  (setq docker-compose-command (or (executable-find "podman-compose")
                                   "docker-compose")))

(with-eval-after-load 'docker-container
  (message "Importing docker-config")
  (eval-when-compile
    (require 'docker-utils))
  (setq docker-container-columns
        '((:name "Id" :width 12 :template "{{ json .ID }}" :sort nil :format nil)
          (:name "Image" :width 6 :template "{{ json .Image }}" :sort nil :format nil)
          (:name "Command" :width 8 :template "{{ json .Command }}" :sort nil :format nil)
          (:name "Created" :width 11 :template "{{ json .CreatedAt }}" :sort nil
                 :format (lambda (x) (format-time-string "%F %T" (date-to-time x))))
          (:name "Status" :width 15 :template "{{ json .Status }}" :sort nil
                 :format (lambda (s)
                           (replace-regexp-in-string
                            "^[^ ]+" (lambda (s) (substring s 0 2))
                            (string-replace
                             "About" "~"
                             (string-replace "Less than" "<" s)))))
          (:name "Ports" :width 19 :template "{{ json .Ports }}" :sort nil :format nil)
          (:name "Names" :width 10 :template "{{ json .Names }}" :sort nil :format nil)))
  (defun docker-container-status-face (status)
    "Return the correct face according to STATUS."
    (cond
     ((s-starts-with? "Up" status)
      'docker-face-status-up)
     ((s-starts-with? "Ex" status)
      'docker-face-status-down)
     (t
      'docker-face-status-other)))

  (docker-utils-transient-define-prefix
   docker-container-logs ()
   "Transient for showing containers logs."
   :man-page "docker-container-logs"
   :value '("--tail 512" "-f" "--timestamps")
   ["Arguments"
    ("-f" "Follow" "-f")
    ("-s" "Since" "--since " read-string)
    ("-t" "Tail" "--tail " read-string)
    ("-u" "Until" "--until " read-string)
    ("-T" "Timestamps" "--timestamps")]
   [:description docker-generic-action-description
                 ("L" "Logs" docker-generic-action-with-buffer)])

  ;; (setq docker-container-logs-arguments '("-f" "-t" "--tail=150")
  ;;       docker-container-logs-popup
  ;;       (list :variable 'docker-container-logs-arguments
  ;;             :man-page "docker-logs"
  ;;             :switches '((?f "Follow" "-f") (?t "Timestamps" "-t"))
  ;;             :options  '((?T "Tail" "--tail="))
  ;;             :actions  '((?L "Logs" docker-container-logs-selection))
  ;;             :default-arguments '("-f" "-t" "--tail=150")
  ;;             :setup-function #'docker-utils-setup-popup))
  ;; (magit-define-popup docker-container-logs-popup
  ;;   "Popup for showing containers logs."
  ;;   'docker-container
  ;;   :man-page "docker-logs"
  ;;   :switches '((?f "Follow" "-f") (?t "Timestamps" "-t"))
  ;;   :options  '((?T "Tail" "--tail="))
  ;;   :actions  '((?L "Logs" docker-container-logs-selection))
  ;;   :default-arguments '("-f" "-t" "--tail=150")
  ;;   :setup-function #'docker-utils-setup-popup)

;;;;;;;;;;
  ;; Keys ;;
;;;;;;;;;;
  ;; (dolist (map-symbol '(docker-container-mode-map
  ;;                       docker-image-mode-map
  ;;                       docker-machine-mode-map
  ;;                       docker-network-mode-map
  ;;                       docker-volume-mode-map))
  ;;   (let ((map (eval map-symbol)))
  ;;     ;; (with-eval-after-load (intern (replace-regexp-in-string "-mode-map" "" (symbol-name map-symbol) t 'literal))
  ;;     (modal-add-first-parent map)
  ;;     ;; )
  ;;     ))
  )
#+end_src

*** /transient/

#+begin_src elisp
(with-eval-after-load 'transient
  (message "Importing transient-config")

  (face-spec-set 'transient-argument
                 '((t (:foreground "forest green" :weight bold))))
  (face-spec-set 'transient-value
                 '((t (:inherit font-lock-string-face :weight bold)))))
#+end_src

*** CANC /yasnippet/
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
(add-hook 'prog-mode-hook #'yas-minor-mode)
(add-hook 'org-mode-hook #'yas-minor-mode)
(with-eval-after-load 'yasnippet
  (message "Importing yasnippet-config")
  (defface mode-line-yasnippet-mode
    '((t :foreground "medium slate blue" :weight bold))
    "Project name" :group 'mode-line)
  (setcar (cdr (assq 'yas-minor-mode minor-mode-alist))
          (propertize "Y" 'face 'mode-line-yasnippet-mode))

  (require 'yasnippet-snippets)
  (setq yas-snippet-dirs
        (list (expand-file-name "cache/snippets" user-emacs-directory)))

  (define-key yas-minor-mode-map (kbd "<tab>") nil)
  (define-key yas-minor-mode-map (kbd "TAB") nil)
  (define-key yas-minor-mode-map (kbd "<backtab>") 'yas-expand-from-trigger-key)
  (define-key yas-keymap [tab] nil)
  (define-key yas-keymap (kbd "TAB") nil)
  (define-key yas-keymap [(control tab)] #'yas-next-field-or-maybe-expand)
  (define-key yas-keymap (kbd "<C-tab>") #'yas-next-field-or-maybe-expand)

  (defun python-args-to-google-docstring (text &optional make-fields)
    "Return a reST docstring format for the python arguments in yas-text.
TEXT - list of python args
MAKE-FIELDS - t or nil"
    (let* ((indent (concat "\n" (make-string (current-column) 32)))
           ;; `python-split-args' found at snippets/python-mode/.yas-setup.el
           (args (python-split-args text))
           (nr 0)
           (formatted-args
            (mapconcat
             (lambda (x)
               (concat "   " (nth 0 x)
                       (when make-fields
                         (format " (${%d:arg%d}): ${%d:arg%d}"
                                 (cl-incf nr) nr (cl-incf nr) nr))
                       (when (nth 1 x) (concat " \(default " (nth 1 x) "\)"))))
             args
             indent)))
      (unless (string= formatted-args "")
        (concat
         (mapconcat 'identity
                    (list "" "Args:" formatted-args)
                    indent)
         "\n"))))

  (yasnippet-snippets-initialize)
  (yas-reload-all))
#+end_src

*** CANC /projectile/
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
(add-hook 'prog-mode-hook #'projectile-mode)
(with-eval-after-load 'projectile
  ;; after semantic
  (message "Importing projectile config")

  (cond ((executable-find "fdfind")
       (setq projectile-generic-command "fdfind . -0 --type f --color=never"))
      ((executable-find "fd-find")
       (setq projectile-generic-command "fd-find . -0 --type f --color=never")))
  (setq-default projectile--mode-line "")
  (setq projectile-mode-line-prefix ""
        projectile-dynamic-mode-line nil
        projectile-globally-ignored-file-suffixes
        '(".o" ".d" ".crt" ".key" ".txt" "~")
        ;; projectile-indexing-method 'native
        ;; projectile-enable-caching nil
        ;; projectile-file-exists-remote-cache-expire nil
        ;; projectile-require-project-root nil
        projectile-find-dir-includes-top-level t  ;; el bug
        projectile-project-root-files-top-down-recurring
        '("Makefile" "makefile" "CMakeLists.txt" "makefile.linux")
        projectile-project-root-files-functions
        '(projectile-root-local
          projectile-root-top-down-recurring
          projectile-root-bottom-up
          projectile-root-top-down)
        ;; projectile-switch-project-action 'counsel-projectile
        projectile-completion-system 'default
        projectile-mode-line-function (lambda () (concat "[" (projectile-project-name) "]")))

  (defun projectile-enable-which-key-integration ()
    (which-key-add-major-mode-key-based-replacements
      major-mode
      "C-c p 4" "other window"
      "C-c p 5" "other frame"
      "C-c p s" "search"
      "C-c p x" "run"))
  (add-hook 'projectile-mode-hook #'projectile-enable-which-key-integration)

  (when (bug-check-function-bytecode
         'projectile-ripgrep
         "wsPExSODIADGx8gICSIiyQPKIASDGwADgh4AywRCI4fMzSGH")
    (defun projectile-ripgrep (search-term &optional arg)
      "Run a Ripgrep search with `SEARCH-TERM' at current project root.

With an optional prefix argument ARG SEARCH-TERM is interpreted as a
regular expression."
      (interactive
       (list (projectile--read-search-string-with-default
              (format "Ripgrep %ssearch for" (if current-prefix-arg "regexp " "")))
             current-prefix-arg))
      (if (require 'ripgrep nil 'noerror)
          (let* ((project-root (projectile-ensure-project (projectile-project-root)))
                 (args (mapcar (lambda (val) (concat "--glob !" val))
                               (append projectile-globally-ignored-files
                                       projectile-globally-ignored-directories))))
            (ripgrep-regexp search-term
                            project-root
                            (if arg
                                args
                              (cons "--fixed-strings" args))))
        (error "Package `ripgrep' is not available"))))

  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map))
#+end_src

*** /origami/ (when installed)

#+begin_src elisp
(when (locate-library "origami")
  (add-hook 'emacs-lisp-mode-hook #'origami-mode)
  (with-eval-after-load 'origami
    (message "Importing origami-config")

    (set-face-attribute 'origami-fold-replacement-face nil
                        :inherit 'unspecified
                        :underline 'unspecified
                        :weight 'bold
                        :foreground "yellow1"
                        :background "DimGray")

    (setq origami-fold-replacement "···")


    (define-key origami-mode-map (kbd "<C-tab>") 'origami-recursively-toggle-node)
    (define-key origami-mode-map (kbd "C-c <tab> n") 'origami-forward-fold-same-level)
    (define-key origami-mode-map (kbd "C-c <tab> N") 'origami-forward-toggle-node)
    (define-key origami-mode-map (kbd "C-c <tab> p") 'origami-backward-fold-same-level)
    (define-key origami-mode-map (kbd "C-c <tab> a") 'origami-close-all-nodes)
    (define-key origami-mode-map (kbd "C-c <tab> A") 'origami-open-all-nodes)
    (define-key origami-mode-map (kbd "C-c <tab> s") 'origami-show-only-node)))
#+end_src

*** /cmake/

#+begin_src elisp
;; cmake-mode
(setq auto-mode-alist
      (nconc '(;;("CMakeLists\\.txt\\'" . cmake-mode) ; por defecto
               ;;("\\.cmake\\'" . cmake-mode) ; por defecto
               ("[Mm]akefile\\." . makefile-mode))
             auto-mode-alist))
;; cmake highlight
(autoload 'cmake-font-lock-activate "cmake-font-lock" nil t)
(add-hook 'cmake-mode-hook #'cmake-font-lock-activate)
#+end_src

*** /flycheck/

#+begin_src elisp
(with-eval-after-load 'flycheck
  (message "Importing flycheck-config")
;;;;;;;;;;;
;; Julia ;;
;;;;;;;;;;;
  (with-eval-after-load 'julia-mode
    (require 'flycheck-julia)
    (flycheck-julia-setup))
;;;;;;;;;;;;;;
;; Flycheck ;;
;;;;;;;;;;;;;;
  ;; Enable flycheck globaly
  ;;(add-hook 'after-init-hook #'global-flycheck-mode)
  ;; Enable flycheck localy
  ;;(add-hook 'prog-mode-hook 'flycheck-mode)
  (add-hook 'c++-mode-hook
            (lambda ()
              (setq flycheck-gcc-language-standard "c++11"
                    flycheck-clang-language-standard "c++11")))

  (setq flycheck-idle-change-delay 2.0
        ;; flycheck-check-syntax-automatically '(save mode-enabled)
        ;; sudo apt install php-codesniffer
        flycheck-phpcs-standard "PSR2")

  ;; (require 'semantic)
  ;; (setq flycheck-clang-system-path (list))
  ;; (require 'semantic/bovine/gcc)
  ;; (let ((dirs (semantic-gcc-get-include-paths "c++")))
  ;;     (dolist (dir dirs)
  ;;       (add-to-list 'flycheck-clang-system-path dir)))

  ;; ;; Disable clang check, gcc check works better
  ;; (setq-default flycheck-disabled-checkers
  ;;               (append flycheck-disabled-checkers
  ;;                       '(c/c++-clang)))
  (with-eval-after-load 'c-c++-config
    (dolist (path c-c++-include-paths)
      (add-to-list 'flycheck-gcc-include-path path)
      (add-to-list 'flycheck-clang-include-path path)))

  ;; hide 'In included' messages
  (defconst flycheck-fold-include-levels-include
    (symbol-function 'flycheck-fold-include-levels))

  (defun flycheck-fold-include-levels-exclude (errors sentinel-message)
    "Exclude ERRORS with SENTINEL-MESSAGE from included files."
    (unless (or (stringp sentinel-message) (functionp sentinel-message))
      (error "Sentinel must be string or function: %S" sentinel-message))
    (let ((sentinel (if (functionp sentinel-message)
                        sentinel-message
                      (lambda (err)
                        (string-match-p sentinel-message
                                        (flycheck-error-message err))))))
      (setq errors (cl-remove-if sentinel errors)))
    errors)
  (defconst flycheck-fold-include-levels-exclude
    (symbol-function 'flycheck-fold-include-levels-exclude))

  (defun flycheck-toggle-includes ()
    "Toggle errors in included files."
    (interactive)
    (if (eq (symbol-function 'flycheck-fold-include-levels)
            (indirect-function flycheck-fold-include-levels-include))
        (fset 'flycheck-fold-include-levels flycheck-fold-include-levels-exclude)
      (fset 'flycheck-fold-include-levels flycheck-fold-include-levels-include))
    (flycheck-buffer))

  ;; warning options
  (defun flycheck-toggle-warnings ()
    "Toggle warnings."
    (interactive)
    (if (member "extra" flycheck-clang-warnings)
        (delete "extra" flycheck-clang-warnings)
      (add-to-list 'flycheck-clang-warnings "extra"))
    (if (member "extra" flycheck-gcc-warnings)
        (delete "extra" flycheck-gcc-warnings)
      (add-to-list 'flycheck-gcc-warnings "extra"))
    (flycheck-buffer))

  (when (member "extra" flycheck-clang-warnings)
    (delete "extra" flycheck-clang-warnings))
  (when (member "extra" flycheck-gcc-warnings)
    (delete "extra" flycheck-gcc-warnings))

  ;; Mode-line
  (when (bug-check-function-bytecode
         'flycheck-mode-line-status-text
         "iYYFAAiJw7eCTgDEgk8AxYJPAMaCTwDHgk8AyAkhyQGeQcoCnkEBhC4AiYM+AMvMA4Y1AM0DhjoAzSOCPwDEtoKyAYJPAM6CTwDPgk8A0LIB0QoCUYc=")
    (defun flycheck-mode-line-status-text (&optional status)
      "Get a text describing STATUS for use in the mode line.

STATUS defaults to `flycheck-last-status-change' if omitted or
nil."
      (pcase (or status flycheck-last-status-change)
        ('not-checked '(:propertize "{}" face mode-line-inactive))
        ('no-checker '(:propertize "{∅}" face mode-line-notready))
        ('running '(:propertize "{↻}" face mode-line-correct))
        ('errored '(:propertize "{✘}" face mode-line-error))
        ('finished `((:propertize "{")
                     ,@(let-alist (flycheck-count-errors flycheck-current-errors)
                         (let (accumulate)
                           (if .warning (push `(:propertize ,
                                                (format "⚠%d" .warning)
                                                face flycheck-error-list-warning)
                                              accumulate))
                           (if .error (push `(:propertize
                                              ,(format "🚫%d" .error)
                                              face flycheck-error-list-error)
                                            accumulate))
                           (or accumulate '((:propertize
                                             "✓"
                                             face flycheck-error-list-info)))))
                     (:propertize "}")))
        ('interrupted '(:propertize "{.}" face mode-line-error))
        ('suspicious '(:propertize "{?}" face mode-line-warning)))))

;;;;;;;;;;;;;;
;; Posframe ;;
;;;;;;;;;;;;;;
  (when (and (display-graphic-p) (load "flycheck-posframe" t))
    (add-hook 'flycheck-mode-hook #'flycheck-posframe-mode))

  ;; Keys
  (define-key flycheck-mode-map (kbd "C-c ! t w") 'flycheck-toggle-warnings)
  (define-key flycheck-mode-map (kbd "C-c ! t i") 'flycheck-toggle-includes)
  (define-key flycheck-mode-map (kbd "M-g n") #'flycheck-next-error)
  (define-key flycheck-mode-map (kbd "M-g M-n") #'flycheck-next-error)
  (define-key flycheck-mode-map (kbd "M-g p") #'flycheck-previous-error)
  (define-key flycheck-mode-map (kbd "M-g M-p") #'flycheck-previous-error))
#+end_src

*** /lua-mode/

#+begin_src elisp
(with-eval-after-load 'lua-mode
  (message "Importing lua-config")
  (setq lua-indent-level 4))
#+end_src

*** /virtualenvwrapper/

#+begin_src elisp
(with-eval-after-load 'virtualenvwrapper
  (message "Importing virtualenvwrapper config")

  (venv-initialize-interactive-shells) ;; if you want interactive shell support
  (venv-initialize-eshell) ;; if you want eshell support
  ;; note that setting `venv-location` is not necessary if you
  ;; use the default location (`~/.virtualenvs`), or if the
  ;; the environment variable `WORKON_HOME` points to the right place
  (setq venv-location "~/.virtualenvs"))
#+end_src

*** /web-mode/

#+begin_src elisp
(setq auto-mode-alist (nconc auto-mode-alist
                             '(("\\.phtml\\'" . web-mode)
                               ("\\.tpl\\.php\\'" . web-mode)
                               ("\\.[agj]sp\\'" . web-mode)
                               ("\\.as[cp]x\\'" . web-mode)
                               ("\\.erb\\'" . web-mode)
                               ("\\.mustache\\'" . web-mode)
                               ("\\.djhtml\\'" . web-mode)
                               ("\\.html?\\'" . web-mode)
                               ("\\.tpl\\'" . web-mode)
                               ("\\.hbs\\'" . web-mode))))
(with-eval-after-load 'web-mode
  (message "Importing web-config")

  (setq web-mode-enable-auto-indentation nil
        web-mode-code-indent-offset 2
        web-mode-markup-indent-offset 2
        web-mode-css-indent-offset 2))
#+end_src

*** /plantuml-mode/

#+begin_src elisp
;; Enable plantuml-mode for PlantUML files
;; (add-to-list 'auto-mode-alist '("\\.plantuml\\'" . plantuml-mode))
(with-eval-after-load 'plantuml-mode
  (message "Importing plantuml-mode")

  (setq plantuml-default-exec-mode 'jar
        plantuml-jar-path (expand-file-name 
                           "cache/java/plantuml.jar"
                           user-emacs-directory)))
#+end_src

**** Plantuml documentation


- Emphasized text

@startuml
Alice -> Bob : hello --there--
... Some ~~long delay~~ ...
Bob -> Alice : ok
note left
  This is **bold**
  This is //italics//
  This is ""monospaced""
  This is --stroked--
  This is __underlined__
  This is ~~waved~~
end note
@enduml

bold italic monospaced stroke underline wave creole syntax

- List

@startuml
object demo {
  * Bullet list
  * Second item
}
note left
  * Bullet list
  * Second item
  ** Sub item
end note

legend
  # Numbered list
  # Second item
  ## Sub item
  ## Another sub item
  # Third item
end legend
@enduml

list in creole

- Escape character

You can use the tilde ~ to escape special creole characters.

@startuml
object demo {
  This is not ~___underscored__.
  This is not ~""monospaced"".
}
@enduml

escaping character in creole

- Horizontal lines

@startuml
database DB1 as "
You can have horizontal line
----
Or double line
====
Or strong line
____
Or dotted line
..My title..
Enjoy!
"
note right
  This is working also in notes
  You can also add title in all these lines
  ==Title==
  --Another title--
end note
@enduml

separator in creole

- Headings

@startuml
usecase UC1 as "
= Extra-large heading
Some text
== Large heading
Other text
=== Medium heading
Information
....
==== Small heading"
@enduml

heading in creole

- Legacy HTML

Some HTML tags are also working:

    <b> for bold text
    <u> or <u:#AAAAAA> or <u:colorName> for underline
    <i> for italic
    <s> or <s:#AAAAAA> or <s:colorName> for strike text
    <w> or <w:#AAAAAA> or <w:colorName> for wave underline text
    <color:#AAAAAA> or <color:colorName>
    <back:#AAAAAA> or <back:colorName> for background color
    <size:nn> to change font size
    <img:file> : the file must be accessible by the filesystem
    <img:http://url> : the URL must be available from the Internet

@startuml
  :* You can change <color:red>text color</color> 
  * You can change <back:cadetblue>background color</back> 
  * You can change <size:18>size</size> 
  * You use <u>legacy</u> <b>HTML <i>tag</i></b> 
  * You use <u:red>color</u> <s:green>in HTML</s> <w:#0000FF>tag</w>
  ----
  * Use image : <img:sourceforge.jpg> 
  ;
@enduml

some HTML tag are working with creole

- Table

It is possible to build table.

@startuml
skinparam titleFontSize 14
title
  Example of simple table
  |= |= table |= header |
  | a | table | row |
  | b | table | row |
end title
[*] --> State1
@enduml

simple table in creole

- Background colors

You can specify background colors for cells and lines.

@startuml
start
:Here is the result
|= |= table |= header |
| a | table | row |
|<#FF8080> red |<#80FF80> green |<#8080FF> blue |
<#yellow>| b | table | row |;
@enduml

background color for table in creole

- Tree

You can use |_ characters to build a tree.

@startuml
skinparam titleFontSize 14
title
  Example of Tree
  |_ First line
  |_ **Bom(Model)**
    |_ prop1
    |_ prop2
    |_ prop3
  |_ Last line
end title
[*] --> State1
@enduml

tree in creole

- Special characters

It's possible to use any unicode characters with &# syntax or <U+XXXX>

usecase foo as "this is &#8734; long"
usecase bar as "this is also <U+221E> long"

unicode support in creole

- OpenIconic

OpenIconic is an very nice open source icon set. Those icons have been integrated into the creole parser, so you can use them out-of-the-box.

You can use the following syntax: <&ICON_NAME>.

@startuml
title: <size:20><&heart>Use of OpenIconic<&heart></size>
class Wifi
note left
  Click on <&wifi>
end note
@enduml

*** /edit-server/

#+begin_src elisp
(with-eval-after-load 'edit-server
  (message "Importing edit-server-config")

  (setcar (cdr (assq 'edit-server-edit-mode minor-mode-alist)) "Es")

  (setq edit-server-url-major-mode-alist
        '(("github\\.com" . markdown-mode)
          ("gitlab\\."    . markdown-mode)))

  (defun edit-server-header-line ()
    (setq header-line-format
          (substitute-command-keys
           "Commit: `\\[edit-server-done]'  Save: `\\[edit-server-save]'  \
Abort: `\\[edit-server-abort]'")))
  (add-hook 'edit-server-edit-mode-hook 'edit-server-header-line)

  (define-key edit-server-edit-mode-map (kbd "C-c C-k") 'edit-server-abort))
#+end_src

*** /emms/

#+begin_src elisp
(with-eval-after-load 'emms
  (message "Importing emms-config")

  (require 'emms-setup)
  (emms-minimalistic)
  (emms-default-players)

  (require 'emms-source-file)
  (require 'emms-volume)
  
  (setq emms-source-file-default-directory
        (cl-some (lambda (f)
                   (and (file-exists-p f)
                        f))
                 '("~/Music"
                   "~/Música"))
        emms-volume-change-function 'emms-volume-pulse-change
        emms-volume-pulse-sink "@DEFAULT_SINK@")

  (require 'emms-player-mplayer)
  (push "-novideo" emms-player-mplayer-parameters)
  (push "-novideo" emms-player-mplayer-playlist-parameters)

  (require 'emms-cache)
  (emms-cache-enable)

  (require 'emms-playlist-mode)
  (global-set-key (kbd "C-c e l") 'emms)
  (global-set-key (kbd "C-c e P") 'emms-pause)
  (global-set-key (kbd "C-c e SPC") 'emms-pause)
  (global-set-key (kbd "C-c e s") 'emms-stop)
  (global-set-key (kbd "C-c e f") 'emms-show)
  (global-set-key (kbd "C-c e r") 'emms-random)
  (global-set-key (kbd "C-c e n") 'emms-next)
  (global-set-key (kbd "C-c e p") 'emms-previous)
  (global-set-key (kbd "C-c e <") 'emms-seek-backward)
  (global-set-key (kbd "C-c e >") 'emms-seek-forward)
  (global-set-key (kbd "C-c e +") 'emms-volume-raise)
  (global-set-key (kbd "C-c e -") 'emms-volume-lower)
  (global-set-key (kbd "C-c e RET") 'emms-start)

  (global-set-key (kbd "<XF86AudioPlay>") 'emms-pause)
  (global-set-key (kbd "<XF86AudioStop>") 'emms-stop)
  (global-set-key (kbd "<XF86AudioPrev>") 'emms-previous)
  (global-set-key (kbd "<XF86AudioNext>") 'emms-next))
(global-set-key (kbd "C-c e B") 'emms-smart-browse)
(global-set-key (kbd "C-c e b") 'emms-browser)
(global-set-key (kbd "C-c e a") 'emms-add-directory)
#+end_src

*** /elfeed/

#+begin_src elisp
(global-set-key (kbd "C-x w") 'elfeed)
(with-eval-after-load 'elfeed
  (message "Importing elfeed-config")

  (defface elfeed-search-science-title-face
    '((((class color) (background light)) (:foreground "#fd0"))  ;; gold
      (((class color) (background dark))  (:foreground "#fd0")))
    "Face used in search mode for titles."
    :group 'elfeed)

  (defface elfeed-search-arxiv-title-face
    '((((class color) (background light)) (:foreground "#ad3" :underline t))  ;; yellow green
      (((class color) (background dark))  (:foreground "#ad3" :underline t)))
    "Face used in search mode for titles."
    :group 'elfeed)

  (defface elfeed-search-health-title-face
    '((((class color) (background light)) (:foreground "#fcd"))  ;; pink
      (((class color) (background dark))  (:foreground "#fcd")))
    "Face used in search mode for titles."
    :group 'elfeed)

  (defface elfeed-search-audio-title-face
    '((t  (:background "#3d3")))  ;; lime green
    "Face used in search mode for titles."
    :group 'elfeed)

  (defface elfeed-search-image-title-face
    '((t  (:background "#ad3")))  ;; yellow green
    "Face used in search mode for titles."
    :group 'elfeed)

  (defface elfeed-search-video-title-face
    '((t  (:background "#a33")))  ;; brown
    "Face used in search mode for titles."
    :group 'elfeed)

  (push '(aud elfeed-search-audio-title-face) elfeed-search-face-alist)
  (push '(img elfeed-search-image-title-face) elfeed-search-face-alist)
  (push '(vid elfeed-search-video-title-face) elfeed-search-face-alist)
  (push '(science elfeed-search-science-title-face) elfeed-search-face-alist)
  (push '(arxiv elfeed-search-arxiv-title-face) elfeed-search-face-alist)
  (push '(health elfeed-search-health-title-face) elfeed-search-face-alist)

  (defun elfeed-youtube-expand (id)
    (format
     (pcase (substring id 0 2)
       ("UC" "https://www.youtube.com/feeds/videos.xml?channel_id=%s")
       ("PL" "https://www.youtube.com/feeds/videos.xml?playlist_id=%s")
       (_    "https://www.youtube.com/feeds/videos.xml?user=%s"))
     id))

  (setq elfeed-feeds
        `(
          ;; ("https://e00-expansion.uecdn.es/rss/portada.xml" expansion es txt)
          ;; ("http://estaticos.elmundo.es/elmundo/rss/espana.xml" elmundo spain es txt)
          ;; ("http://estaticos.elmundo.es/elmundo/rss/internacional.xml" elmundo world es txt)
          ;; ("http://www.abc.es/rss/feeds/abc_EspanaEspana.xml" abc spain es txt)
          ;; ("http://www.abc.es/rss/feeds/abc_Internacional.xml" abc world es txt)
          ;; ("https://feeds.elpais.com/mrss-s/pages/ep/site/elpais.com/portada" elpais spain es txt)
          ;; ("https://feeds.elpais.com/mrss-s/pages/ep/site/elpais.com/section/internacional/portada" elpais world es txt)
          ;; [ english
          ;; ("http://feeds.bbci.co.uk/news/rss.xml?edition=int" bbc world en txt)
          ;; ("https://www.theguardian.com/international/rss" theguardian world en txt)
          ;; ("https://rss.nytimes.com/services/xml/rss/nyt/World.xml" nytimes world en txt)
          ;; ]
          ;; [ science
          ;; ("http://rss.sciam.com/ScientificAmerican-Global" SA science en txt)
          ;; ("https://www.sciencenews.org/feed" sciencenews science en txt)
          ;; arxiv papers
          ;; ,@(mapcar (lambda (category)
          ;;             (list (concat "http://arxiv.org/rss/" (symbol-name category))
          ;;                   'arxiv category 'en 'txt))
          ;;           '(astro-ph cond-mat cs econ eess gr-qc hep-ex hep-lat
          ;;                      hep-ph hep-th math math-ph nlin nucl-ex nucl-th
          ;;                      physics q-bio q-fin quant-ph stat))
          ("http://arxiv.org/rss/math-ph" arxiv math en txt)
          ("http://arxiv.org/rss/physics" arxiv physics en txt)
          ("http://arxiv.org/rss/cs.AI" arxiv ai en txt)
          ;; ]
          ;; [ health
          ("https://www.who.int/rss-feeds/news-english.xml" oms health es txt)
          ;; ]
          ;; podcast
          ;; ("https://podcasts.files.bbci.co.uk/p02pc9ny.rss" bbc en aud)
          ;; ("https://www.theguardian.com/news/series/todayinfocus/podcast.xml" theguardian en aud)
          ;; images
          ("https://xkcd.com/atom.xml" xkcd en img)
          ;; video
          (,(elfeed-youtube-expand "UCHnyfMqiRRG1u-2MsSQLbXA") veritasium science en vid)
          ;; curiosity
          ("http://www.iqscorner.com/feeds/posts/default?alt=rss" cur corner iq en txt)
          ("http://importantquestionsabout.blogspot.com/feeds/posts/default?alt=rss" cur quest gk en txt)
          ("https://www.reddit.com/r/IntelligenceQ/.rss" cur reddit iq en txt)
          ("http://brainstormingbox.org/feed/" cur storm gk en txt)
          ("https://deepmind.com/blog/feed/basic/" cur google ai en txt)
          ("https://writings.stephenwolfram.com/feed/" cur wolfram math en txt)
          ;; universities
          ("https://www.sup.org/rss/?feed=economics" uni stanford economics en txt)
          ("https://www.sup.org/rss/?feed=anthropology" uni stanford anthropology en txt)
          ("https://www.sup.org/rss/?feed=philosophy" uni stanford philosophy en txt)
          ("https://www.cam.ac.uk/news-feed-generator.rss?field_taxonomy_section_tid=All" uni cambridge en txt)
          ("https://www.southampton.ac.uk/news/feeds/home-news-feed.page" uni southampton en txt)
          )
        elfeed-db-directory (expand-file-name "elfeed" user-emacs-directory)
        elfeed-search-filter "@1-month-ago +unread"
        elfeed-search-date-format '("%Y-%m-%d %H:%M" 16 :left)
        elfeed-search-trailing-width 30
        elfeed-search-title-min-width 20
        elfeed-search-title-max-width 100)

  (setq elfeed-search--tags
        (let ((tags #s(hash-table size 30 test eq data (unread t))))
          (dolist (item elfeed-feeds)
            (if (listp item)
                (mapc (lambda (tag) (puthash tag t tags))
                      (cdr item))))
          (mapcar 'symbol-name
                  (hash-table-keys tags))))

  (defun elfeed-search-filter-tags-selection (arg)
    (interactive "P")
    (let ((tag (completing-read "Select tag: " elfeed-search--tags nil t)))
      (elfeed-search-set-filter
       (if (string-match (concat "\\( ?\\)\\([-+]\\)" tag) elfeed-search-filter)
           (replace-match (if arg
                              (concat
                               (match-string 1 elfeed-search-filter)
                               (if (string-equal "+" (match-string
                                                      2 elfeed-search-filter))
                                   "-"
                                 "+")
                               tag)
                            "")
                          t t elfeed-search-filter)
         (concat elfeed-search-filter " " (if arg "-" "+") tag)))))

  (define-key elfeed-show-mode-map "h" nil)
  (define-key elfeed-show-mode-map "?" #'describe-mode)
  (define-key elfeed-show-mode-map "R" #'language-text-to-speak-region)
  (define-key elfeed-show-mode-map "S" #'language-text-to-speak-stop)

  (define-key elfeed-search-mode-map "h" nil)
  (define-key elfeed-search-mode-map "?" #'describe-mode)
  (define-key elfeed-search-mode-map "t" 'elfeed-search-filter-tags-selection)
  )
#+end_src

*** /ein/

#+begin_src elisp
(with-eval-after-load 'ein-core
  (message "Importing ein-config")

  (setq ein:output-area-inlined-images t))
#+end_src

*** /xahk-mode/

#+begin_src elisp
(add-to-list 'auto-mode-alist '("\\.ahk\\'" . xahk-mode))
#+end_src

*** /vterm/

Añadir a =.bashrc= después de la asignación del prompt ~PS1~:

#+begin_src bash
case "$INSIDE_EMACS" in
vterm)
    vterm_printf(){
        if [ -n "$TMUX" ] && ([ "${TERM%%-*}" = "tmux" ] || [ "${TERM%%-*}" = "screen" ] ); then
            # Tell tmux to pass the escape sequences through
            printf "\ePtmux;\e\e]%s\007\e\\" "$1"
        elif [ "${TERM%%-*}" = "screen" ]; then
            # GNU screen (screen, screen-256color, screen-256color-bce)
            printf "\eP\e]%s\007\e\\" "$1"
        else
            printf "\e]%s\e\\" "$1"
        fi
    }
    vterm_prompt_end(){
        vterm_printf "51;A$(whoami)@$(hostname):$(pwd)"
    }
    PS1=$PS1'\[$(vterm_prompt_end)\]'
    ;;
esac
#+end_src

#+begin_src elisp
;;(add-hook 'vterm-mode-hook 'inhibit-mode-line)
(global-set-key (kbd "C-M-<return>") 'vterm)
(global-set-key (kbd "C-x 4 RET") 'vterm-other-window)
(with-eval-after-load 'vterm
  (setq vterm-buffer-name-string "*vterm %s*"
        vterm-max-scrollback 20000))
#+end_src

*** /async/

#+begin_src elisp
(async-bytecomp-package-mode)
#+end_src

*** CANC /deadgrep/
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
(global-set-key (kbd "M-g M-a") 'deadgrep)
(with-eval-after-load 'deadgrep
  (define-key deadgrep-edit-mode-map (kbd "C-c C-c") 'deadgrep-mode)
  (define-key deadgrep-mode-map "e" 'deadgrep-edit-mode))
#+end_src

* Machine config

#+begin_src elisp
;;;;;;;;;;;;;;;;;;
;; Machine name ;;
;;;;;;;;;;;;;;;;;;
(cond
 ;;;;;;;;;;;;;;;;;;;;;;;
 ;; localhost machine ;;
 ;;;;;;;;;;;;;;;;;;;;;;;
 ((string-equal (system-name) "localhost")
  ;; (setq temporary-file-directory "~/tmp/")
  (with-eval-after-load 'python-mode
    (set 'py-temp-directory temporary-file-directory))
  (toggle-hscroll-aggressive)
  (remove-hook 'c++-mode-hook 'irony-mode)
  (remove-hook 'c-mode-hook 'irony-mode)
  (remove-hook 'objc-mode-hook 'irony-mode)
  (remove-hook 'c-mode-hook 'rtags-start-process-unless-running)
  (remove-hook 'c++-mode-hook 'rtags-start-process-unless-running)
  (require 'gtags-config)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Machine operating system ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(cond
 ;;;;;;;;;;;
 ;; Linux ;;
 ;;;;;;;;;;;
 ((eq system-type 'gnu/linux)
  )
 ;;;;;;;;;;;;;
 ;; Windows ;;
 ;;;;;;;;;;;;;
 ((eq system-type 'windows-nt)
  ;; Coding system
  (setq default-process-coding-system '(windows-1252-dos . windows-1252-dos))
  ;; Clean environment PATH
  (setenv "PATH" (mapconcat 'identity (remove-if (lambda (s) (string-match-p "\\\\MKS\\\\" s)) (delete "" (split-string (getenv "PATH") ";"))) ";"))
  (set 'exec-path (delete "" (split-string (getenv "PATH") ";")))
  ;; Paths
  (defun path-style-linux-to-windows (filename)
    (if (string-match "^/" filename)
        (concat "c:/cygwin64" filename)
      filename))
  (defun figlet-get-font-dir-advice (orig-fun &rest args)
    (path-style-linux-to-windows (apply orig-fun args)))
  (advice-add 'figlet-get-font-dir :around #'figlet-get-font-dir-advice)
  ;; Python
  (with-eval-after-load 'elpy
    (setq elpy-rpc-python-command (or (executable-find "py")
                                      (executable-find "pythonw")
                                      "python"))
    (let ((time (* 15 60)))
      (run-with-timer time time 'elpy-rpc-restart-max 7 "python.exe")
      (message "Limiting python's interpreters every %i seconds" time)))
  ;; Org
  (with-eval-after-load 'org-config
    (setq org-babel-python-command python-shell-interpreter))
  ;; UTF 8
  ;;(modify-coding-system-alist 'file "" 'utf-8)
  ;;(modify-coding-system-alist 'process "" 'utf-8)
  ;; Bugs
  (require 'emacs-win-bug))
 ;;;;;;;;;;;;
 ;; Cygwin ;;
 ;;;;;;;;;;;;
 ((eq system-type 'cygwin)
  (add-to-list 'recentf-exclude "\\\\")
  (setq recentf-save-file "recentf_cygwin"
        cygwin-root-path (if (executable-find "cygpath")
                             (substring (shell-command-to-string "cygpath -m /") 0 -1)
                           "/cygwin64"))
  ;; coding
  (defun get-buffer-file-coding-system-local (process)
    (if (ede-current-project)
        (buffer-local-value 'buffer-file-coding-system (find-file-noselect (oref (ede-current-project) file)))
      'utf-8-dos))
  (add-to-list 'process-coding-system-alist '("ag" . get-buffer-file-coding-system-local))
  (add-to-list 'process-coding-system-alist '("grep" . get-buffer-file-coding-system-local))
  (defun helm-ag--remove-carrige-returns ()
    (save-excursion
      ;; [ solve ^M at the end of the line
      (goto-char (point-min))
      (while (re-search-forward "\xd" nil t)
        (replace-match "" t t))
      ;; ]
      ;; <xor>
      ;; [ solve both ^M at end and acutes
      ;; but have any problems... I don't remember
      ;; (recode-region (point-min) (point-max) 'latin-1-dos 'utf-8-unix)
      ;; ]
      ))
  ;; correct ascii characters
  (defun ascii-to-utf8-compilation-filter ()
    (ascii-to-utf8-forward compilation-filter-start (point-max)))
  (add-hook 'compilation-filter-hook 'ascii-to-utf8-compilation-filter)
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; obtain linux style paths ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (defun path-style-windows-to-linux (filename)
    (if (string-match "\\([A-Z]\\):\\\\" filename)
        (replace-regexp-in-string
         "\\\\" "/"
         (replace-match
          (concat "/cygdrive/"
                  (downcase (match-string 1 filename))
                  "/") nil t filename) nil t)
      (replace-regexp-in-string "\\\\" "/" filename nil t)))
  ;; shell-command
  (defun shell-command-advice (orig-fun command &rest args)
    (cond
     ((string-match "^WINWORD" command)
      (apply orig-fun (replace-regexp-in-string
                       "/q \""
                       (concat "/q \"" cygwin-root-path)
                       command nil t) args))
     ((or
       (string-match "^java" command)
       (string-match "^soffice" command))
      (apply orig-fun (replace-regexp-in-string
                       "\\([^<>] +\"?\\)/"
                       (concat "\\1" cygwin-root-path "/")
                       command) args))
     (t (apply orig-fun command args))))
  (advice-add 'shell-command :around #'shell-command-advice)
  (advice-add 'shell-command-to-string :around #'shell-command-advice)
  (advice-add 'org-babel-eval :around #'shell-command-advice)
  ;; find-file
  ;; (defun find-file-advice (orig-fun filename &rest args)
  ;;   (set 'filename (path-style-windows-to-linux filename))
  ;;   (apply orig-fun filename args))
  ;; (require 'files)
  ;; (advice-add 'find-file-noselect :around #'find-file-advice)
  ;; expand file name
  ;; (defun expand-file-name-advice (orig-fun filename &rest args)
  ;;   (if (string-match "^\\([A-Z]\\):\\\\" filename)
  ;;       filename
  ;;     (apply orig-fun filename args)))
  ;; (advice-add 'expand-file-name :around #'expand-file-name-advice)
  ;; file exist
  ;; (defun file-exists-p-advice (orig-fun filename &rest args)
  ;;   (apply orig-fun (path-style-windows-to-linux filename) args))
  ;; (advice-add 'file-exists-p :around #'file-exists-p-advice)
  ;; compile
  (defun compilation-find-file-advice (orig-fun maker filename &rest args)
    (set 'filename (path-style-windows-to-linux filename))
    (apply orig-fun maker filename args))
  (require 'compile)
  (advice-add 'compilation-find-file :around #'compilation-find-file-advice)
  ;; ffap
  (defun ffap-string-at-point-advice (orig-fun &rest args)
    (path-style-windows-to-linux (apply orig-fun args)))
  (require 'ffap)
  (advice-add 'ffap-string-at-point :around #'ffap-string-at-point-advice)
  (global-set-key (kbd "C-v") 'yank)))

(when (locate-library "helm")
  (define-key global-map [remap find-file] 'helm-find-files)
  (define-key global-map [remap occur] 'helm-occur)
  (define-key global-map [remap list-buffers] 'helm-buffers-list)
  (define-key global-map [remap yank-pop] 'helm-show-kill-ring)
  (define-key global-map [remap kmacro-end-and-call-macro] 'helm-execute-kmacro)
  (define-key global-map [remap switch-to-buffer] 'helm-mini)
  (define-key global-map [remap insert-register] 'helm-register)
  (define-key global-map [remap bookmark-jump] 'helm-filtered-bookmarks)
  (define-key global-map [remap dabbrev-expand] 'helm-dabbrev)
  (define-key global-map [remap apropos-command] 'helm-apropos)
  (define-key global-map [remap jump-to-register] 'helm-register)
  (define-key global-map [remap find-dired] (if (fboundp 'helm-fd) 'helm-fd 'helm-find))
  (unless (boundp 'completion-in-region-function)
    (define-key lisp-interaction-mode-map [remap completion-at-point] 'helm-lisp-completion-at-point)
    (define-key emacs-lisp-mode-map       [remap completion-at-point] 'helm-lisp-completion-at-point)))

(eval-after-config 'after-machine-config)
#+end_src

* Config autoloads

- Generated with ~make-directory-autoloads~

#+begin_src elisp
(require 'config-autoloads)
#+end_src

* Bugs
** /gdb/

#+begin_src elisp
(with-eval-after-load 'gud-config
  (add-hook 'gdb-mode-hook (lambda () (gud-basic-call "set print sevenbit-strings off"))))
#+end_src

** CANC /flyspell/
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
(with-eval-after-load 'flyspell
  ;; Change mouse hover help text
  (when (bug-check-function-bytecode
         'make-flyspell-overlay
         "wwQExMXEJcYBxwUjiMYByAQjiMYBycUjiMYBysUjiMYBy8wjiM0IzgYHzyIiiMYBzwgjiALQPYNQAAk7g0UAxgHRCSOICjuDUADGAdIKI4iJhw==")
    (defun make-flyspell-overlay (beg end face mouse-face)
      "Allocate an overlay to highlight an incorrect word.
BEG and END specify the range in the buffer of that word.
FACE and MOUSE-FACE specify the `face' and `mouse-face' properties
for the overlay."
      (let ((overlay (make-overlay beg end nil t nil)))
        (overlay-put overlay 'face face)
        (overlay-put overlay 'mouse-face mouse-face)
        (overlay-put overlay 'flyspell-overlay t)
        (overlay-put overlay 'evaporate t)
        (overlay-put overlay 'help-echo "C-mouse-2: correct word at point")
        ;; If misspelled text has a 'keymap' property, let that remain in
        ;; effect for the bindings that flyspell-mouse-map doesn't override.
        (set-keymap-parent flyspell-mouse-map (get-char-property beg 'keymap))
        (overlay-put overlay 'keymap flyspell-mouse-map)
        (when (eq face 'flyspell-incorrect)
          (and (stringp flyspell-before-incorrect-word-string)
               (overlay-put overlay 'before-string
                            flyspell-before-incorrect-word-string))
          (and (stringp flyspell-after-incorrect-word-string)
               (overlay-put overlay 'after-string
                            flyspell-after-incorrect-word-string)))
        overlay))))
#+end_src

** /ace-window/

#+begin_src elisp
(with-eval-after-load 'ace-window
  ;;;; OVERRIDDEN
  (defun aw-update ()
    "Update ace-window-path window parameter for all windows.

Ensure all windows are labeled so the user can select a specific
one, even from the set of windows typically ignored when making a
window list."
    (unless prefix-arg        ;; +
      (let (;; (aw-ignore-on) ;; -
            (aw-ignore-current)
            (ignore-window-parameters t))
        (avy-traverse
         (avy-tree (aw-window-list) aw-keys)
         (lambda (path leaf)
           (set-window-parameter
            leaf 'ace-window-path
            (propertize
             (apply #'string (reverse path))
             'face 'aw-mode-line-face)))))))
  ;;;; OVERRIDDEN
  (defun aw-show-dispatch-help ()
    "Display action shortucts in echo area."
    (interactive)
    (message "%s" (mapconcat
                   (lambda (action)
                     (cl-destructuring-bind (key fn &optional description) action
                       (format "%s: %s"
                               (propertize
                                ;; (char-to-string key)      ;; -
                                (key-description (list key)) ;; +
                                'face 'aw-key-face)
                               (or description fn))))
                   aw-dispatch-alist
                   "\n"))
    ;; Prevent this from replacing any help display
    ;; in the minibuffer.
    (let (aw-minibuffer-flag)
      (mapc #'delete-overlay aw-overlays-back)
      (call-interactively 'ace-window)))
  ;;;; OVERRIDDEN
  (defun aw-select (mode-line &optional action)
  "Return a selected other window.
Amend MODE-LINE to the mode line for the duration of the selection."
  (setq aw-action action)
  (let ((start-window (selected-window))
        (next-window-scope (cl-case aw-scope
                             ('visible 'visible)
                             ('global 'visible)
                             ('frame 'frame)))
        (wnd-list (aw-window-list))
        window)
    (setq window
          (cond ((<= (length wnd-list) 1)
                 (when aw-dispatch-always
                   (setq aw-action
                         (unwind-protect
                              (catch 'done
                                (funcall aw-dispatch-function (read-char)))
                           (aw--done)))
                   (when (eq aw-action 'exit)
                     (setq aw-action nil)))
                 (or (car wnd-list) start-window))
                ((and (<= (+ (length wnd-list) (if (aw-ignored-p start-window) 1 0))
                          aw-dispatch-when-more-than)
                      (not aw-dispatch-always)
                      (not aw-ignore-current))
                 (let ((wnd (next-window nil nil next-window-scope)))
                   (while (and (or (not (memq wnd wnd-list))
                                   (aw-ignored-p wnd))
                               (not (equal wnd start-window)))
                     (setq wnd (next-window wnd nil next-window-scope)))
                   wnd))
                (t
                 (let ((candidate-list
                        (mapcar (lambda (wnd)
                                  (cons (aw-offset wnd) wnd))
                                wnd-list)))
                   (aw--make-backgrounds wnd-list)
                   (aw-set-mode-line mode-line)
                   ;; turn off helm transient map
                   (remove-hook 'post-command-hook 'helm--maybe-update-keymap)
                   (unwind-protect
                        (let* ((avy-handler-function aw-dispatch-function)
                               (avy-translate-char-function aw-translate-char-function)
                               (transient-mark-mode nil)
                               (res (avy-read (avy-tree candidate-list aw-keys)
                                              (if (and ace-window-display-mode
                                                       (null aw-display-mode-overlay))
                                                  (lambda (_path _leaf))
                                                #'aw--lead-overlay)
                                              #'avy--remove-leading-chars)))
                          (if (listp res)
                              (or (cdr res)
                                  start-window)
                            (setq aw-action nil)))
                     (aw--done))))))
    (if aw-action
        (funcall aw-action window)
      window))))
#+end_src

** /comint/

#+begin_src elisp
(with-eval-after-load 'comint
  ;;;; OVERRIDDEN
  (defun comint-term-environment ()
    (if (and (boundp 'system-uses-terminfo) system-uses-terminfo)
        (list (format "TERM=%s" comint-terminfo-terminal)
              "TERMCAP="
              (format "COLUMNS=%d" (window-width-without-margin)))
      (list "TERM=emacs"
            (format "TERMCAP=emacs:co#%d:tc=unknown:" (window-width-without-margin))))))
#+end_src

** CANC /ellocate/
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
(with-eval-after-load 'ellocate
  (when (bug-check-function-bytecode
         'ellocate
         "CIYFAAkZxcYKIkFAiYMgAMcLIcjJAgQGBiMhsgGCOwDFygwiiYMvAMsBIYiCOADMzSGDOADNIIiIziAphw==")
    (defun ellocate-db ()
      (let* ((config-dir (completing-read
                          "Select folder: "
                          (mapcar 'car ellocate-scan-dirs)
                          nil t))
             (dir (expand-file-name config-dir))
             (search (nth 1 (cl-find-if (lambda (list)
                                          (file-in-directory-p
                                           dir (nth 0 list)))
                                        ellocate-scan-cache))))
        (if search
            (find-file
             (ellocate-completing-read
              dir
              search
              t))
          (ellocate-cache-dir (assoc config-dir ellocate-scan-dirs))
          (find-file
           (ellocate-completing-read
            dir
            (car (cdr (assoc dir ellocate-scan-cache)))
            t)))))

    (defun ellocate (&optional ignore-scope)
      "Displays any files below the current dir.
If IGNORE-SCOPE is non-nil, search the entire database instead of just every
file under the current directory."
      (interactive "P")
      (let ((gc-cons-threshold (or ellocate-gc-mem gc-cons-threshold)))
        (if (equal ignore-scope '(16))
            (ellocate-db)
          (let ((search
                 ;; Load data from cached search corresponding to this default-directory
                 (nth 1 (cl-find-if (lambda (list)
                                      (file-in-directory-p
                                       default-directory (nth 0 list)))
                                    ellocate-scan-cache)))
                (dir (expand-file-name default-directory)))
            (if search
                (find-file
                 (ellocate-completing-read dir search ignore-scope))
              (let ((found-dir (cl-find-if
                                (lambda (list)
                                  (file-in-directory-p dir (nth 0 list)))
                                ellocate-scan-dirs)))
                (if found-dir
                    (progn
                      (ellocate-cache-dir found-dir)
                      (find-file
                       (ellocate-completing-read
                        dir
                        ;; re-search
                        (nth 1 (cl-find-if (lambda (list)
                                             (file-in-directory-p
                                              default-directory (nth 0 list)))
                                           ellocate-scan-cache))
                        ignore-scope)))
                  (if (fboundp 'counsel-file-jump)
                      (counsel-file-jump)
                    (ellocate-db)))))))))))
#+end_src

** /eshell/

#+begin_src elisp
(with-eval-after-load 'em-cmpl
  ;;;; OVERRIDDEN
  (defun eshell-complete-parse-arguments ()
    "Parse the command line arguments for `pcomplete-argument'."
    (when (and eshell-no-completion-during-jobs
               (eshell-interactive-process))
      ;; (insert-and-inherit "\t") ;; -
      (throw 'pcompleted t))
    (let ((end (point-marker))
          (begin (save-excursion (eshell-bol) (point)))
          (posns (list t))
          args delim)
      (when (memq this-command '(pcomplete-expand
                                 pcomplete-expand-and-complete))
        (run-hook-with-args 'eshell-expand-input-functions begin end)
        (if (= begin end)
            (end-of-line))
        (setq end (point-marker)))
      (if (setq delim
                (catch 'eshell-incomplete
                  (ignore
                   (setq args (eshell-parse-arguments begin end)))))
          (cond ((memq (car delim) '(?\{ ?\<))
                 (setq begin (1+ (cadr delim))
                       args (eshell-parse-arguments begin end)))
                ((eq (car delim) ?\()
                 (eshell-complete-lisp-symbol)
                 (throw 'pcompleted t))
                (t
                 ;; (insert-and-inherit "\t") ;; -
                 (throw 'pcompleted t))))
      (when (get-text-property (1- end) 'comment)
        ;; (insert-and-inherit "\t") ;; -
        (throw 'pcompleted t))
      (let ((pos begin))
        (while (< pos end)
          (if (get-text-property pos 'arg-begin)
              (nconc posns (list pos)))
          (setq pos (1+ pos))))
      (setq posns (cdr posns))
      (cl-assert (= (length args) (length posns)))
      (let ((a args)
            (i 0)
            l)
        (while a
          (if (and (consp (car a))
                   (eq (caar a) 'eshell-operator))
              (setq l i))
          (setq a (cdr a) i (1+ i)))
        (and l
             (setq args (nthcdr (1+ l) args)
                   posns (nthcdr (1+ l) posns))))
      (cl-assert (= (length args) (length posns)))
      (when (and args (eq (char-syntax (char-before end)) ? )
                 (not (eq (char-before (1- end)) ?\\)))
        (nconc args (list ""))
        (nconc posns (list (point))))
      (cons (mapcar
             (lambda (arg)
               (let ((val
                      (if (listp arg)
                          (let ((result
                                 (eshell-do-eval
                                  (list 'eshell-commands arg) t)))
                            (cl-assert (eq (car result) 'quote))
                            (cadr result))
                        arg)))
                 (if (numberp val)
                     (setq val (number-to-string val)))
                 (or val "")))
             args)
            posns))))

(with-eval-after-load 'em-hist
  (defun end-of-buffer-advice (&rest _args)
    (end-of-buffer))
  (advice-add 'eshell-previous-matching-input-from-input :before 'end-of-buffer-advice))

(with-eval-after-load 'em-term
  ;;;; OVERRIDDEN
  (defun eshell-exec-visual (&rest args)
    "Run the specified PROGRAM in a terminal emulation buffer.
 ARGS are passed to the program.  At the moment, no piping of input is
 allowed."
    (let* (eshell-interpreter-alist
           (original-args args)
           (interp (eshell-find-interpreter (car args) (cdr args)))
           (in-ssh-tramp (and (tramp-tramp-file-p default-directory)
                              (equal (tramp-file-name-method
                                      (tramp-dissect-file-name default-directory))
                                     "ssh")))
           (program (if in-ssh-tramp
                        "ssh"
                      (car interp)))
           (args (if in-ssh-tramp
                     (let ((dir-name (tramp-dissect-file-name default-directory)))
                       (eshell-flatten-list
                        (list
                         "-t"
                         (tramp-file-name-host dir-name)
                         (format
                          "export TERM=xterm-256color; cd %s; exec %s"
                          (tramp-file-name-localname dir-name)
                          (string-join
                           (append
                            (list (tramp-file-name-localname (tramp-dissect-file-name (car interp))))
                            (cdr args))
                           " ")))))
                   (eshell-flatten-list
                    (eshell-stringify-list (append (cdr interp)
                                                   (cdr args))))))
           (term-buf
            (generate-new-buffer
             (concat "*"
                     (if in-ssh-tramp
                         (format "%s %s" default-directory (string-join original-args " "))
                       (file-name-nondirectory program))
                     "*")))
           (eshell-buf (current-buffer)))
      (save-current-buffer
        (switch-to-buffer term-buf)
        (term-mode)
        (set (make-local-variable 'term-term-name) eshell-term-name)
        (make-local-variable 'eshell-parent-buffer)
        (setq eshell-parent-buffer eshell-buf)
        (term-exec term-buf program program nil args)
        (let ((proc (get-buffer-process term-buf)))
          (if (and proc (eq 'run (process-status proc)))
              (set-process-sentinel proc 'eshell-term-sentinel)
            (error "Failed to invoke visual command")))
        (term-char-mode)
        (if eshell-escape-control-x
            (term-set-escape-char ?\C-x))))
    nil))
#+end_src

** /find-dired/

#+begin_src elisp
(with-eval-after-load 'find-dired
  ;;;; OVERRIDDEN
  (defun find-dired (dir args)
  "Run `find' and go into Dired mode on a buffer of the output.
The command run (after changing into DIR) is essentially

    find . \\( ARGS \\) -ls

except that the car of the variable `find-ls-option' specifies what to
use in place of \"-ls\" as the final argument.

Collect output in the \"*Find*\" buffer.  To kill the job before
it finishes, type \\[kill-find]."
  (interactive (list (read-directory-name "Run find in directory: " nil "" t)
                     (read-string "Run find (with args): " find-args
                                  '(find-args-history . 1))))
  (let ((dired-buffers dired-buffers))
    ;; Expand DIR ("" means default-directory), and make sure it has a
    ;; trailing slash.
    (setq dir (file-name-as-directory (expand-file-name dir)))
    ;; Check that it's really a directory.
    (or (file-directory-p dir)
        (error "find-dired needs a directory: %s" dir))
    (pop-to-buffer-same-window (get-buffer-create "*Find*"))

    ;; See if there's still a `find' running, and offer to kill
    ;; it first, if it is.
    (let ((find (get-buffer-process (current-buffer))))
      (when find
        (if (or (not (eq (process-status find) 'run))
                (yes-or-no-p
                 (format-message "A `find' process is running; kill it? ")))
            (condition-case nil
                (progn
                  (interrupt-process find)
                  (sit-for 1)
                  (delete-process find))
              (error nil))
          (error "Cannot have two processes in `%s' at once" (buffer-name)))))

    (widen)
    (kill-all-local-variables)
    (setq buffer-read-only nil)
    (erase-buffer)
    (setq default-directory dir
          find-args args              ; save for next interactive call
          args (concat find-program " . ! -readable -prune -o "
                       (if (string= args "")
                           ""
                         (concat
                          (shell-quote-argument "(")
                          " " args " "
                          (shell-quote-argument ")")
                          " "))
                       (if (string-match "\\`\\(.*\\) {} \\(\\\\;\\|\\+\\)\\'"
                                         (car find-ls-option))
                           (format "%s %s %s"
                                   (match-string 1 (car find-ls-option))
                                   (shell-quote-argument "{}")
                                   find-exec-terminator)
                         (car find-ls-option))))
    ;; Start the find process.
    (shell-command (concat args "&") (current-buffer))
    (dired-mode dir (cdr find-ls-option))
    (let ((map (make-sparse-keymap)))
      (set-keymap-parent map (current-local-map))
      (define-key map "\C-c\C-k" 'kill-find)
      (use-local-map map))
    (setq-local dired-sort-inhibit t)
    (setq-local revert-buffer-function
                `(lambda (ignore-auto noconfirm)
                   (find-dired ,dir ,find-args)))
    ;; Set subdir-alist so that Tree Dired will work:
    (if (fboundp 'dired-simple-subdir-alist)
        ;; will work even with nested dired format (dired-nstd.el,v 1.15
        ;; and later)
        (dired-simple-subdir-alist)
      ;; else we have an ancient tree dired (or classic dired, where
      ;; this does no harm)
      (setq-local dired-subdir-alist
                  (list (cons default-directory (point-min-marker)))))
    (setq-local dired-subdir-switches find-ls-subdir-switches)
    (setq buffer-read-only nil)
    ;; Subdir headlerline must come first because the first marker in
    ;; subdir-alist points there.
    (insert "  " dir ":\n")
    ;; Make second line a ``find'' line in analogy to the ``total'' or
    ;; ``wildcard'' line.
    (let ((point (point)))
      (insert "  " args "\n")
      (dired-insert-set-properties point (point)))
    (setq buffer-read-only t)
    (let ((proc (get-buffer-process (current-buffer))))
      (set-process-filter proc #'find-dired-filter)
      (set-process-sentinel proc #'find-dired-sentinel)
      ;; Initialize the process marker; it is used by the filter.
      (move-marker (process-mark proc) (point) (current-buffer)))
    (setq mode-line-process '(":%s")))))
#+end_src

** CANC /ido-completing-read+/
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
(with-eval-after-load 'ido-completing-read+
  (when (bug-check-function-bytecode
         'ido-completing-read@ido-cr+-replace
         "CMIgWYQLAAmEEADDAgIih8PEAiKH")
    (defun ido-completing-read@ido-cr+-replace (orig-fun prompt choices &optional
                                                         predicate require-match
                                                         initial-input hist def
                                                         inherit-input-method)
      "This advice allows ido-cr+ to completely replace `ido-completing-read'.

See the varaible `ido-cr+-replace-completely' for more information."
      (if (or (ido-cr+-active)
              (not ido-cr+-replace-completely))
          ;; ido-cr+ has either already activated or isn't going to
          ;; activate, so just run the function as normal
          (if def
              (let ((result (funcall orig-fun prompt choices predicate require-match
                                     initial-input hist def inherit-input-method)))
                (if (or (null result)
                        (and (seqp result)
                             (= 0 (length result))))
                    def
                  result))
           (funcall orig-fun prompt choices predicate require-match
                    initial-input hist def inherit-input-method))
        ;; Otherwise, we need to activate ido-cr+.
        (funcall #'ido-completing-read+ prompt choices predicate require-match
                 initial-input hist def inherit-input-method))))

  (when (bug-check-function-bytecode
         'ido-completing-read+
         "BgcGBwYHBgcGBwYHBgcGB68IGMYJIQQ6gyAABECCOAAEO4MpAASCOAAEhDEAx4I4AMjJygYHRCLLGgs/hUgAzAYJIYVIAAYIHMsdDINdAM3OIYNdAM7P0CEhgl4A0B5ADINyAM3OIYNyAM7P0SEhgnMA0R5BDkI/y9IxBQUEg4sADkODiwDI09QiiMwGCyGDqgHVBgshg7IABgo5g6wAyNPW1wYOIkMiiIKyAMjT2EMiiAGE3gDZBgshg94ABgo5g8sA1toGDCKCzADbyw5EhdkA3N3eBFADI7YD37ICBgiDqgEFhKoBDkXL38sDOoN+AQNAsgMCg3MBAjmDNAECBg89hGkB4DEQAc8DITCCEgGIy+ExHgHPBhAhMIIgAYjLiYUvAQGFLwHPAiHPAiE9toKCZgECO4NTAQYOOYNzAQLiBhAhy98eRuMDAwMjKbaDgmYB5OUERA5EhWMB3N3eBFADI7YDy4NzAQKyAcuJsgOCdAHfg34BA0GyBILsAAE/hYQBibaEg6oBBgo5g5cB1uYGDCKCmAHnyw5EhaUB3N3eBFADI7YD37IBDIO5AQ5AAwYMBgwjgsAB0ccGDAYMI7ILBgpH6FWD0wEMhNMByNPpIogOR4PrAQYKRw5HVoPrAcjT1uoORyJDIojrIIMiBA5IDklEywE6g/MCAUCyAdUBIYMMAsjT7ANEIogDhCoC2QEhgyoC7QFDDkSFJQLc3d4EUAMjtgPfsgQGCoPsAgYHhOwCAoTsAg5Fy9/LAzqDzQIDQLIDAoPCAgI5g4QCAgU9hLgC7jFgAs8DITCCYgKIy+8xbgLPBgYhMIJwAojLiYV/AgGFfwLPAiHPAiE9toKCtQICO4OiAgQ5g8ICAuIGBiHL3x5G4wMDAyMptoOCtQLk5QREDkSFsgLc3d4EUAMjtgPLg8ICArIBy4myA4LDAt+DzQIDQbIEgj0CAT+F0wKJtoSD7ALwAUMORIXnAtzd3gRQAyO2A9+yAwFBsgKC9gG2AvHL8gLzIkFAsgGJgyAEzwEh9D6EIATVASGDIwPI0wI5gx8D1vUEIoIgA/ZDIogDhEwD2QEhg0wDiTmDOQPW9wIigjoD+MsORIVHA9zd3gRQAyO2A9+yBAYKgxkEBgeEGQQChBkEDkXL38sDOoPvAwNAsgMCg+QDAjmDpgMCBT2E2gP5MYIDzwMhMIKEA4jL+jGQA88GBiEwgpIDiMuJhaEDAYWhA88CIc8CIT22goLXAwI7g8QDBDmD5AMC4gYGIcvfHkbjAwMDIym2g4LXA+TlBEQORIXUA9zd3gRQAyO2A8uD5AMCsgHLibIDguUD34PvAwNBsgSCXwMBP4X1A4m2hIMZBIk5gwYE1vsCIoIHBPzLDkSFFATc3d4EUAMjtgPfsgMBVLICgvcCtgIBhCwEyNP9QyKIBgiDYAQFhGAEiYNMBP7LDkSFRwTc3d4EUAMjtgOCYAT/yw5EhVoE3N3eBFADI7YDx0OyBgU8hGkEBUOyBgWDjgSBUQCBUgDWgVMAIgYHIrIGgVQAgVUABgcGDSIhsgvLsgYOSoOtBIFWAA5LgVcAIoOtBMcGC52DrQTI04FYACKIBgc6g8gEgVYADkuBWQAig8gEBgeJAUFUobYCgVoAIFTL38sbHkweTR5OgVsAjoFcAAYMBgwGDAYMBgwGDAYMBgwmCC0OT4FdAD2DAQXI04FeACKIMII/BQTLGxmJDkSFNQWJPIMgBYlA0z2DIAWJQUCyAYFfAA5QAkQORIUzBdzd3gRQAyO2grYC3A5QCCIqsgEuBoc=")
    (defun ido-completing-read+ (prompt collection &optional predicate
                                        require-match initial-input
                                        hist def inherit-input-method)
      "ido-based method for reading from the minibuffer with completion.

See `completing-read' for the meaning of the arguments.

This function is a wrapper for `ido-completing-read' designed to
be used as the value of `completing-read-function'. Importantly,
it detects edge cases that ido cannot handle and uses normal
completion for them."
      (let* (;; Save the original arguments in case we need to do the
             ;; fallback
             (ido-cr+-orig-completing-read-args
              (list prompt collection predicate require-match
                    initial-input hist def inherit-input-method))
             ;; Need to save a copy of this since activating the
             ;; minibuffer once will clear out any temporary minibuffer
             ;; hooks, which need to get restored before falling back so
             ;; that they will trigger again when the fallback function
             ;; uses the minibuffer. We make a copy in case the original
             ;; list gets modified in place.
             (orig-minibuffer-setup-hook (cl-copy-list minibuffer-setup-hook))
             ;; Need just the string part of INITIAL-INPUT
             (initial-input-string
              (cond
               ((consp initial-input)
                (car initial-input))
               ((stringp initial-input)
                initial-input)
               ((null initial-input)
                "")
               (t
                (signal 'wrong-type-argument (list 'stringp initial-input)))))
             (ido-cr+-active-restrictions nil)
             ;; If collection is a function, save it for later, unless
             ;; instructed not to
             (ido-cr+-dynamic-collection
              (when (and (not ido-cr+-assume-static-collection)
                         (functionp collection))
                collection))
             (ido-cr+-last-dynamic-update-text nil)
             ;; Only memoize if the collection is dynamic.
             (ido-cr+-all-prefix-completions-memoized
              (if (and ido-cr+-dynamic-collection (featurep 'memoize))
                  (memoize (indirect-function 'ido-cr+-all-prefix-completions))
                'ido-cr+-all-prefix-completions))
             (ido-cr+-all-completions-memoized
              (if (and ido-cr+-dynamic-collection (featurep 'memoize))
                  (memoize (indirect-function 'all-completions))
                'all-completions))
             ;; If the whitelist is empty, everything is whitelisted
             (whitelisted (not ido-cr+-function-whitelist))
             ;; If non-nil, we need alternate nil DEF handling
             (alt-nil-def nil))
        (condition-case sig
            (progn
              ;; Check a bunch of fallback conditions
              (when (and inherit-input-method current-input-method)
                (signal 'ido-cr+-fallback
                        '("ido cannot handle alternate input methods")))

              ;; Check for black/white-listed collection function
              (when (functionp collection)
                ;; Blacklist
                (when (ido-cr+-function-is-blacklisted collection)
                  (if (symbolp collection)
                      (signal 'ido-cr+-fallback
                              (list (format "collection function `%S' is blacklisted" collection)))
                    (signal 'ido-cr+-fallback
                            (list "collection function is blacklisted"))))
                ;; Whitelist
                (when (and (not whitelisted)
                           (ido-cr+-function-is-whitelisted collection))
                  (ido-cr+--debug-message
                   (if (symbolp collection)
                       (format "Collection function `%S' is whitelisted" collection)
                     "Collection function is whitelisted"))
                  (setq whitelisted t))
                ;; nil DEF list
                (when (and
                       require-match (null def)
                       (ido-cr+-function-is-in-list
                        collection
                        ido-cr+-nil-def-alternate-behavior-list))
                  (ido-cr+--debug-message
                   (if (symbolp collection)
                       (format "Using alternate nil DEF handling for collection function `%S'" collection)
                     "Using alternate nil DEF handling for collection function"))
                  (setq alt-nil-def t)))

              ;; Expand all currently-known completions.
              (setq collection
                    (if ido-cr+-dynamic-collection
                        (funcall ido-cr+-all-prefix-completions-memoized
                                 initial-input-string collection predicate)
                      (all-completions "" collection predicate)))
              ;; No point in using ido unless there's a collection
              (when (and (= (length collection) 0)
                         (not ido-cr+-dynamic-collection))
                (signal 'ido-cr+-fallback '("ido is not needed for an empty collection")))
              ;; Check for excessively large collection
              (when (and ido-cr+-max-items
                         (> (length collection) ido-cr+-max-items))
                (signal 'ido-cr+-fallback
                        (list
                         (format
                          "there are more than %i items in COLLECTION (see `ido-cr+-max-items')"
                          ido-cr+-max-items))))

              ;; If called from `completing-read', check for
              ;; black/white-listed commands/callers
              (when (ido-cr+--called-from-completing-read)
                ;; Check calling command and `ido-cr+-current-command'
                (cl-loop
                 for cmd in (list this-command ido-cr+-current-command)

                 if (ido-cr+-function-is-blacklisted cmd)
                 do (signal 'ido-cr+-fallback
                            (list "calling command `%S' is blacklisted" cmd))

                 if (and (not whitelisted)
                         (ido-cr+-function-is-whitelisted cmd))
                 do (progn
                      (ido-cr+--debug-message "Command `%S' is whitelisted" cmd)
                      (setq whitelisted t))

                 if (and
                     require-match (null def) (not alt-nil-def)
                     (ido-cr+-function-is-in-list
                      cmd ido-cr+-nil-def-alternate-behavior-list))
                 do (progn
                      (ido-cr+--debug-message
                       "Using alternate nil DEF handling for command `%S'" cmd)
                      (setq alt-nil-def t)))

                ;; Check every function in the call stack starting after
                ;; `completing-read' until to the first
                ;; `funcall-interactively' (for a call from the function
                ;; body) or `call-interactively' (for a call from the
                ;; interactive form, in which the function hasn't actually
                ;; been called yet, so `funcall-interactively' won't be on
                ;; the stack.)
                (cl-loop for i upfrom 1
                         for caller = (cadr (backtrace-frame i 'completing-read))
                         while caller
                         while (not (memq (indirect-function caller)
                                          '(internal--funcall-interactively
                                            (indirect-function 'call-interactively))))

                         if (ido-cr+-function-is-blacklisted caller)
                         do (signal 'ido-cr+-fallback
                                    (list (if (symbolp caller)
                                              (format "calling function `%S' is blacklisted" caller)
                                            "a calling function is blacklisted")))

                         if (and (not whitelisted)
                                 (ido-cr+-function-is-whitelisted caller))
                         do (progn
                              (ido-cr+--debug-message
                               (if (symbolp caller)
                                   (format "Calling function `%S' is whitelisted" caller)
                                 "A calling function is whitelisted"))
                              (setq whitelisted t))

                         if (and require-match (null def) (not alt-nil-def)
                                 (ido-cr+-function-is-in-list
                                  caller ido-cr+-nil-def-alternate-behavior-list))
                         do (progn
                              (ido-cr+--debug-message
                               (if (symbolp caller)
                                   (format "Using alternate nil DEF handling for calling function `%S'" caller)
                                 "Using alternate nil DEF handling for a calling function"))
                              (setq alt-nil-def t))))

              (unless whitelisted
                (signal 'ido-cr+-fallback
                        (list "no functions or commands matched the whitelist for this call")))

              (when (and require-match (null def))
                ;; Replace nil with "" for DEF if match is required, unless
                ;; alternate nil DEF handling is enabled
                (if alt-nil-def
                    (ido-cr+--debug-message
                     "Leaving the default at nil because alternate nil DEF handling is enabled.")
                  (ido-cr+--debug-message
                   "Adding \"\" as the default completion since no default was provided.")
                  (setq def (list ""))))

              ;; In ido, the semantics of "default" are simply "put it at
              ;; the front of the list". Furthermore, ido can't handle a
              ;; list of defaults, nor can it handle both DEF and
              ;; INITIAL-INPUT being non-nil. So, just pre-process the
              ;; collection to put the default(s) at the front and then
              ;; set DEF to nil in the call to ido to avoid these issues.
              (unless (listp def)
                ;; Ensure DEF is a list
                (setq def (list def)))
              (when def
                ;; Ensure DEF are strings
                (setq def (mapcar (apply-partially #'format "%s") def))
                ;; Prepend DEF to COLLECTION and remove duplicates
                (setq collection (delete-dups (append def collection))
                      ;; def nil))     ;; -
                      def (car def)))  ;; +

              ;; Check for a specific bug
              (when (and ido-enable-dot-prefix
                         (version< emacs-version "26.1")
                         (member "" collection))
                (signal 'ido-cr+-fallback
                        '("ido cannot handle the empty string as an option when `ido-enable-dot-prefix' is non-nil; see https://debbugs.gnu.org/cgi/bugreport.cgi?bug=26997")))

              ;; Fix ido's broken handling of cons-style INITIAL-INPUT on
              ;; Emacsen older than 27.1.
              (when (and (consp initial-input)
                         (version< emacs-version "27.1"))
                ;; `completing-read' uses 0-based index while
                ;; `read-from-minibuffer' uses 1-based index.
                (cl-incf (cdr initial-input)))

              ;; Finally ready to do actual ido completion
              (prog1
                  (let ((ido-cr+-minibuffer-depth (1+ (minibuffer-depth)))
                        (ido-cr+-dynamic-update-timer nil)
                        (ido-cr+-exhibit-pending t)
                        ;; Reset this for recursive calls to ido-cr+
                        (ido-cr+-assume-static-collection nil))
                    (unwind-protect
                        (ido-completing-read
                         prompt collection
                         predicate require-match initial-input hist def
                         inherit-input-method)
                      (when ido-cr+-dynamic-update-timer
                        (cancel-timer ido-cr+-dynamic-update-timer)
                        (setq ido-cr+-dynamic-update-timer nil))))
                ;; This detects when the user triggered fallback mode
                ;; manually.
                (when (eq ido-exit 'fallback)
                  (signal 'ido-cr+-fallback '("user manually triggered fallback")))))

          ;; Handler for ido-cr+-fallback signal
          (ido-cr+-fallback
           (let (;; Reset `minibuffer-setup-hook' to original value
                 (minibuffer-setup-hook orig-minibuffer-setup-hook)
                 ;; Reset this for recursive calls to ido-cr+
                 (ido-cr+-assume-static-collection nil))
             (ido-cr+--explain-fallback sig)
             (apply ido-cr+-fallback-function ido-cr+-orig-completing-read-args))))))))
#+end_src

** /magit-log/

#+begin_src elisp
(with-eval-after-load 'magit-log
  (require 'magit-wip))
#+end_src

** /ox-odt/

#+begin_src elisp
(with-eval-after-load 'ox-odt
  ;;;; OVERRIDDEN
  (defun org-odt-verbatim (verbatim contents info)
    "Transcode a VERBATIM object from Org to ODT.
CONTENTS is nil.  INFO is a plist used as a communication
channel."
    (format "<text:span text:style-name=\"%s\">%s</text:span>"
            "OrgVerbatim" (org-odt--encode-plain-text
                           (org-element-property :value verbatim)))))
#+end_src

** CANC /posframe/
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
(with-eval-after-load 'posframe
  (when (bug-check-function-bytecode
         'posframe-show
         "xAHFIkFAxALGIkFAxAPHIkFAxATIIkFAxAXJIkFAxAYGyiJBQMQGB8siQUDEBgjMIkFAxAYJzSJBQMQGCs4iQUDEBgvPIkFAxAYM0CJBQMQGDdEiQUDEBg7SIkFAxAYP0yJBQMQGENQiQUDEBhHVIkFAxAYS1iJBQMQGE9ciQUDEBhTYIkFAxAYV2SJBQMQGFtoiQUDEBhfbIkFAxAYY3CJBQMQGGd0iQUDEBhreIkFAxAYb3yJBQAgGHcYGHCOGwwBgCAYexwYcIwgGH8gGHCMIBiDJBhwjCAYhygYcI4bjAOAIBiLLBhwjhu4A4AgGI8wGHCOG+QDhCAYkzQYcI4YEAeEIBiXOBhwjCAYmzwYcIwgGJ9AGHCMIBijRBhwjCAYp0gYcIwgGKtMGHCMIBivUBhwjCAYs1QYcIwgGLdYGHCMIBi7XBhwjCAYv2AYcIwgGMNkGHCMIBjHaBhwjCAYy2wYcIwgGM9wGHCMIBjTdBhwjCAY13gYcIwgGNt8GHCPiBjch4yDkASHlAiHmAyHnBCEGH6iDowHoBiAGBiKCpQEGH+kGBiHqASHrAiHsIHLtBgohcYjuBiUhKe8g5/AgIfEGDSHy8yGD0gHzIILTAeH0GfVyBhBxiAqE7QEGGfIBIYPsAYkgiPQSiPYGEdIGIfcGDs4GKc8GKtAGK9EGLNMGLNQGLdkGKtoGK9UGMtYGM9sGMN4GLyYdsgH4AfnhI4j6BgoCIoj7BkYGGiKI/AEGKQYoBiwGKyWI/QH+xgYu/wYQxwYxgUAABg+BQQAGEoFCAAYOgUMA6gYRIYFEAOsGEyGBRQAGJPcGH4FGAAYggUcABiGBSAAGK4FJAAYsgUoABi2BSwAGLoFMAAYvgU0ABiqBTgAGK4FPAAYsgVAABi3MBlLNBlOvLiEGCwYLJIiBUQABBhYiiIFSAAEGFQYqBikGLQYsJgaIgVMAgVQACyHhIoiBVQALIYjtBhAhgVYAASH4C4FXAAYWI4j4C4FYAAMFQiO2Ayq2qoc=")
    (cl-defun posframe-show (buffer-or-name
                             &key
                             string
                             position
                             poshandler
                             width
                             height
                             min-width
                             min-height
                             x-pixel-offset
                             y-pixel-offset
                             left-fringe
                             right-fringe
                             internal-border-width
                             internal-border-color
                             font
                             foreground-color
                             background-color
                             respect-header-line
                             respect-mode-line
                             initialize
                             no-properties
                             keep-ratio
                             lines-truncate
                             override-parameters
                             timeout
                             refresh
                             accept-focus
                             hidehandler
                             &allow-other-keys)
      "Pop up a posframe and show STRING at POSITION.

POSITION can be:
1. An integer, meaning point position.
2. A cons of two integers, meaning absolute X and Y coordinates.
3. Other type, in which case the corresponding POSHANDLER should be
   provided.

POSHANDLER is a function of one argument returning an actual
position.  Its argument is a plist of the following form:

  (:position xxx
   :position-info xxx
   :poshandler xxx
   :font-height xxx
   :font-width xxx
   :posframe xxx
   :posframe-width xxx
   :posframe-height xxx
   :posframe-buffer xxx
   :parent-frame xxx
   :parent-window-left xxx
   :parent-window-top xxx
   :parent-frame-width xxx
   :parent-frame-height xxx
   :parent-window xxx
   :parent-window-width  xxx
   :parent-window-height xxx
   :minibuffer-height
   :mode-line-height
   :header-line-height
   :tab-line-height
   :x-pixel-offset xxx
   :y-pixel-offset xxx)

By default, poshandler is auto-selected based on the type of POSITION,
but the selection can be overridden using the POSHANDLER argument.
The builtin poshandler functions are listed below:

1.  `posframe-poshandler-frame-center'
2.  `posframe-poshandler-frame-top-center'
3.  `posframe-poshandler-frame-top-left-corner'
4.  `posframe-poshandler-frame-top-right-corner'
5.  `posframe-poshandler-frame-bottom-center'
6.  `posframe-poshandler-frame-bottom-left-corner'
7.  `posframe-poshandler-frame-bottom-right-corner'
8.  `posframe-poshandler-window-center'
9.  `posframe-poshandler-window-top-center'
10. `posframe-poshandler-window-top-left-corner'
11. `posframe-poshandler-window-top-right-corner'
12. `posframe-poshandler-window-bottom-center'
13. `posframe-poshandler-window-bottom-left-corner'
14. `posframe-poshandler-window-bottom-right-corner'
15. `posframe-poshandler-point-top-left-corner'
16. `posframe-poshandler-point-bottom-left-corner'
17. `posframe-poshandler-point-bottom-left-corner-upward'

This posframe's buffer is BUFFER-OR-NAME, which can be a buffer
or a name of a (possibly nonexistent) buffer.

If NO-PROPERTIES is non-nil, The STRING's properties will
be removed before being shown in posframe.

WIDTH, MIN-WIDTH, HEIGHT and MIN-HEIGHT, specify bounds on the
new total size of posframe.  MIN-HEIGHT and MIN-WIDTH default to
the values of ‘window-min-height’ and ‘window-min-width’
respectively.  These arguments are specified in the canonical
character width and height of posframe.

If LEFT-FRINGE or RIGHT-FRINGE is a number, left fringe or
right fringe with be shown with the specified width.

By default, posframe shows no borders, but users can specify
borders by setting INTERNAL-BORDER-WIDTH to a positive number.
Border color can be specified by INTERNAL-BORDER-COLOR
or via the ‘internal-border’ face.

Posframe's font as well as foreground and background colors are
derived from the current frame by default, but can be overridden
using the FONT, FOREGROUND-COLOR and BACKGROUND-COLOR arguments,
respectively.

By default, posframe will display no header-line, mode-line and
tab-line.  In case a header-line, mode-line or tab-line is
desired, users can set RESPECT-HEADER-LINE and RESPECT-MODE-LINE
to t.

INITIALIZE is a function with no argument.  It will run when
posframe buffer is first selected with `with-current-buffer'
in `posframe-show', and only run once (for performance reasons).

If LINES-TRUNCATE is non-nil, then lines will truncate in the
posframe instead of wrap.

OVERRIDE-PARAMETERS is very powful, *all* the frame parameters
used by posframe's frame can be overridden by it.

TIMEOUT can specify the number of seconds after which the posframe
will auto-hide.

If REFRESH is a number, posframe's frame-size will be re-adjusted
every REFRESH seconds.

When ACCEPT-FOCUS is non-nil, posframe will accept focus.
be careful, you may face some bugs when set it to non-nil.

HIDEHANDLER is a function, when it return t, posframe will be
hide when `post-command-hook' is executed, this function has a
plist argument:

  (:posframe-buffer xxx
   :posframe-parent-buffer xxx)

The builtin hidehandler functions are listed below:

1. `posframe-hidehandler-when-buffer-switch'


You can use `posframe-delete-all' to delete all posframes."
      (let* ((position (or (funcall posframe-arghandler buffer-or-name :position position) (point)))
             (poshandler (funcall posframe-arghandler buffer-or-name :poshandler poshandler))
             (width (funcall posframe-arghandler buffer-or-name :width width))
             (height (funcall posframe-arghandler buffer-or-name :height height))
             (min-width (or (funcall posframe-arghandler buffer-or-name :min-width min-width) 1))
             (min-height (or (funcall posframe-arghandler buffer-or-name :min-height min-height) 1))
             (x-pixel-offset (or (funcall posframe-arghandler buffer-or-name :x-pixel-offset x-pixel-offset) 0))
             (y-pixel-offset (or (funcall posframe-arghandler buffer-or-name :y-pixel-offset y-pixel-offset) 0))
             (left-fringe (funcall posframe-arghandler buffer-or-name :left-fringe left-fringe))
             (right-fringe (funcall posframe-arghandler buffer-or-name :right-fringe right-fringe))
             (internal-border-width (funcall posframe-arghandler buffer-or-name :internal-border-width internal-border-width))
             (internal-border-color (funcall posframe-arghandler buffer-or-name :internal-border-color internal-border-color))
             (font (funcall posframe-arghandler buffer-or-name :font font))
             (foreground-color (funcall posframe-arghandler buffer-or-name :foreground-color foreground-color))
             (background-color (funcall posframe-arghandler buffer-or-name :background-color background-color))
             (respect-header-line (funcall posframe-arghandler buffer-or-name :respect-header-line respect-header-line))
             (respect-mode-line (funcall posframe-arghandler buffer-or-name :respect-mode-line respect-mode-line))
             (initialize (funcall posframe-arghandler buffer-or-name :initialize initialize))
             (no-properties (funcall posframe-arghandler buffer-or-name :no-properties no-properties))
             (keep-ratio (funcall posframe-arghandler buffer-or-name :keep-ratio keep-ratio))
             (lines-truncate (funcall posframe-arghandler buffer-or-name :lines-truncate lines-truncate))
             (override-parameters (funcall posframe-arghandler buffer-or-name :override-parameters override-parameters))
             (timeout (funcall posframe-arghandler buffer-or-name :timeout timeout))
             (refresh (funcall posframe-arghandler buffer-or-name :refresh refresh))
             (accept-focus (funcall posframe-arghandler buffer-or-name :accept-focus accept-focus))
             (hidehandler (funcall posframe-arghandler buffer-or-name :hidehandler hidehandler))
             ;;-----------------------------------------------------
             (buffer (get-buffer-create buffer-or-name))
             (parent-window (selected-window))
             (parent-window-top (window-pixel-top parent-window))
             (parent-window-left (window-pixel-left parent-window))
             (parent-window-width (window-pixel-width parent-window))
             (parent-window-height (window-pixel-height parent-window))
             (position-info
              (if (integerp position)
                  (posn-at-point position parent-window)
                position))
             (parent-frame (window-frame parent-window))
             (parent-frame-width (frame-pixel-width parent-frame))
             (parent-frame-height (frame-pixel-height parent-frame))
             (font-width (default-font-width))
             (font-height (with-current-buffer (window-buffer parent-window)
                            (posframe--get-font-height position)))
             (mode-line-height (window-mode-line-height))
             (minibuffer-height (window-pixel-height (minibuffer-window)))
             (header-line-height (window-header-line-height parent-window))
             (tab-line-height (if (functionp 'window-tab-line-height)
                                  (window-tab-line-height)
                                0))
             (frame-resize-pixelwise t)
             posframe)

        (with-current-buffer buffer

          ;; Initialize
          (unless posframe--initialized-p
            (let ((func initialize))
              (when (functionp func)
                (funcall func)
                (setq posframe--initialized-p t))))

          ;; Create posframe
          (setq posframe
                (posframe--create-posframe
                 buffer
                 :font font
                 :parent-frame parent-frame
                 :left-fringe left-fringe
                 :right-fringe right-fringe
                 :internal-border-width internal-border-width
                 :internal-border-color internal-border-color
                 :foreground-color foreground-color
                 :background-color background-color
                 :keep-ratio keep-ratio
                 :lines-truncate lines-truncate
                 :respect-header-line respect-header-line
                 :respect-mode-line respect-mode-line
                 :override-parameters override-parameters
                 :accept-focus accept-focus))

          ;; Remove tab-bar always.
          (set-frame-parameter posframe 'tab-bar-lines 0)

          ;; Move mouse to (0 . 0)
          (posframe--mouse-banish parent-frame posframe)

          ;; Insert string into the posframe buffer
          (posframe--insert-string string no-properties)

          ;; Set posframe's size
          (posframe--set-frame-size
           posframe height min-height width min-width)

          ;; Move posframe
          (posframe--set-frame-position
           posframe
           (posframe-run-poshandler
            ;; All poshandlers will get info from this plist.
            (list :position position
                  :position-info position-info
                  :poshandler poshandler
                  :font-height font-height
                  :font-width font-width
                  :posframe posframe
                  :posframe-width (frame-pixel-width posframe)
                  :posframe-height (frame-pixel-height posframe)
                  :posframe-buffer buffer
                  :parent-frame parent-frame
                  :parent-frame-width parent-frame-width
                  :parent-frame-height parent-frame-height
                  :parent-window parent-window
                  :parent-window-top parent-window-top
                  :parent-window-left parent-window-left
                  :parent-window-width parent-window-width
                  :parent-window-height parent-window-height
                  :mode-line-height mode-line-height
                  :minibuffer-height minibuffer-height
                  :header-line-height header-line-height
                  :tab-line-height tab-line-height
                  :x-pixel-offset x-pixel-offset
                  :y-pixel-offset y-pixel-offset))
           parent-frame-width parent-frame-height)

          ;; Delay hide posframe when timeout is a number.
          (posframe--run-timeout-timer posframe timeout)

          ;; Re-adjust posframe's size when buffer's content has changed.
          (posframe--run-refresh-timer
           posframe refresh height min-height width min-width)

          ;; Make sure not hide buffer's content for scroll down.
          (let ((window (frame-root-window posframe--frame)))
            (if (window-live-p window)
                (set-window-point window 0)))

          ;; Force raise the current posframe.
          (raise-frame posframe--frame)

          ;; Hide posframe when switch buffer
          (let* ((parent-buffer (window-buffer parent-window))
                 (parent-buffer-name (buffer-name parent-buffer)))
            (set-frame-parameter posframe--frame 'posframe-hidehandler hidehandler)
            (set-frame-parameter posframe--frame 'posframe-parent-buffer
                                 (cons parent-buffer-name parent-buffer)))

          ;; Return posframe
          posframe)))))
#+end_src

** CANC /simple/
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
(with-eval-after-load 'simple
  (when (bug-check-function-bytecode
         'repeat-complex-command
         "iVMIOMUBgzQAxQPGIFQZGhvHjsjJygQhDMvABghCJSyyAczAAiKIzc4CQM/QBUEiI4JCAAiDPwDR0gQigkIA0dMhhw==")
    (defun repeat-complex-command (arg)
      "Edit and re-evaluate last complex command, or ARGth from last.
A complex command is one that used the minibuffer.
The command is placed in the minibuffer as a Lisp form for editing.
The result is executed, repeating the command as changed.
If the command has been changed or is not the most recent previous
command it is added to the front of the command history.
You can use the minibuffer history commands \
\\<minibuffer-local-map>\\[next-history-element] and \\[previous-history-element]
to get different commands to edit and resubmit."
      (interactive "p")
      (let ((elt (nth (1- arg) command-history))
            newcmd)
        (if elt
            (progn
              (setq newcmd
                    (let ((print-level nil)
                          (minibuffer-completing-symbol t)
                          (minibuffer-history-position arg)
                          (minibuffer-history-sexp-flag (1+ (minibuffer-depth))))
                      (unwind-protect
                          (minibuffer-with-setup-hook
                              (lambda ()
                                ;; FIXME: call emacs-lisp-mode (see also
                                ;; `eldoc--eval-expression-setup')?
                                (add-hook 'completion-at-point-functions
                                          #'elisp-completion-at-point nil t)
                                (run-hooks 'eval-expression-minibuffer-setup-hook))
                            (read-from-minibuffer
                             "Redo: " (prin1-to-string elt) read-expression-map t
                             (cons 'command-history arg)))

                        ;; If command was added to command-history as a
                        ;; string, get rid of that.  We want only
                        ;; evaluable expressions there.
                        (when (stringp (car command-history))
                          (pop command-history)))))

              (add-to-history 'command-history newcmd)
              (apply #'funcall-interactively
                     (car newcmd)
                     (mapcar (lambda (e) (eval e t)) (cdr newcmd))))
          (if command-history
              (error "Argument %d is beyond length of command history" arg)
            (error "There are no previous complex commands to repeat")))))))
#+end_src

** /virtualenvwrapper/

#+begin_src elisp
(with-eval-after-load 'virtualenvwrapper
  (eval-when-compile
    (require 'virtualenvwrapper))
  ;;;; OVERRIDDEN
  (defun venv-mkvirtualenv-using (interpreter &rest names)
    "Create new virtualenvs NAMES using INTERPRETER. If venv-location
is a single directory, the new virtualenvs are made there; if it
is a list of directories, the new virtualenvs are made in the
current `default-directory'."
    (interactive '(nil))
    (venv--check-executable)
    (let* ((interpreter (if (or current-prefix-arg
                                (null interpreter))
                            (read-string "Python executable: ")
                          interpreter))
           (parent-dir (if (stringp venv-location)
                           (file-name-as-directory
                            (expand-file-name venv-location))
                         default-directory))
           (python-exe-arg (when interpreter
                             (concat "--python=" interpreter)))
           (names (if names names
                    (list (read-from-minibuffer "New virtualenv: ")))))
      ;; map over all the envs we want to make
      (--each names
        ;; error if this env already exists
        (when (-contains? (venv-get-candidates) it)
          (error "A virtualenv with this name already exists!"))
        (run-hooks 'venv-premkvirtualenv-hook)
        (shell-command (concat venv-virtualenv-command " " python-exe-arg " " parent-dir it))
        (when (listp venv-location)
          (add-to-list 'venv-location (concat parent-dir it)))
        (venv-with-virtualenv it
                              (run-hooks 'venv-postmkvirtualenv-hook))
        (when (called-interactively-p 'interactive)
          (message (concat "Created virtualenv: " it))))
      ;; workon the last venv we made
      (venv-workon (car (last names))))))
#+end_src

** /whitespace/

#+begin_src elisp
;; (move-to-column arg t) problems with whitespace-mode
(with-eval-after-load 'whitespace
  (defun avoid-whitespace-mode-advice (orig-fun column &optional force)
    (if (and force
             (< (current-column) column)
             (bound-and-true-p whitespace-mode))
        (prog2
            (call-interactively #'whitespace-mode)
            (funcall orig-fun column force)
          (call-interactively #'whitespace-mode))
      (funcall orig-fun column force)))

  (advice-add 'move-to-column :around #'avoid-whitespace-mode-advice))
#+end_src

** CANC /exwm/
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
(with-eval-after-load 'exwm-manage
  (when (bug-check-function-bytecode
         'exwm-manage--manage-window
         "CIMUAMbHCYMPAAkgghAAyMkEJIjKMlIDywrMCs3OzwYH0AvR0iAmByIigzIA08rUIojVCs3W1wzPBgclIohy2B3Z2iEpcYgOQAFwQkOkFkDbIIiJFkEOQhZD3AEhiN0BIYjeASGI3wEhiOABIYjhASGI4gEhiOMBIYjkASGI5SAWROYOROcihH8B6A5E5yKEyQAORYOlAOkORQ5GDkcOSEUig8kADkmEfwEOSoR/AQ5LhMkADkyEyQAORg5FPoTJAA5HDkU+g38BCIPdAMbqCYPYAAkggtkAyMkEJIgOTQ5FPoPpAOsBIYjVCs3OzwXQC9EOTQ5FPoP/ANIgggEBDk4mByKI1QrN7M8FIyKIDk8OUA5FPoNJAQ5R7Q5DIZyJ7kgB70gC8EgD8UjyBgcFBPMGCvQiWvClXAUE8wYL9SJa8KVc9okltgaIDlIORT6DZQGJFlPVCs33zwXQDlT4DlUmByKI+QohiPoBDkAiFkD22B0eVvtwIYgq08r8IojmDkT9IomDlgGJDldHV4OWAQ5XAZwWQ4gIg6sBxv4Jg6YBCSCCpwHIyQQkiNUKzffPBdAOWP/uJgciiA5ZDloOW0WJgwICiUDVCs2BZwCBaADugWkABgnRDlyBagAOXYFrAA5egWwADl+BbQAOYIFuAAYTgW8ADmEmEyKIAUG2goLBAYiBcAAgiPkKIYjoDkSBcQAig18C5g5EgXEAIoMpAoFyAAEhiIK6AoFzAIF0AA5DISFygXUA7oF2AIF3AIF4AAUhgXkAIvAkjoF6AAFAgXsAIoiBfAACIYgqiIK6Ag5ihIcCDkuEfgIOTIR+Ag5GDkU+hH4CDkcORT6DhwKBcgABIYiCugKBcwCBdAAOQyEhcoF1AO6BdgCBdwCBeAAFIYF9ACLwJI6BegABQIF7ACKIgXwAAiGIKojmDkSBfgAig80CgX8AASGIgtMCgYAAASGI5g5EgYEAIuYORIGCACJyAoGDAAEOQCJBsgFxiAGD+QKBhAACIYiJgwgDgYUAgWMAIYiJFmMptgLYFmSBhgABIYiBhwABIYhyiYGDAAEOQCJBsgFxiOYORIGIACKEOQOBiQAgg0kDgYoADmUOZiIWZoGLAAEhiIGMAIGNACEqMIc=")
    (eval-and-compile
      (require 'exwm-core))
    (defun exwm-manage--manage-window (id)
      "Manage window ID."
      (exwm--log "Try to manage #x%x" id)
      (catch 'return
        ;; Ensure it's alive
        (when (xcb:+request-checked+request-check exwm--connection
                  (make-instance 'xcb:ChangeWindowAttributes
                                 :window id :value-mask xcb:CW:EventMask
                                 :event-mask (exwm--get-client-event-mask)))
          (throw 'return 'dead))
        ;; Add this X window to save-set.
        (xcb:+request exwm--connection
            (make-instance 'xcb:ChangeSaveSet
                           :mode xcb:SetMode:Insert
                           :window id))
        (with-current-buffer (let ((exwm-input--skip-buffer-list-update t))
                               (generate-new-buffer "*EXWM*"))
          ;; Keep the oldest X window first.
          (setq exwm--id-buffer-alist
                (nconc exwm--id-buffer-alist `((,id . ,(current-buffer)))))
          (exwm-mode)
          (setq exwm--id id
                exwm--frame exwm-workspace--current)
          (exwm--update-window-type id)
          (exwm--update-class id)
          (exwm--update-transient-for id)
          (exwm--update-normal-hints id)
          (exwm--update-hints id)
          (exwm-manage--update-geometry id)
          (exwm-manage--update-mwm-hints id)
          (exwm--update-title id)
          (exwm--update-protocols id)
          (setq exwm--configurations (exwm-manage--get-configurations))
          ;; OverrideRedirect is not checked here.
          (when (and
                 ;; The user has specified to manage it.
                 (not (plist-get exwm--configurations 'managed))
                 (or
                  ;; The user has specified not to manage it.
                  (plist-member exwm--configurations 'managed)
                  ;; This is not a type of X window we can manage.
                  (and exwm-window-type
                       (not (cl-intersection
                             exwm-window-type
                             (list xcb:Atom:_NET_WM_WINDOW_TYPE_UTILITY
                                   xcb:Atom:_NET_WM_WINDOW_TYPE_DIALOG
                                   xcb:Atom:_NET_WM_WINDOW_TYPE_NORMAL))))
                  ;; Check the _MOTIF_WM_HINTS property to not manage floating X
                  ;; windows without decoration.
                  (and (not exwm--mwm-hints-decorations)
                       (not exwm--hints-input)
                       ;; Floating windows only
                       (or exwm-transient-for exwm--fixed-size
                           (memq xcb:Atom:_NET_WM_WINDOW_TYPE_UTILITY
                                 exwm-window-type)
                           (memq xcb:Atom:_NET_WM_WINDOW_TYPE_DIALOG
                                 exwm-window-type)))))
            (exwm--log "No need to manage #x%x" id)
            ;; Update struts.
            (when (memq xcb:Atom:_NET_WM_WINDOW_TYPE_DOCK exwm-window-type)
              (exwm--update-struts id))
            ;; Remove all events
            (xcb:+request exwm--connection
                (make-instance 'xcb:ChangeWindowAttributes
                               :window id :value-mask xcb:CW:EventMask
                               :event-mask
                               (if (memq xcb:Atom:_NET_WM_WINDOW_TYPE_DOCK
                                         exwm-window-type)
                                   ;; Listen for PropertyChange (struts) and
                                   ;; UnmapNotify/DestroyNotify event of the dock.
                                   (exwm--get-client-event-mask)
                                 xcb:EventMask:NoEvent)))
            ;; The window needs to be mapped
            (xcb:+request exwm--connection
                (make-instance 'xcb:MapWindow :window id))
            (with-slots (x y width height) exwm--geometry
              ;; Center window of type _NET_WM_WINDOW_TYPE_SPLASH
              (when (memq xcb:Atom:_NET_WM_WINDOW_TYPE_SPLASH exwm-window-type)
                (let* ((workarea (elt exwm-workspace--workareas
                                      (exwm-workspace--position exwm--frame)))
                       (x* (aref workarea 0))
                       (y* (aref workarea 1))
                       (width* (aref workarea 2))
                       (height* (aref workarea 3)))
                  (exwm--set-geometry id
                                      (+ x* (/ (- width* width) 2))
                                      (+ y* (/ (- height* height) 2))
                                      nil
                                      nil))))
            ;; Check for desktop.
            (when (memq xcb:Atom:_NET_WM_WINDOW_TYPE_DESKTOP exwm-window-type)
              ;; There should be only one desktop X window.
              (setq exwm-manage--desktop id)
              ;; Put it at bottom.
              (xcb:+request exwm--connection
                  (make-instance 'xcb:ConfigureWindow
                                 :window id
                                 :value-mask xcb:ConfigWindow:StackMode
                                 :stack-mode xcb:StackMode:Below)))
            (xcb:flush exwm--connection)
            (setq exwm--id-buffer-alist (assq-delete-all id exwm--id-buffer-alist))
            (let ((kill-buffer-query-functions nil)
                  (exwm-input--skip-buffer-list-update t))
              (kill-buffer (current-buffer)))
            (throw 'return 'ignored))
          (let ((index (plist-get exwm--configurations 'workspace)))
            (when (and index (< index (length exwm-workspace--list)))
              (setq exwm--frame (elt exwm-workspace--list index))))
          ;; Manage the window
          (exwm--log "Manage #x%x" id)
          (xcb:+request exwm--connection    ;remove border
              (make-instance 'xcb:ConfigureWindow
                             :window id :value-mask xcb:ConfigWindow:BorderWidth
                             :border-width 0))
          (dolist (button       ;grab buttons to set focus / move / resize
                   (list xcb:ButtonIndex:1 xcb:ButtonIndex:2 xcb:ButtonIndex:3))
            (xcb:+request exwm--connection
                (make-instance 'xcb:GrabButton
                               :owner-events 0 :grab-window id
                               :event-mask xcb:EventMask:ButtonPress
                               :pointer-mode xcb:GrabMode:Sync
                               :keyboard-mode xcb:GrabMode:Async
                               :confine-to xcb:Window:None :cursor xcb:Cursor:None
                               :button button :modifiers xcb:ModMask:Any)))
          (exwm-manage--set-client-list)
          (xcb:flush exwm--connection)
          (if (plist-member exwm--configurations 'floating)
              ;; User has specified whether it should be floating.
              (if (plist-get exwm--configurations 'floating)
                  (exwm-floating--set-floating id)
                ;; [ <FIXED>
                (select-window (frame-selected-window exwm--frame))
                (exwm-floating--unset-floating id)
                ;; ] <FIXED>  
                )
            ;; Try to determine if it should be floating.
            (if (and (not exwm-manage-force-tiling)
                     (or exwm-transient-for exwm--fixed-size
                         (memq xcb:Atom:_NET_WM_WINDOW_TYPE_UTILITY
                               exwm-window-type)
                         (memq xcb:Atom:_NET_WM_WINDOW_TYPE_DIALOG
                               exwm-window-type)))
                (exwm-floating--set-floating id)
              ;; [ <FIXED>
              (select-window (frame-selected-window exwm--frame))
              (exwm-floating--unset-floating id)
              ;; ] <FIXED>
              ))
          (if (plist-get exwm--configurations 'char-mode)
              (exwm-input-release-keyboard id)
            (exwm-input-grab-keyboard id))
          (let ((simulation-keys (plist-get exwm--configurations 'simulation-keys))
                (prefix-keys (plist-get exwm--configurations 'prefix-keys)))
            (with-current-buffer (exwm--id->buffer id)
              (when simulation-keys
                (exwm-input-set-local-simulation-keys simulation-keys))
              (when prefix-keys
                (setq-local exwm-input-prefix-keys prefix-keys))))
          (setq exwm-workspace--switch-history-outdated t)
          (exwm--update-desktop id)
          (exwm-manage--update-ewmh-state id)
          (with-current-buffer (exwm--id->buffer id)
            (when (or (plist-get exwm--configurations 'fullscreen)
                      (exwm-layout--fullscreen-p))
              (setq exwm--ewmh-state (delq xcb:Atom:_NET_WM_STATE_FULLSCREEN
                                           exwm--ewmh-state))
              (exwm-layout-set-fullscreen id))
            (run-hooks 'exwm-manage-finish-hook)))))))
#+end_src

** CANC /xelb/
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
(with-eval-after-load 'xcb
  ;;;; OVERRIDDEN
  (defun xcb:-connection-filter (process message)
    "Filter function for an X connection.

Concurrency is disabled as it breaks the orders of errors, replies and events."
    (let* ((connection (plist-get (process-plist process) 'connection))
           ;; Temporarily disable GC here as typically it's about to do
           ;; lots of marshaling/unmarshaling.
           (cache (vconcat (slot-value connection 'message-cache) message))
           (cache-length (length cache)))
      (setf (slot-value connection 'message-cache) cache)
      (unless (slot-value connection 'lock)
        ;; Start parsing message
        (setf (slot-value connection 'lock) t)
        ;; Process error/reply/event
        (catch 'break
          (while (<= 32 (length cache))
            (pcase (aref cache 0)
              (0                          ;error
               (xcb:-log "Error received: %s" (substring cache 0 32))
               (let ((sequence (funcall (if xcb:lsb #'xcb:-unpack-u2-lsb
                                          #'xcb:-unpack-u2)
                                        cache 2))
                     (plist (slot-value connection 'error-plist))
                     struct)
                 (setq sequence (xcb:-convert-sequence connection sequence))
                 (when (plist-member plist sequence)
                   (setq struct (plist-get plist sequence))
                   (setf (slot-value connection 'error-plist)
                         (plist-put plist sequence
                                    (push `(,(aref cache 1) .
                                            ,(substring cache 0 32))
                                          struct))))
                 (setq cache (substring cache 32))
                 (setf (slot-value connection 'last-seen-sequence) sequence)))
              (1                          ;reply
               (let* ((reply-words (funcall (if xcb:lsb #'xcb:-unpack-u4-lsb
                                              #'xcb:-unpack-u4)
                                            cache 4))
                      (reply-length (+ 32 (* 4 reply-words)))
                      struct sequence plist)
                 (when (< (length cache) reply-length) ;too short, do next time
                   (throw 'break nil))
                 (xcb:-log "Reply received: %s" (substring cache 0 reply-length))
                 (setq sequence (funcall (if xcb:lsb #'xcb:-unpack-u2-lsb
                                           #'xcb:-unpack-u2)
                                         cache 2)
                       sequence (xcb:-convert-sequence connection sequence))
                 (setq plist (slot-value connection 'reply-plist))
                 (setq struct (plist-get plist sequence))
                 (when struct
                   (setf (slot-value connection 'reply-plist)
                         (plist-put plist sequence
                                    (if (symbolp struct)
                                        ;; Single reply or
                                        ;; first reply for multiple replies
                                        (list struct
                                              (substring cache 0 reply-length))
                                      ;; Multiple replies
                                      `(,(car struct) ,@(cdr struct)
                                        ,(substring cache 0 reply-length))))))
                 (setq cache (substring cache reply-length))
                 (setf (slot-value connection 'last-seen-sequence) sequence)))
              (x                          ;event
               (let (synthetic listener event-length)
                 (when (/= 0 (logand x #x80)) ;synthetic event
                   (setq synthetic t
                         x (logand x #x7f))) ;low 7 bits is the event number
                 (setq listener
                       (plist-get (slot-value connection 'event-plist) x))
                 (pcase listener
                   (`xge
                    (setq event-length (funcall (if xcb:lsb
                                                    #'xcb:-unpack-u4-lsb
                                                  #'xcb:-unpack-u4)
                                                cache 4)
                          ;; event-length indicates additional words to the
                          ;; first 32 bytes.
                          event-length (+ 32 (* 4 event-length)))
                    (when (< (length cache) event-length)
                      ;; Too short.
                      (throw 'break nil))
                    (setq listener
                          (lax-plist-get (slot-value connection 'event-plist)
                                         (vector (aref cache 1)
                                                 (funcall
                                                  (if xcb:lsb
                                                      #'xcb:-unpack-u2-lsb
                                                    #'xcb:-unpack-u2)
                                                  cache 8)))))
                   (`xkb
                    (setq listener
                          (lax-plist-get (slot-value connection 'event-plist)
                                         (vector (aref cache 1))))))
                 ;; Conventional events are 32 bytes in size.
                 (unless event-length
                   (setq event-length 32))
                 (when listener
                   (with-slots (event-queue) connection
                     (setf event-queue (nconc event-queue
                                              `([,listener
                                                 ,(substring cache 0
                                                             event-length)
                                                 ,synthetic])))))
                 (xcb:-log "Event received: %s" (substring cache 0 event-length))
                 (setq cache (substring cache event-length)))))))
        (setf (slot-value connection 'lock) nil))
      (unless (slot-value connection 'lock)
        (with-slots (message-cache) connection
          (let ((current-cache-length (length message-cache)))
            (setf message-cache
                  (substring message-cache (- cache-length (length cache))))
            (when (/= current-cache-length cache-length)
              (xcb:-connection-filter process []))))
        (xcb:-process-events connection)))))
#+end_src

** CANC /orderless/
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
(with-eval-after-load 'orderless
;;;; OVERRIDDEN
  (defun orderless-try-completion (string table pred point &optional _metadata)
    "Complete STRING to unique matching entry in TABLE.
This uses `orderless-all-completions' to find matches for STRING
in TABLE among entries satisfying PRED.  If there is only one
match, it completes to that match.  If there are no matches, it
returns nil.  In any other case it \"completes\" STRING to
itself, without moving POINT.
This function is part of the `orderless' completion style."
    (let ((all (orderless-filter string table pred)))
      (cond
       ((null all) nil)
       ((null (cdr all))
        (let ((full (concat
                     (car (orderless--prefix+pattern string table pred))
                     (car all))))
          (cons full (length full))))
       (t
        (completion-flex-try-completion string table pred point))))))
#+end_src

** /emms/

#+begin_src elisp
(with-eval-after-load 'emms-volume-pulse
;;;; OVERRIDDEN
  (defun emms-volume--pulse-get-volume ()
    "Return `emms-volume-pulse-sink' volume."
    (let ((sink-number-p (numberp emms-volume-pulse-sink))
          (output
           (shell-command-to-string
            (concat "LC_ALL=C pactl list sinks" "|"
                    "grep -E -e 'Sink' -e 'Name' -e '^[^a-zA-Z]*Volume'"))))
      (string-to-number
       (car
        (reverse
         (funcall
          (if sink-number-p #'assq #'assoc)
          emms-volume-pulse-sink
          (mapcar (if sink-number-p 'identity 'cdr)
                  (cl-loop while
                           (string-match
                            (mapconcat #'identity
                                       '(".*Sink[ \t]+\\#\\([0-9]+\\)"
                                         ".*Name:[ \t]\\([^\n]+\\)"
                                         ".*Volume:.*?\\([0-9]+\\)%.*\n?")
                                       "\n")
                            output)
                           collect (list (string-to-number (match-string 1 output))
                                         (match-string 2 output)
                                         (match-string 3 output))
                           do (setq output (replace-match "" nil nil output))))))))))
;;;; OVERRIDDEN
  (defun emms-volume-pulse-change (amount)
    "Change PulseAudio volume by AMOUNT."
    (let ((pactl (or (executable-find "pactl")
                     (error "pactl is not in PATH"))))
      (shell-command
       (format "%s set-sink-volume %s %s%s%%"
               pactl emms-volume-pulse-sink (if (> 0 amount "" "+")) amount)))))
#+end_src

** /ox-mediawiki/                                                     :markdown:

#+begin_src elisp
(with-eval-after-load 'ox-mediawiki
  (defun org-mw-src-block (block contents info)
    (concat
     "<syntaxhighlight lang=\""
     (org-element-property :language block)
     "\">\n"
     (org-element-property :value block)
     "</syntaxhighlight>"))

  (setcdr (assoc 'src-block (org-export-get-all-transcoders 'mw))
          'org-mw-src-block)
  (defun org-mw-link (link contents info)
    (let ((--link-org-files-as-html-maybe
           (function
            (lambda (raw-path info)
              ;; Treat links to `file.org' as links to `file.html', if
              ;; needed.  See `org-html-link-org-files-as-html'.
              (cond
               ((and org-html-link-org-files-as-html
                     (string= ".org"
                              (downcase (file-name-extension raw-path "."))))
                (concat (file-name-sans-extension raw-path) "."
                        (plist-get info :html-extension)))
               (t raw-path)))))
          (type (org-element-property :type link)))
      (cond ((member type '("custom-id" "id"))
             (let ((destination (org-export-resolve-id-link link info)))
               (if (stringp destination)	; External file.
                   (let ((path (funcall --link-org-files-as-html-maybe
                                        destination info)))
                     (if (not contents) (format "<%s>" path)
                       (format "[%s](%s)" contents path)))
                 (concat
                  (and contents (concat contents " "))
                  (format "(%s)"
                          (format
                           (org-export-translate "See section %s" :html info)
                           (mapconcat 'number-to-string
                                      (org-export-get-headline-number
                                       destination info)
                                      ".")))))))
            ((org-export-inline-image-p link org-html-inline-image-rules)
             (let ((path (let ((raw-path (org-element-property :path link)))
                           (if (not (file-name-absolute-p raw-path)) raw-path
                             (expand-file-name raw-path)))))
               (format "![%s](%s)"
                       (let ((caption (org-export-get-caption
                                       (org-export-get-parent-element link))))
                         (when caption (org-export-data caption info)))
                       path)))
            ((string= type "coderef")
             (let ((ref (org-element-property :path link)))
               (format (org-export-get-coderef-format ref contents)
                       (org-export-resolve-coderef ref info))))
            ((equal type "radio")
             (let ((destination (org-export-resolve-radio-link link info)))
               (org-export-data (org-element-contents destination) info)))
            ((equal type "fuzzy")
             (if (org-string-nw-p contents) contents
               (concat "[[#" (replace-regexp-in-string
                              "^\*+ *" ""
                              (org-element-property :raw-link link)
                              t)
                       "]]")))
            (t (let* ((raw-path (org-element-property :path link))
                      (path (cond
                             ((member type '("http" "https" "ftp"))
                              (concat type ":" raw-path))
                             ((equal type "file")
                              ;; Treat links to ".org" files as ".html",
                              ;; if needed.
                              (setq raw-path
                                    (funcall --link-org-files-as-html-maybe
                                             raw-path info))
                              ;; If file path is absolute, prepend it
                              ;; with protocol component - "file://".
                              (if (not (file-name-absolute-p raw-path)) raw-path
                                (concat "file://" (expand-file-name raw-path))))
                             (t raw-path))))
                 (if (not contents) (format "%s" path)
                   (format "[%s %s]" path
                           (s-join " " (s-split "\n" contents)))))))))

  (defun org-mw-separate-elements (tree backend info)
    (org-element-map tree org-element-all-elements
      (lambda (elem)
        (unless (memq (org-element-type elem) '(org-data item))
          (org-element-put-property
           elem :post-blank
           (let ((post-blank (org-element-property :post-blank elem)))
             (if (not post-blank) 1 (max 1 post-blank)))))))
    ;; Return updated tree.
    tree))
#+end_src

** CANC /org-babel/
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

Included /-T/ argument in alacritty

#+begin_src elisp
(with-eval-after-load 'ob-screen
;;;; OVERRIDDEN
  (defun org-babel-prep-session:screen (_session params)
    "Prepare SESSION according to the header arguments specified in PARAMS."
    (let* ((session (cdr (assq :session params)))
           (cmd (cdr (assq :cmd params)))
           (terminal (cdr (assq :terminal params)))
           (screenrc (cdr (assq :screenrc params)))
           (process-name (concat "org-babel: terminal (" session ")")))
      (apply 'start-process process-name "*Messages*"
             terminal `(,(if (string-equal terminal "alacritty") "-t" "-T") ,(concat "org-babel: " session) "-e" ,org-babel-screen-location
                        "-c" ,screenrc "-mS" ,session ,cmd))
      ;; XXX: Is there a better way than the following?
      (while (not (org-babel-screen-session-socketname session))
        ;; wait until screen session is available before returning
        ))))
#+end_src
alacritty (-T org-babel: apiproxy -e screen -c /dev/null -mS apiproxy bash)

* Improvements
** CANC /vertico-mode/
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
(with-eval-after-load 'vertico-grid
  (defun vertico-grid--arrange-candidates ()
    "Arrange candidates."
    (when (<= vertico--index 0)
      (let ((cand vertico--candidates) (w 1) (n 0))
        (while (and cand (< n vertico-grid-lookahead))
          (setq w (max w (length (car cand))) n (1+ n))
          (pop cand))
        (setq vertico-grid--columns
              (max 1 (min vertico-grid-max-columns
                          (floor (window-width) (+ w (length vertico-grid-separator))))))))
    (let* ((sep (length vertico-grid-separator))
           (count (* vertico-grid-rows vertico-grid--columns))
           (start (* count (floor (max 0 vertico--index) count)))
           (width (- (/ (window-width) vertico-grid--columns) sep))
           (cands
            (seq-map-indexed (lambda (cand index)
                               (setq cand (mapconcat 'identity cand " ")) ;; +
                               (cl-incf index start)
                               ;; (when (string-match-p "\n" cand) ;; -
                               ;;   (setq cand (vertico--truncate-multiline cand width))) ;; -
                               (truncate-string-to-width
                                (string-trim
                                 (replace-regexp-in-string
                                  "[ \t]+"
                                  (lambda (x) (apply #'propertize " " (text-properties-at 0 x)))
                                  (vertico--format-candidate cand "" "" index start)))
                                width))
                             (vertico--affixate ;; +
                              (funcall vertico--highlight-function
                                       (seq-subseq vertico--candidates start
                                                   (min (+ start count)
                                                        vertico--total)))
                              ) ;; +
                             ))
           (width (make-vector vertico-grid--columns 0)))
      (dotimes (col vertico-grid--columns)
        (dotimes (row vertico-grid-rows)
          (aset width col (max
                           (aref width col)
                           (string-width (or (nth (+ row (* col vertico-grid-rows)) cands) ""))))))
      (dotimes (col (1- vertico-grid--columns))
        (cl-incf (aref width (1+ col)) (+ (aref width col) sep)))
      (cl-loop for row from 0 to (1- vertico-grid-rows) collect
               (let ((line (list "\n")))
                 (cl-loop for col from (1- vertico-grid--columns) downto 0 do
                          (when-let (cand (nth (+ row (* col vertico-grid-rows)) cands))
                            (push cand line)
                            (when (> col 0)
                              (push vertico-grid-separator line)
                              (push (propertize " " 'display
                                                `(space :align-to (+ left ,(aref width (1- col))))) line))))
                 (string-join line))))))
#+end_src

** CANC Completions
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
;;;; OVERRIDDEN
(require 'dash)
(defun completion-metadata-get (metadata prop)
  (or (cdr (assq prop metadata))
      (when (eq prop 'display-sort-function)
        (when-let ((history (minibuffer-history-value)))
          `(lambda (completions)
             (let* ((common 
                     (let (result)
                       (mapc
                        (lambda (candidate)
                          (when-let ((it (car (member candidate completions))))
                            (add-face-text-property
                              0 (length it)
                              '(:weight ultra-bold :foreground "#00B4AB") nil it)
                            (push
                             it
                             result)))
                        (quote ,history))
                       (nreverse result)))
                    (rest (-difference completions common)))
               (nconc common (sort rest 'string-lessp))))))))
#+end_src

** /flymake/

#+begin_src elisp
(with-eval-after-load 'flymake
  ;; custom modeline
  (if (fboundp 'flymake--mode-line-title)
      (progn
        (defun flymake--mode-line-title ()
          `(:propertize
            "!"
            mouse-face mode-line-highlight
            help-echo
            ,(lambda (&rest _)
               (concat
                (format "%s known backends\n" (hash-table-count flymake--state))
                (format "%s running\n" (length (flymake-running-backends)))
                (format "%s disabled\n" (length (flymake-disabled-backends)))
                "mouse-1: Display minor mode menu\n"
                "mouse-2: Show help for minor mode"))
            keymap
            ,(let ((map (make-sparse-keymap)))
               (define-key map [mode-line down-mouse-1]
                 flymake-menu)
               (define-key map [mode-line down-mouse-3]
                 flymake-menu)
               (define-key map [mode-line mouse-2]
                 (lambda ()
                   (interactive)
                   (describe-function 'flymake-mode)))
               map)))

        (defun flymake--mode-line-exception ()
          "Helper for `flymake-mode-line-exception'."
          (pcase-let* ((running) (reported)
                       (`(,ind ,face ,explain)
                        (cond ((zerop (hash-table-count flymake--state))
                               '("?" nil "No known backends"))
                              ((cl-set-difference
                                (setq running (flymake-running-backends))
                                (setq reported (flymake-reporting-backends)))
                               `("…" compilation-mode-line-run
                                 ,(format "Waiting for %s running backend(s)"
                                          (length (cl-set-difference running reported)))))
                              ((and (flymake-disabled-backends) (null running))
                               '("!" compilation-mode-line-run
                                 "All backends disabled"))
                              (t
                               '(nil nil nil)))))
            (when ind
              `(":"
                (:propertize ,ind face ,face
                             help-echo ,explain
                             keymap ,(let ((map (make-sparse-keymap)))
                                       (define-key map [mode-line mouse-1]
                                         'flymake-switch-to-log-buffer)
                                       map)))))))
    (when (bug-check-function-bytecode
           'flymake--mode-line-format
           "CMVDxsfIycrLBgYhzCLNziUDIoiJop+2gs8g0CDRINIgAoUnAAM/0wUEIsbHyNTKywYIIdUi1tclCCKI2Nna29zd3gYNRyLd3wYNRyLd4AYNRyLhUuLjIOQB5QkjiOQB5ucjiImyAa8I6AYIhHMA6YKMAAKDgwDq693sBgZHIkWCjAADg4sA7YKMAO6JQAFBiUABQYlAAUEBBAYHiYW4AO/YAvAF3AYI4uMg5AHx8iOIibIBrwhEQ7aDtocEhsMABgk/P4UIAgXFQ8bHyMnKywYGIcwizc4lAyKIiaKftoLzxQE6g/oAAUCyAfQBBPX2JLIDAUGyAoLiAMW2gvcC+PX2JMWJiYkEOoPOAQRAsgT5BAYOIrID+gT7/COyAgKEOgEK/T2ExwEKgzYB9gQh/gohWYI3Af2DxwGJ2N3/BgZHIvAF2tvi4yAGDOQCy4FAAAsix4FBAIFCAMrLBgghgUMAIoFEAIFFAIFGACYGI4jkAsuBQAAMIseBQQCBQgDKywYIIYFHACKBRACBRQCBRgAmBiOIAbaC3N2BSACBSQDd/wYRRyLwBhAjgUkA3YFKAAYTIvAGESMj3YFLAAsMI1CvCkOksgEEQbIFggcBgUwA6ALFiYkDOoP9AQOyAwKJQbIEorICAQFCsgECg/YBgU0AAUKyAQNBsgSC1gGJn7aEgU4AIkK2hyJChw==")
      (defun flymake--mode-line-format ()
        "Produce a pretty minor mode indicator."
        (let* ((known (hash-table-keys flymake--backend-state))
               (running (flymake-running-backends))
               (disabled (flymake-disabled-backends))
               (reported (flymake-reporting-backends))
               (diags-by-type (make-hash-table))
               (all-disabled (and disabled (null running)))
               (some-waiting (cl-set-difference running reported)))
          (maphash `(lambda (_b state)
                      (mapc (lambda (diag)
                              (push diag
                                    (gethash (flymake--diag-type diag)
                                             ,diags-by-type)))
                            (flymake--backend-state-diags state)))
                   flymake--backend-state)
          `((:propertize "!"
                         mouse-face mode-line-highlight
                         help-echo
                         ,(concat (format "%s known backends\n" (length known))
                                  (format "%s running\n" (length running))
                                  (format "%s disabled\n" (length disabled))
                                  "mouse-1: Display minor mode menu\n"
                                  "mouse-2: Show help for minor mode")
                         keymap
                         ,(let ((map (make-sparse-keymap)))
                            (define-key map [mode-line down-mouse-1]
                              flymake-menu)
                            (define-key map [mode-line mouse-2]
                              (lambda ()
                                (interactive)
                                (describe-function 'flymake-mode)))
                            map))
            ,@(pcase-let ((`(,ind ,face ,explain)
                           (cond ((null known)
                                  '("?" mode-line "No known backends"))
                                 (some-waiting
                                  `("…" compilation-mode-line-run
                                    ,(format "Waiting for %s running backend(s)"
                                             (length some-waiting))))
                                 (all-disabled
                                  '("!" compilation-mode-line-run
                                    "All backends disabled"))
                                 (t
                                  '(nil nil nil)))))
                (when ind
                  `(((:propertize ,ind
                                  face ,face
                                  help-echo ,explain
                                  keymap
                                  ,(let ((map (make-sparse-keymap)))
                                     (define-key map [mode-line mouse-1]
                                       'flymake-switch-to-log-buffer)
                                     map))))))
            ,@(unless (or all-disabled
                          (null known))
                (cl-loop
                 with types = (hash-table-keys diags-by-type)
                 with _augmented = (cl-loop for extra in '(:error :warning)
                                            do (cl-pushnew extra types
                                                           :key #'flymake--severity))
                 for type in (cl-sort types #'> :key #'flymake--severity)
                 for diags = (gethash type diags-by-type)
                 for face = (flymake--lookup-type-property type
                                                           'mode-line-face
                                                           'compilation-error)
                 when (or diags
                          (cond ((eq flymake-suppress-zero-counters t)
                                 nil)
                                (flymake-suppress-zero-counters
                                 (>= (flymake--severity type)
                                     (warning-numeric-level
                                      flymake-suppress-zero-counters)))
                                (t t)))
                 collect `(:propertize
                           ,(format "%d" (length diags))
                           face ,face
                           mouse-face mode-line-highlight
                           keymap
                           ,(let ((map (make-sparse-keymap))
                                  (type type))
                              (define-key map (vector 'mode-line
                                                      mouse-wheel-down-event)
                                `(lambda (event)
                                   (interactive "e")
                                   (with-selected-window (posn-window (event-start event))
                                     (flymake-goto-prev-error 1 (list ,type) t))))
                              (define-key map (vector 'mode-line
                                                      mouse-wheel-up-event)
                                `(lambda (event)
                                   (interactive "e")
                                   (with-selected-window (posn-window (event-start event))
                                     (flymake-goto-next-error 1 (list ,type) t))))
                              map)
                           help-echo
                           ,(concat (format "%s diagnostics of type %s\n"
                                            (propertize (format "%d"
                                                                (length diags))
                                                        'face face)
                                            (propertize (format "%s" type)
                                                        'face face))
                                    (format "%s/%s: previous/next of this type"
                                            mouse-wheel-down-event
                                            mouse-wheel-up-event)))
                 into forms
                 finally return
                 `((:propertize "{")
                   ,@(cl-loop for (a . rest) on forms by #'cdr
                              collect a when rest collect
                              '(:propertize " "))
                   (:propertize "}"))))))))))
#+end_src

** CANC /icomplete/
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
(with-eval-after-load 'icomplete
;;;; OVERRIDDEN
  (defun icomplete-completions (name candidates predicate require-match)
    "Identify prospective candidates for minibuffer completion.

The display is updated with each minibuffer keystroke during
minibuffer completion.

Prospective completion suffixes (if any) are displayed, bracketed by
one of (), [], or {} pairs.  The choice of brackets is as follows:

  (...) - a single prospect is identified and matching is enforced,
  [...] - a single prospect is identified but matching is optional, or
  {...} - multiple prospects, separated by commas, are indicated, and
          further input is required to distinguish a single one.

If there are multiple possibilities, `icomplete-separator' separates them.

The displays for unambiguous matches have ` [Matched]' appended
\(whether complete or not), or ` [No matches]', if no eligible
matches exist."
    (let* ((ignored-extension-re
            (and minibuffer-completing-file-name
                 icomplete-with-completion-tables
                 completion-ignored-extensions
                 (concat "\\(?:\\`\\.\\./\\|"
                         (regexp-opt completion-ignored-extensions)
                         "\\)\\'")))
           (minibuffer-completion-table candidates)
           (minibuffer-completion-predicate
            (if ignored-extension-re
                (lambda (cand)
                  (and (not (string-match ignored-extension-re cand))
                       (or (null predicate)
                           (funcall predicate cand))))
              predicate))
           (md (completion--field-metadata (icomplete--field-beg)))
           (comps (icomplete--sorted-completions))
           (last (if (consp comps) (last comps)))
           (base-size (cdr last))
           (open-bracket (if require-match "(" "["))
           (close-bracket (if require-match ")" "]")))
      ;; `concat'/`mapconcat' is the slow part.
      (if (not (consp comps))
          (progn ;;(debug (format "Candidates=%S field=%S" candidates name))
            (format " %sNo matches%s" open-bracket close-bracket))
        (if last (setcdr last nil))
        (let* ((most-try
                (if (and base-size (> base-size 0))
                    (completion-try-completion
                     name candidates predicate (length name) md)
                  ;; If the `comps' are 0-based, the result should be
                  ;; the same with `comps'.
                  (completion-try-completion
                   name comps nil (length name) md)))
               (most (if (consp most-try) (car most-try)
                       (if most-try (car comps) "")))
               ;; Compare name and most, so we can determine if name is
               ;; a prefix of most, or something else.
               (compare (compare-strings name nil nil
                                         most nil nil completion-ignore-case))
               (ellipsis (if (char-displayable-p ?…) "…" "..."))
               (determ (unless (or (eq t compare) (eq t most-try)
                                   (= (setq compare (1- (abs compare)))
                                      (length most)))
                         (concat open-bracket
                                 (cond
                                  ((= compare (length name))
                                   ;; Typical case: name is a prefix.
                                   (substring most compare))
                                  ;; Don't bother truncating if it doesn't gain
                                  ;; us at least 2 columns.
                                  ((< compare (+ 2 (string-width ellipsis))) most)
                                  (t (concat ellipsis (substring most compare))))
                                 close-bracket)))
               ;;"-prospects" - more than one candidate
               (prospects-len (+ (string-width
                                  (or determ (concat open-bracket close-bracket)))
                                 (string-width icomplete-separator)
                                 (+ 2 (string-width ellipsis)) ;; take {…} into account
                                 (string-width (buffer-string))))
               (prospects-max
                ;; Max total length to use, including the minibuffer content.
                (* (+ icomplete-prospects-height
                      ;; If the minibuffer content already uses up more than
                      ;; one line, increase the allowable space accordingly.
                      (/ prospects-len (window-width)))
                   (window-width)))
               ;; Find the common prefix among `comps'.
               ;; We can't use the optimization below because its assumptions
               ;; aren't always true, e.g. when completion-cycling (bug#10850):
               ;; (if (eq t (compare-strings (car comps) nil (length most)
               ;;                          most nil nil completion-ignore-case))
               ;;     ;; Common case.
               ;;     (length most)
               ;; Else, use try-completion.
               (prefix (when icomplete-hide-common-prefix
                         (try-completion "" comps)))
               (prefix-len
                (and (stringp prefix)
                     ;; Only hide the prefix if the corresponding info
                     ;; is already displayed via `most'.
                     (string-prefix-p prefix most t)
                     (length prefix))) ;;)
               prospects comp limit)
          (if (or (eq most-try t) (not (consp (cdr comps))))
              (setq prospects nil)
            (when (member name comps)
              ;; NAME is complete but not unique.  This scenario poses
              ;; following UI issues:
              ;;
              ;; - When `icomplete-hide-common-prefix' is non-nil, NAME
              ;;   is stripped empty.  This would make the entry
              ;;   inconspicuous.
              ;;
              ;; - Due to sorting of completions, NAME may not be the
              ;;   first of the prospects and could be hidden deep in
              ;;   the displayed string.
              ;;
              ;; - Because of `icomplete-prospects-height' , NAME may
              ;;   not even be displayed to the user.
              ;;
              ;; To circumvent all the above problems, provide a visual
              ;; cue to the user via an "empty string" in the try
              ;; completion field.
              (setq determ (concat open-bracket "" close-bracket)))
            ;; Compute prospects for display.
            (while (and comps (not limit))
              (setq comp
                    (if prefix-len (substring (car comps) prefix-len) (car comps))
                    comps (cdr comps))
              (setq prospects-len
                    (+ (string-width comp)
                       (string-width icomplete-separator)
                       prospects-len))
              (if (< prospects-len prospects-max)
                  (push comp prospects)
                (setq limit t))))
          (setq prospects (nreverse prospects))
          ;; Decorate first of the prospects.
          (when prospects
            (let ((first (copy-sequence (pop prospects))))
              (add-face-text-property 0 (length first)                  ;; - ;; +
                                      'icomplete-first-match nil first) ;; - ;; +
              (push first prospects)))
          ;; Restore the base-size info, since completion-all-sorted-completions
          ;; is cached.
          (if last (setcdr last base-size))
          (if prospects
              (concat determ
                      (if icomplete-vertical-mode " \n" (propertize "{ " 'face '(:foreground "steel blue"))) ;; - ;; +
                      (mapconcat 'identity prospects (if icomplete-vertical-mode
                                                         "\n"
                                                       icomplete-separator))
                      (unless icomplete-vertical-mode
                        (concat (and limit (concat icomplete-separator ellipsis))
                                (propertize " }" 'face '(:foreground "steel blue"))))) ;; - ;; +
            (concat determ " [Matched]")))))))
#+end_src

** CANC /exwm/
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
(with-eval-after-load 'exwm-layout
  (eval-when-compile
    (require 'exwm-core))
  (when (bug-check-function-bytecode
         'exwm-layout-toggle-fullscreen
         "wzJKAAiDHADExQmDEwAJIIIUAMbHBIYaAMgkiImEKwDJyiGEKwDLw8wiiImFSQByic0BCiJBsgFxiM4gg0UAzwEhgkgA0AEhKTCH")
    (cl-defun exwm-layout-toggle-fullscreen (&optional id)
      "Toggle fullscreen mode."
      (interactive (list (exwm--buffer->id (window-buffer))))
      (exwm--log "id=#x%x" (or id 0))
      (unless (or id (derived-mode-p 'exwm-mode))
        (cl-return-from exwm-layout-toggle-fullscreen))
      (when id
        (with-current-buffer (exwm--id->buffer id)
          (if (exwm-layout--fullscreen-p)
              (progn
                (exwm-randr-refresh)
                (exwm-layout-unset-fullscreen id))
            (let ((exwm-gap-monitor 0))
              (exwm-randr-refresh))
            (delete-other-windows)
            (exwm-layout-set-fullscreen id))))))

  (when (bug-check-function-bytecode
         'exwm-layout-unset-fullscreen
         "xjKcAAiDHADHyAmDEwAJIIIUAMnKBIYaAMskiImEJgDMzSGDKwDOIIQwAM/G0CKIcomDQACJ0QEKIkGyAYJCANIgcYjTCwwiFA2DWADUDiXVDSEiiIKAANYOJtfY2Q4l2tsOJw4oItwOKd0OKiYJIoje0N8iiYN/ANQOJQIiiIjgASGI4Q4mIYji3iDQIogOK+M9hZoA5A4lISkwhw==")
    (cl-defun exwm-layout-unset-fullscreen (&optional id)
      "Restore window from fullscreen state."
      (interactive)
      (exwm--log "id=#x%x" (or id 0))
      (unless (and (or id (derived-mode-p 'exwm-mode))
                   (exwm-layout--fullscreen-p))
        (cl-return-from exwm-layout-unset-fullscreen))
      (with-current-buffer (if id (exwm--id->buffer id) (window-buffer))
        (setq exwm--ewmh-state
              (delq xcb:Atom:_NET_WM_STATE_FULLSCREEN exwm--ewmh-state))
        (if exwm--floating-frame
            (exwm-layout--show exwm--id (frame-root-window exwm--floating-frame))
          (xcb:+request exwm--connection
              (make-instance 'xcb:ConfigureWindow
                             :window exwm--id
                             :value-mask (logior xcb:ConfigWindow:Sibling
                                                 xcb:ConfigWindow:StackMode)
                             :sibling exwm--guide-window
                             :stack-mode xcb:StackMode:Above))
          (let ((window (get-buffer-window nil t)))
            (when window
              (exwm-layout--show exwm--id window))))
        (xcb:+request exwm--connection
            (make-instance 'xcb:ewmh:set-_NET_WM_STATE
                           :window exwm--id
                           :data exwm--ewmh-state))
        (xcb:flush exwm--connection)
        (set-window-dedicated-p (get-buffer-window) nil))))

  (when (bug-check-function-bytecode
         'exwm-layout-set-fullscreen
         "xjKdAAiDHADHyAmDEwAJIIIUAMnKBIYaAMskiImEJgDMzSGDKwDOIIMwAM/G0CKIcomDQACJ0QEKIkGyAYJCANIgcYjTCyHUDNUD1iLVBNci1QXYItUGBtkiJbYC2g3b3N0M3t8OKQ4qIuDL4Q4rJgkiiA4s4gEOLSKDgwAOLYiCiQCJDi1CFi2I4wEhiOQNIYjl5iDnIojoDCEpMIc=")
    (cl-defun exwm-layout-set-fullscreen (&optional id)
      "Make window ID fullscreen."
      (interactive)
      (exwm--log "id=#x%x" (or id 0))
      (unless (and (or id (derived-mode-p 'exwm-mode))
                   (not (exwm-layout--fullscreen-p)))
        (cl-return-from exwm-layout-set-fullscreen))
      (with-current-buffer (if id (exwm--id->buffer id) (window-buffer))
        ;; Expand the X window to fill the whole screen.
        (with-slots (x y width height) (exwm-workspace--get-geometry exwm--frame)
          (exwm--set-geometry exwm--id x y width height))
        ;; Raise the X window.
        (xcb:+request exwm--connection
            (make-instance 'xcb:ConfigureWindow
                           :window exwm--id
                           :value-mask (logior xcb:ConfigWindow:BorderWidth
                                               xcb:ConfigWindow:StackMode)
                           :border-width 0
                           :stack-mode xcb:StackMode:Above))
        (cl-pushnew xcb:Atom:_NET_WM_STATE_FULLSCREEN exwm--ewmh-state)
        (xcb:+request exwm--connection
            (make-instance 'xcb:ewmh:set-_NET_WM_STATE
                           :window exwm--id
                           :data exwm--ewmh-state))
        (exwm-layout--set-ewmh-state id)
        (xcb:flush exwm--connection)
        (set-window-dedicated-p (get-buffer-window) t)))))

(with-eval-after-load 'exwm-randr
  (when (bug-check-function-bytecode
         'exwm-randr-refresh
         "CIMTAMbHCYMPAAkgghAAyMkjiAqDHADKIIIeAMsgicycAc2cAs6cz4kEhRsBA4UbAQuDNwDMEwxHzIkCV4OXAInQDQIi0QEGCSJBDAOc0gHTIgKDYQDRBAYLIkGyBIJuAAYLsgTRBgwGDCJBsgOJ1AUhQkMGCaSyCYkCQkMGCKSyCNUC1gYGI4jVAtcFI7YGiVSyAYI6ALYC2CCIDImDrgCJQNkBIYgBQbaCgp0AiNoOLCGI2yCDwQDcIIPBAN0giN4giAyJg9cAiUDfAc8iiAFBtoKCxQCI4OHiDizjDizk5eYOLSMizyNA5yIhiYMSAYlAiQSeQYmDCgHoAQYGIrIF3wIFnkHpIoiIAUG2goLtAIjaDiwhiOrrIYc=")
    (defun exwm-randr-refresh ()
      "Refresh workspaces according to the updated RandR info."
      (interactive)
      (exwm--log)
      (let* ((result (if exwm-randr--compatibility-mode
                         (exwm-randr--get-outputs)
                       (exwm-randr--get-monitors)))
             (primary-monitor (elt result 0))
             (monitor-geometry-alist (elt result 1))
             (monitor-alias-alist (elt result 2))
             container-monitor-alist container-frame-alist)
        (when (and primary-monitor monitor-geometry-alist)
          (when exwm-workspace--fullscreen-frame-count
            ;; Not all workspaces are fullscreen; reset this counter.
            (setq exwm-workspace--fullscreen-frame-count 0))
          (dotimes (i (exwm-workspace--count))
            (let* ((monitor (plist-get exwm-randr-workspace-monitor-plist i))
                   (geometry (cdr (assoc monitor monitor-geometry-alist)))
                   (frame (elt exwm-workspace--list i))
                   (container (frame-parameter frame 'exwm-container)))
              (if geometry
                  ;; Unify monitor names in case it's a mirroring setup.
                  (setq monitor (cdr (assoc monitor monitor-alias-alist)))
                ;; Missing monitors fallback to the primary one.
                (setq monitor primary-monitor
                      geometry (cdr (assoc primary-monitor
                                           monitor-geometry-alist))))
              (setq container-monitor-alist (nconc
                                             `((,container . ,(intern monitor)))
                                             container-monitor-alist)
                    container-frame-alist (nconc `((,container . ,frame))
                                                 container-frame-alist))
              (set-frame-parameter frame 'exwm-randr-monitor monitor)
              (set-frame-parameter
               frame 'exwm-geometry
               (with-slots (x y width height) geometry
                 (make-instance 'xcb:RECTANGLE
                                :x (and x (+ x exwm-gap-monitor))
                                :y (and y (+ y exwm-gap-monitor))
                                :width (and width
                                            (- width
                                               (* 2 exwm-gap-monitor)))
                                :height (and height
                                             (- height
                                                (* 2 exwm-gap-monitor))))))))
          ;; Update workareas.
          (exwm-workspace--update-workareas)
          ;; Resize workspace.
          (dolist (f exwm-workspace--list)
            (exwm-workspace--set-fullscreen f))
          (xcb:flush exwm--connection)
          ;; Raise the minibuffer if it's active.
          (when (and (active-minibuffer-window)
                     (exwm-workspace--minibuffer-own-frame-p))
            (exwm-workspace--show-minibuffer))
          ;; Set _NET_DESKTOP_GEOMETRY.
          (exwm-workspace--set-desktop-geometry)
          ;; Update active/inactive workspaces.
          (dolist (w exwm-workspace--list)
            (exwm-workspace--set-active w nil))
          ;; Mark the workspace on the top of each monitor as active.
          (dolist (xwin
                   (reverse
                    (slot-value (xcb:+request-unchecked+reply exwm--connection
                                    (make-instance 'xcb:QueryTree
                                                   :window exwm--root))
                                'children)))
            (let ((monitor (cdr (assq xwin container-monitor-alist))))
              (when monitor
                (setq container-monitor-alist
                      (rassq-delete-all monitor container-monitor-alist))
                (exwm-workspace--set-active (cdr (assq xwin container-frame-alist))
                                            t))))
          (xcb:flush exwm--connection)
          (run-hooks 'exwm-randr-refresh-hook))))))
#+end_src

** /org-clock/

#+begin_src elisp
(with-eval-after-load 'org-clock
  (when (bug-check-function-bytecode
         'org-clock-get-clock-string
         "xCAIgy4AxQghxscDIcgJgxoACoQaAMmCGwDKI8cCIcvGzMjKIwMDCyS2g4I5AMvGzcjKI8cDIQsjhw==")
    (defun org-clock-get-clock-string ()
      "Form a clock-string, that will be shown in the mode line.
If an effort estimate was defined for the current item, use
01:30/01:50 format (clocked/estimated).
If not, show simply the clocked time like 01:50."
      (let* ((currently-clocked-time (floor (org-time-convert-to-integer
                                             (org-time-since org-clock-start-time))
                                            60))
             (clocked-time (+ currently-clocked-time (or org-clock-total-time 0))))
        (if org-clock-effort
            (let* ((effort-in-minutes (org-duration-to-minutes org-clock-effort))
                   (work-done-str
                    (propertize (org-duration-from-minutes clocked-time)
                                'face
                                (if (and org-clock-task-overrun
                                         (not org-clock-task-overrun-text))
                                    'org-mode-line-clock-overrun
                                  'org-mode-line-clock)))
                   (effort-str (org-duration-from-minutes effort-in-minutes)))
              (if (equal currently-clocked-time clocked-time)
                  (format (propertize "[%s/%s %s]" 'face 'org-mode-line-clock)
                          work-done-str effort-str org-clock-heading)
                (format (propertize "[%s|%s/%s %s]" 'face 'org-mode-line-clock)
                        (org-duration-from-minutes currently-clocked-time)
                        work-done-str effort-str org-clock-heading)))
          (if (equal currently-clocked-time clocked-time)
              (format (propertize "[%s %s]" 'face 'org-mode-line-clock)
                      (org-duration-from-minutes clocked-time)
                      org-clock-heading)
            (format (propertize "[%s|%s %s]" 'face 'org-mode-line-clock)
                    (org-duration-from-minutes currently-clocked-time)
                    (org-duration-from-minutes clocked-time)
                    org-clock-heading)))))))
#+end_src

** /ob-php/

#+begin_src elisp
(with-eval-after-load 'ob-php
  (defun org-babel-php-var-to-php (var)
    "Convert an elisp value to a php variable.
Convert an elisp value, VAR, into a string of php source code
specifying a variable of the same value."
    (if (listp var)
        (concat "array(" (mapconcat #'org-babel-python-var-to-python var ", ") ")")
      (if (eq var 'hline)
          "null"
        (format
         "%S"
         (if (stringp var) (substring-no-properties var) var)))))

  (defun org-babel-variable-assignments:php (params)
    "Return a list of php statements assigning the block's variables."
    (mapcar
     (lambda (pair)
       (format "$%s=%s;"
               (car pair)
               (org-babel-php-var-to-php (cdr pair))))
     (org-babel--get-vars params)))

  (defun org-babel-execute:php (body params)
    "Orgmode Babel PHP evaluate function for `BODY' with `PARAMS'."
    (let* ((cmd (concat org-babel-php-command " " org-babel-php-command-options))
           (body (concat "<?php\n"
                         (mapconcat
                          'identity
                          (org-babel-variable-assignments:php params) "\n")
                         "\n"
                         body "\n?>")))
      (org-babel-eval cmd body))))
#+end_src

** CANC /docker/
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
;; (with-eval-after-load 'docker-utils
;;   (when (bug-check-function-bytecode
;;          'docker-utils-generic-action
;;          "wCDBAYMbAAFAwgUFAyO2AolUsgEBQbICggMAtgLDIIc=")
;;     (defun docker-utils-generic-action (action args)
;;       (interactive (list (docker-utils-get-transient-action)
;;                          (transient-args transient-current-command)))
;;       (let ((items (docker-utils-get-marked-items-ids)))
;;         (async-start
;;          `(lambda ()
;;             (load ,(locate-library "s"))
;;             (load ,(locate-library "transient"))
;;             (load ,(locate-library "dash"))
;;             (load ,(locate-library "docker-core"))
;;             (let ((pos (with-current-buffer "*Messages*"
;;                          (point-max))))
;;               (--each (quote ,items)
;;                 (docker-run-docker ,action ,args it))
;;               (with-current-buffer "*Messages*"
;;                 (buffer-substring-no-properties pos (point-max)))))
;;          `(lambda (result)
;;             (message "Async {{{\n%s}}} " result)
;;             (with-current-buffer ,(current-buffer)
;;               (tablist-revert))))))))

(with-eval-after-load 'docker-utils
  ;;;; OVERRIDDEN
  (setq docker-utils-generic-action-count 0)
  (defun docker-utils-generic-action (action args)
    (interactive (list (docker-utils-get-transient-action)
                       (transient-args transient-current-command)))
    ;; (--each (docker-utils-get-marked-items-ids) ;; -
    ;;   (docker-run-docker action args it))       ;; -
    ;; (tablist-revert)                            ;; -
    (let ((buffer (current-buffer))
          (items (docker-utils-get-marked-items-ids)))
      (setq docker-utils-generic-action-count
            (+ (length items)
               docker-utils-generic-action-count))
      (--each items
        (async-start
         `(lambda ()
            (load ,(locate-library "s"))
            (load ,(locate-library "transient"))
            (load ,(locate-library "dash"))
            (load ,(locate-library "docker-core"))
            (let ((pos (with-current-buffer "*Messages*"
                         (point-max))))
              (docker-run-docker ,action ,args ,it)
              (with-current-buffer "*Messages*"
                (buffer-substring-no-properties pos (1- (point-max))))))
         `(lambda (result)
            (message "Async %s" result)
            (cl-decf docker-utils-generic-action-count)
            (when (= 0 docker-utils-generic-action-count)
              (with-current-buffer ,buffer
                (tablist-revert)))))))))
#+end_src

** CANC M-x with bindings help
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
(with-eval-after-load 'simple
  ;;;; OVERRIDDEN
  (defun read-extended-command ()
    "Read command name to invoke in `execute-extended-command'."
    (let ((map (current-local-map)))
      (minibuffer-with-setup-hook
          (lambda ()
            (add-hook 'post-self-insert-hook
                      (lambda ()
                        (setq execute-extended-command--last-typed
                              (minibuffer-contents)))
                      nil 'local)
            (set (make-local-variable 'minibuffer-default-add-function)
                 (lambda ()
                   ;; Get a command name at point in the original buffer
                   ;; to propose it after M-n.
                   (with-current-buffer (window-buffer (minibuffer-selected-window))
                     (and (commandp (function-called-at-point))
                          (format "%S" (function-called-at-point)))))))
        ;; Read a string, completing from and restricting to the set of
        ;; all defined commands.  Don't provide any initial input.
        ;; Save the command read on the extended-command history list.
        (completing-read
         (concat (cond
                  ((eq current-prefix-arg '-) "- ")
                  ((and (consp current-prefix-arg)
                        (eq (car current-prefix-arg) 4)) "C-u ")
                  ((and (consp current-prefix-arg)
                        (integerp (car current-prefix-arg)))
                   (format "%d " (car current-prefix-arg)))
                  ((integerp current-prefix-arg)
                   (format "%d " current-prefix-arg)))
                 ;; This isn't strictly correct if `execute-extended-command'
                 ;; is bound to anything else (e.g. [menu]).
                 ;; It could use (key-description (this-single-command-keys)),
                 ;; but actually a prompt other than "M-x" would be confusing,
                 ;; because "M-x" is a well-known prompt to read a command
                 ;; and it serves as a shorthand for "Extended command: ".
                 "M-x ")
         `(lambda (string pred action)
            (cond
             ((eq action 'metadata)
              '(metadata
                (annotation-function
                 .
                 (lambda (proxy)
                   (when-let ((key-list (where-is-internal
                                         (intern proxy)
                                         (quote ,map))))
                     (concat
                      (make-string (max 2 (- 45 (length proxy))) ? )
                      (mapconcat
                       (lambda (binding)
                         (if (and (stringp binding)
                                  (null (string-empty-p binding)))
                             (concat "`"
                                     (propertize (if (< 18 (length binding))
                                                     (concat
                                                      (substring binding 0 15)
                                                      "...")
                                                   binding)
                                                 'face 'italic)
                                     "'")
                           ""))
                       (mapcar 'key-description
                               (delete nil
                                       (list
                                        (car key-list)
                                        (cadr key-list))))
                       " ")
                      (if (cddr key-list) " ...")))))))
             (t (let ((pred
                       (if (memq action '(nil t))
                           ;; Exclude obsolete commands from completions.
                           `(lambda (sym)
                              (and (funcall (quote ,pred) sym)
                                   (or (equal string (symbol-name sym))
                                       (not (get sym 'byte-obsolete-info)))))
                         pred)))
                  (complete-with-action action obarray string pred)))))
         #'commandp t nil 'extended-command-history)))))
#+end_src

** CANC Show paren at cursor
:PROPERTIES:
:header-args:elisp: :tangle no
:END:

#+begin_src elisp
(with-eval-after-load 'paren
  (when (bug-check-function-bytecode
         'show-paren--locate-near-paren
         "isIgiGApisN/iMQBeIhgKcVgUyHFYCEBQMY9gyIAAYJiAIlAxz2DLQCJgmIACIM1AAGGYgAIgz0AiYZiAAmDVABgBFiDVADFBCGGYgDFA1MhgmIACYViAGADWYViAMUDUyGH")
    (defun show-paren--locate-near-paren ()
      "Locate an unescaped paren \"near\" point to show.
If one is found, return the cons (DIR . OUTSIDE), where DIR is 1
for an open paren, -1 for a close paren, and OUTSIDE is the buffer
position of the outside of the paren.  Otherwise return nil."
      (let ((before (show-paren--categorize-paren (point))))
        (when (or
               (eq (car before) 1)
               (eq (car before) -1))
          before)))))
#+end_src

* Command line arguments

#+begin_src elisp
;; Usage: emacs --exwm
(defun argument--exwm (switch)
  "Command line arg `--exwm'.  SWITCH ignored."
  (exwm-enable))
(add-to-list 'command-switch-alist '("--exwm" . argument--exwm))

;; Usage: emacs --benchmark
(defun argument--benchmark (switch)
  "Command line arg `--benchmark'.  SWITCH ignored."
  (switch-to-buffer "*Benchmarks*"))
(add-to-list 'command-switch-alist '("--benchmark" . argument--benchmark))

(defun argument--all (switch)
  "Command line arg `--all'.  SWITCH ignored."
  (require 'semantic)
  (require 'ede)
  (require 'cc-mode)
  (require 'latex)
  (require 'org)
  (require 'yasnippet))
(add-to-list 'command-switch-alist '("--all" . argument--all))
(defun argument--agenda (switch)
  "Command line arg `--agenda'.  SWITCH ignored."
  (require 'org))
(add-to-list 'command-switch-alist '("--agenda" . argument--agenda))
(defun argument--edit-server (switch)
  "Command line arg `--edit-server'.  SWITCH ignored."
  (require 'edit-server)
  (edit-server-start))
(add-to-list 'command-switch-alist '("--edit-server" . argument--edit-server))
;; Usage: emacs --diff file/dir1 file/dir2
(defun argument--diff (switch)
  "Command line arg `--diff'.  SWITCH ignored."
  (let ((arg1 (pop command-line-args-left))
        (arg2 (pop command-line-args-left))
        (arg3 (pop command-line-args-left)))
    (cond
     ((and
       (file-directory-p arg1)
       (file-directory-p arg2))
      (ediff-directories arg1 arg2 arg3))
     ((and
       (file-exists-p arg1)
       (file-exists-p arg2))
      (ediff-files arg1 arg2))
     (t
      (message "Files or directories required")))))
(add-to-list 'command-switch-alist '("--diff" . argument--diff))
;; Usage: emacs --debug-on-entry el-file func-name
(defun argument--debug-on-entry (switch)
  "Command line arg `--debug-on-entry'.  SWITCH ignored."
  (let ((arg1 (pop command-line-args-left))
        (arg2 (pop command-line-args-left)))
    (eval `(with-eval-after-load ,arg1
             (message "Debugging: %s::%s" ,arg1
                      (debug-on-entry (intern ,arg2)))))))
(add-to-list 'command-switch-alist '("--debug-on-entry" . argument--debug-on-entry))

(put 'list-timers 'disabled nil)
#+end_src
